#![allow(unused, unsafe_code)]
use recapn::prelude::generated as _p;
use super::{__file, __imports};
#[repr(u16)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Default)]
pub enum TestEnum {
    #[default]
    Foo,
    Bar,
    Baz,
    Qux,
    Quux,
    Corge,
    Grault,
    Garply,
}
impl _p::ty::SchemaType for TestEnum {
    const ID: u64 = 11281115850894843091u64;
}
impl core::convert::TryFrom<u16> for TestEnum {
    type Error = _p::NotInSchema;
    #[inline]
    fn try_from(value: u16) -> Result<Self, _p::NotInSchema> {
        match value {
            0u16 => Ok(Self::Foo),
            1u16 => Ok(Self::Bar),
            2u16 => Ok(Self::Baz),
            3u16 => Ok(Self::Qux),
            4u16 => Ok(Self::Quux),
            5u16 => Ok(Self::Corge),
            6u16 => Ok(Self::Grault),
            7u16 => Ok(Self::Garply),
            value => Err(_p::NotInSchema(value)),
        }
    }
}
impl core::convert::From<TestEnum> for u16 {
    #[inline]
    fn from(value: TestEnum) -> Self {
        value as u16
    }
}
impl _p::ty::Enum for TestEnum {}
#[derive(Clone)]
pub struct TestAllTypes<T = _p::Family>(T);
impl _p::ty::SchemaType for TestAllTypes {
    const ID: u64 = 11576770112468509693u64;
}
impl<T> _p::IntoFamily for TestAllTypes<T> {
    type Family = TestAllTypes;
}
impl<T: _p::Capable> _p::Capable for TestAllTypes<T> {
    type Table = T::Table;
    type Imbued = T::Imbued;
    type ImbuedWith<T2: _p::rpc::Table> = TestAllTypes<T::ImbuedWith<T2>>;
    #[inline]
    fn imbued(&self) -> &Self::Imbued {
        self.0.imbued()
    }
    #[inline]
    fn imbue_release<T2: _p::rpc::Table>(
        self,
        new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
    ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
        let (imbued, old) = self.0.imbue_release(new_table);
        (TestAllTypes(imbued), old)
    }
    #[inline]
    fn imbue_release_into<U>(&self, other: U) -> (U::ImbuedWith<Self::Table>, U::Imbued)
    where
        U: _p::Capable,
        U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
    {
        self.0.imbue_release_into(other)
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_all_types::Reader<'a, T> {
    type Ptr = _p::StructReader<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
for test_all_types::Reader<'a, T> {
    #[inline]
    fn from(ptr: _p::StructReader<'a, T>) -> Self {
        TestAllTypes(ptr)
    }
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_all_types::Reader<'a, T>>
for _p::StructReader<'a, T> {
    #[inline]
    fn from(reader: test_all_types::Reader<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
for test_all_types::Reader<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructReader<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructReader for test_all_types::Reader<'a, T> {}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_all_types::Builder<'a, T> {
    type Ptr = _p::StructBuilder<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_all_types::Builder<'a, T>>
for _p::StructBuilder<'a, T> {
    #[inline]
    fn from(reader: test_all_types::Builder<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
for test_all_types::Builder<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
for test_all_types::Builder<'a, T> {
    #[inline]
    fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
        &mut self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for test_all_types::Builder<'a, T> {
    unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
        Self(ptr)
    }
}
impl _p::StructView for TestAllTypes {
    type Reader<'a, T: _p::rpc::Table> = test_all_types::Reader<'a, T>;
    type Builder<'a, T: _p::rpc::Table> = test_all_types::Builder<'a, T>;
}
impl _p::ty::Struct for TestAllTypes {
    const SIZE: _p::StructSize = _p::StructSize {
        data: 6u16,
        ptrs: 20u16,
    };
}
impl TestAllTypes {
    const VOID_FIELD: _p::Descriptor<()> = ();
    const BOOL_FIELD: _p::Descriptor<bool> = _p::Descriptor::<bool> {
        slot: 0u32,
        default: false,
    };
    const INT8_FIELD: _p::Descriptor<i8> = _p::Descriptor::<i8> {
        slot: 1u32,
        default: 0i8,
    };
    const INT16_FIELD: _p::Descriptor<i16> = _p::Descriptor::<i16> {
        slot: 1u32,
        default: 0i16,
    };
    const INT32_FIELD: _p::Descriptor<i32> = _p::Descriptor::<i32> {
        slot: 1u32,
        default: 0i32,
    };
    const INT64_FIELD: _p::Descriptor<i64> = _p::Descriptor::<i64> {
        slot: 1u32,
        default: 0i64,
    };
    const U_INT8_FIELD: _p::Descriptor<u8> = _p::Descriptor::<u8> {
        slot: 16u32,
        default: 0u8,
    };
    const U_INT16_FIELD: _p::Descriptor<u16> = _p::Descriptor::<u16> {
        slot: 9u32,
        default: 0u16,
    };
    const U_INT32_FIELD: _p::Descriptor<u32> = _p::Descriptor::<u32> {
        slot: 5u32,
        default: 0u32,
    };
    const U_INT64_FIELD: _p::Descriptor<u64> = _p::Descriptor::<u64> {
        slot: 3u32,
        default: 0u64,
    };
    const FLOAT32_FIELD: _p::Descriptor<f32> = _p::Descriptor::<f32> {
        slot: 8u32,
        default: 0.0f32,
    };
    const FLOAT64_FIELD: _p::Descriptor<f64> = _p::Descriptor::<f64> {
        slot: 5u32,
        default: 0.0f64,
    };
    const TEXT_FIELD: _p::Descriptor<_p::Text> = _p::Descriptor::<_p::Text> {
        slot: 0u32,
        default: ::core::option::Option::None,
    };
    const DATA_FIELD: _p::Descriptor<_p::Data> = _p::Descriptor::<_p::Data> {
        slot: 1u32,
        default: ::core::option::Option::None,
    };
    const STRUCT_FIELD: _p::Descriptor<_p::Struct<TestAllTypes>> = _p::Descriptor::<
        _p::Struct<TestAllTypes>,
    > {
        slot: 2u32,
        default: ::core::option::Option::None,
    };
    const ENUM_FIELD: _p::Descriptor<_p::Enum<TestEnum>> = _p::Descriptor::<
        _p::Enum<TestEnum>,
    > {
        slot: 18u32,
        default: TestEnum::Foo,
    };
    const INTERFACE_FIELD: _p::Descriptor<()> = ();
    const VOID_LIST: _p::Descriptor<_p::List<()>> = _p::Descriptor::<_p::List<()>> {
        slot: 3u32,
        default: ::core::option::Option::None,
    };
    const BOOL_LIST: _p::Descriptor<_p::List<bool>> = _p::Descriptor::<_p::List<bool>> {
        slot: 4u32,
        default: ::core::option::Option::None,
    };
    const INT8_LIST: _p::Descriptor<_p::List<i8>> = _p::Descriptor::<_p::List<i8>> {
        slot: 5u32,
        default: ::core::option::Option::None,
    };
    const INT16_LIST: _p::Descriptor<_p::List<i16>> = _p::Descriptor::<_p::List<i16>> {
        slot: 6u32,
        default: ::core::option::Option::None,
    };
    const INT32_LIST: _p::Descriptor<_p::List<i32>> = _p::Descriptor::<_p::List<i32>> {
        slot: 7u32,
        default: ::core::option::Option::None,
    };
    const INT64_LIST: _p::Descriptor<_p::List<i64>> = _p::Descriptor::<_p::List<i64>> {
        slot: 8u32,
        default: ::core::option::Option::None,
    };
    const U_INT8_LIST: _p::Descriptor<_p::List<u8>> = _p::Descriptor::<_p::List<u8>> {
        slot: 9u32,
        default: ::core::option::Option::None,
    };
    const U_INT16_LIST: _p::Descriptor<_p::List<u16>> = _p::Descriptor::<_p::List<u16>> {
        slot: 10u32,
        default: ::core::option::Option::None,
    };
    const U_INT32_LIST: _p::Descriptor<_p::List<u32>> = _p::Descriptor::<_p::List<u32>> {
        slot: 11u32,
        default: ::core::option::Option::None,
    };
    const U_INT64_LIST: _p::Descriptor<_p::List<u64>> = _p::Descriptor::<_p::List<u64>> {
        slot: 12u32,
        default: ::core::option::Option::None,
    };
    const FLOAT32_LIST: _p::Descriptor<_p::List<f32>> = _p::Descriptor::<_p::List<f32>> {
        slot: 13u32,
        default: ::core::option::Option::None,
    };
    const FLOAT64_LIST: _p::Descriptor<_p::List<f64>> = _p::Descriptor::<_p::List<f64>> {
        slot: 14u32,
        default: ::core::option::Option::None,
    };
    const TEXT_LIST: _p::Descriptor<_p::List<_p::Text>> = _p::Descriptor::<
        _p::List<_p::Text>,
    > {
        slot: 15u32,
        default: ::core::option::Option::None,
    };
    const DATA_LIST: _p::Descriptor<_p::List<_p::Data>> = _p::Descriptor::<
        _p::List<_p::Data>,
    > {
        slot: 16u32,
        default: ::core::option::Option::None,
    };
    const STRUCT_LIST: _p::Descriptor<_p::List<_p::Struct<TestAllTypes>>> = _p::Descriptor::<
        _p::List<_p::Struct<TestAllTypes>>,
    > {
        slot: 17u32,
        default: ::core::option::Option::None,
    };
    const ENUM_LIST: _p::Descriptor<_p::List<_p::Enum<TestEnum>>> = _p::Descriptor::<
        _p::List<_p::Enum<TestEnum>>,
    > {
        slot: 18u32,
        default: ::core::option::Option::None,
    };
    const INTERFACE_LIST: _p::Descriptor<_p::List<()>> = _p::Descriptor::<_p::List<()>> {
        slot: 19u32,
        default: ::core::option::Option::None,
    };
}
impl<'p, T: _p::rpc::Table + 'p> test_all_types::Reader<'p, T> {
    #[inline]
    pub fn void_field(&self) -> _p::Accessor<'_, 'p, T, ()> {
        unsafe {
            <() as _p::field::FieldType>::accessor(&self.0, &TestAllTypes::VOID_FIELD)
        }
    }
    #[inline]
    pub fn bool_field(&self) -> _p::Accessor<'_, 'p, T, bool> {
        unsafe {
            <bool as _p::field::FieldType>::accessor(&self.0, &TestAllTypes::BOOL_FIELD)
        }
    }
    #[inline]
    pub fn int8_field(&self) -> _p::Accessor<'_, 'p, T, i8> {
        unsafe {
            <i8 as _p::field::FieldType>::accessor(&self.0, &TestAllTypes::INT8_FIELD)
        }
    }
    #[inline]
    pub fn int16_field(&self) -> _p::Accessor<'_, 'p, T, i16> {
        unsafe {
            <i16 as _p::field::FieldType>::accessor(&self.0, &TestAllTypes::INT16_FIELD)
        }
    }
    #[inline]
    pub fn int32_field(&self) -> _p::Accessor<'_, 'p, T, i32> {
        unsafe {
            <i32 as _p::field::FieldType>::accessor(&self.0, &TestAllTypes::INT32_FIELD)
        }
    }
    #[inline]
    pub fn int64_field(&self) -> _p::Accessor<'_, 'p, T, i64> {
        unsafe {
            <i64 as _p::field::FieldType>::accessor(&self.0, &TestAllTypes::INT64_FIELD)
        }
    }
    #[inline]
    pub fn u_int8_field(&self) -> _p::Accessor<'_, 'p, T, u8> {
        unsafe {
            <u8 as _p::field::FieldType>::accessor(&self.0, &TestAllTypes::U_INT8_FIELD)
        }
    }
    #[inline]
    pub fn u_int16_field(&self) -> _p::Accessor<'_, 'p, T, u16> {
        unsafe {
            <u16 as _p::field::FieldType>::accessor(
                &self.0,
                &TestAllTypes::U_INT16_FIELD,
            )
        }
    }
    #[inline]
    pub fn u_int32_field(&self) -> _p::Accessor<'_, 'p, T, u32> {
        unsafe {
            <u32 as _p::field::FieldType>::accessor(
                &self.0,
                &TestAllTypes::U_INT32_FIELD,
            )
        }
    }
    #[inline]
    pub fn u_int64_field(&self) -> _p::Accessor<'_, 'p, T, u64> {
        unsafe {
            <u64 as _p::field::FieldType>::accessor(
                &self.0,
                &TestAllTypes::U_INT64_FIELD,
            )
        }
    }
    #[inline]
    pub fn float32_field(&self) -> _p::Accessor<'_, 'p, T, f32> {
        unsafe {
            <f32 as _p::field::FieldType>::accessor(
                &self.0,
                &TestAllTypes::FLOAT32_FIELD,
            )
        }
    }
    #[inline]
    pub fn float64_field(&self) -> _p::Accessor<'_, 'p, T, f64> {
        unsafe {
            <f64 as _p::field::FieldType>::accessor(
                &self.0,
                &TestAllTypes::FLOAT64_FIELD,
            )
        }
    }
    #[inline]
    pub fn text_field(&self) -> _p::Accessor<'_, 'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(
                &self.0,
                &TestAllTypes::TEXT_FIELD,
            )
        }
    }
    #[inline]
    pub fn data_field(&self) -> _p::Accessor<'_, 'p, T, _p::Data> {
        unsafe {
            <_p::Data as _p::field::FieldType>::accessor(
                &self.0,
                &TestAllTypes::DATA_FIELD,
            )
        }
    }
    #[inline]
    pub fn struct_field(&self) -> _p::Accessor<'_, 'p, T, _p::Struct<TestAllTypes>> {
        unsafe {
            <_p::Struct<
                TestAllTypes,
            > as _p::field::FieldType>::accessor(&self.0, &TestAllTypes::STRUCT_FIELD)
        }
    }
    #[inline]
    pub fn enum_field(&self) -> _p::Accessor<'_, 'p, T, _p::Enum<TestEnum>> {
        unsafe {
            <_p::Enum<
                TestEnum,
            > as _p::field::FieldType>::accessor(&self.0, &TestAllTypes::ENUM_FIELD)
        }
    }
    #[inline]
    pub fn interface_field(&self) -> _p::Accessor<'_, 'p, T, ()> {
        unsafe {
            <() as _p::field::FieldType>::accessor(
                &self.0,
                &TestAllTypes::INTERFACE_FIELD,
            )
        }
    }
    #[inline]
    pub fn void_list(&self) -> _p::Accessor<'_, 'p, T, _p::List<()>> {
        unsafe {
            <_p::List<
                (),
            > as _p::field::FieldType>::accessor(&self.0, &TestAllTypes::VOID_LIST)
        }
    }
    #[inline]
    pub fn bool_list(&self) -> _p::Accessor<'_, 'p, T, _p::List<bool>> {
        unsafe {
            <_p::List<
                bool,
            > as _p::field::FieldType>::accessor(&self.0, &TestAllTypes::BOOL_LIST)
        }
    }
    #[inline]
    pub fn int8_list(&self) -> _p::Accessor<'_, 'p, T, _p::List<i8>> {
        unsafe {
            <_p::List<
                i8,
            > as _p::field::FieldType>::accessor(&self.0, &TestAllTypes::INT8_LIST)
        }
    }
    #[inline]
    pub fn int16_list(&self) -> _p::Accessor<'_, 'p, T, _p::List<i16>> {
        unsafe {
            <_p::List<
                i16,
            > as _p::field::FieldType>::accessor(&self.0, &TestAllTypes::INT16_LIST)
        }
    }
    #[inline]
    pub fn int32_list(&self) -> _p::Accessor<'_, 'p, T, _p::List<i32>> {
        unsafe {
            <_p::List<
                i32,
            > as _p::field::FieldType>::accessor(&self.0, &TestAllTypes::INT32_LIST)
        }
    }
    #[inline]
    pub fn int64_list(&self) -> _p::Accessor<'_, 'p, T, _p::List<i64>> {
        unsafe {
            <_p::List<
                i64,
            > as _p::field::FieldType>::accessor(&self.0, &TestAllTypes::INT64_LIST)
        }
    }
    #[inline]
    pub fn u_int8_list(&self) -> _p::Accessor<'_, 'p, T, _p::List<u8>> {
        unsafe {
            <_p::List<
                u8,
            > as _p::field::FieldType>::accessor(&self.0, &TestAllTypes::U_INT8_LIST)
        }
    }
    #[inline]
    pub fn u_int16_list(&self) -> _p::Accessor<'_, 'p, T, _p::List<u16>> {
        unsafe {
            <_p::List<
                u16,
            > as _p::field::FieldType>::accessor(&self.0, &TestAllTypes::U_INT16_LIST)
        }
    }
    #[inline]
    pub fn u_int32_list(&self) -> _p::Accessor<'_, 'p, T, _p::List<u32>> {
        unsafe {
            <_p::List<
                u32,
            > as _p::field::FieldType>::accessor(&self.0, &TestAllTypes::U_INT32_LIST)
        }
    }
    #[inline]
    pub fn u_int64_list(&self) -> _p::Accessor<'_, 'p, T, _p::List<u64>> {
        unsafe {
            <_p::List<
                u64,
            > as _p::field::FieldType>::accessor(&self.0, &TestAllTypes::U_INT64_LIST)
        }
    }
    #[inline]
    pub fn float32_list(&self) -> _p::Accessor<'_, 'p, T, _p::List<f32>> {
        unsafe {
            <_p::List<
                f32,
            > as _p::field::FieldType>::accessor(&self.0, &TestAllTypes::FLOAT32_LIST)
        }
    }
    #[inline]
    pub fn float64_list(&self) -> _p::Accessor<'_, 'p, T, _p::List<f64>> {
        unsafe {
            <_p::List<
                f64,
            > as _p::field::FieldType>::accessor(&self.0, &TestAllTypes::FLOAT64_LIST)
        }
    }
    #[inline]
    pub fn text_list(&self) -> _p::Accessor<'_, 'p, T, _p::List<_p::Text>> {
        unsafe {
            <_p::List<
                _p::Text,
            > as _p::field::FieldType>::accessor(&self.0, &TestAllTypes::TEXT_LIST)
        }
    }
    #[inline]
    pub fn data_list(&self) -> _p::Accessor<'_, 'p, T, _p::List<_p::Data>> {
        unsafe {
            <_p::List<
                _p::Data,
            > as _p::field::FieldType>::accessor(&self.0, &TestAllTypes::DATA_LIST)
        }
    }
    #[inline]
    pub fn struct_list(
        &self,
    ) -> _p::Accessor<'_, 'p, T, _p::List<_p::Struct<TestAllTypes>>> {
        unsafe {
            <_p::List<
                _p::Struct<TestAllTypes>,
            > as _p::field::FieldType>::accessor(&self.0, &TestAllTypes::STRUCT_LIST)
        }
    }
    #[inline]
    pub fn enum_list(&self) -> _p::Accessor<'_, 'p, T, _p::List<_p::Enum<TestEnum>>> {
        unsafe {
            <_p::List<
                _p::Enum<TestEnum>,
            > as _p::field::FieldType>::accessor(&self.0, &TestAllTypes::ENUM_LIST)
        }
    }
    #[inline]
    pub fn interface_list(&self) -> _p::Accessor<'_, 'p, T, _p::List<()>> {
        unsafe {
            <_p::List<
                (),
            > as _p::field::FieldType>::accessor(&self.0, &TestAllTypes::INTERFACE_LIST)
        }
    }
}
impl<'p, T: _p::rpc::Table + 'p> test_all_types::Builder<'p, T> {
    #[inline]
    pub fn void_field(&mut self) -> _p::AccessorMut<'_, 'p, T, ()> {
        unsafe {
            <() as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestAllTypes::VOID_FIELD,
            )
        }
    }
    #[inline]
    pub fn bool_field(&mut self) -> _p::AccessorMut<'_, 'p, T, bool> {
        unsafe {
            <bool as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestAllTypes::BOOL_FIELD,
            )
        }
    }
    #[inline]
    pub fn int8_field(&mut self) -> _p::AccessorMut<'_, 'p, T, i8> {
        unsafe {
            <i8 as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestAllTypes::INT8_FIELD,
            )
        }
    }
    #[inline]
    pub fn int16_field(&mut self) -> _p::AccessorMut<'_, 'p, T, i16> {
        unsafe {
            <i16 as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestAllTypes::INT16_FIELD,
            )
        }
    }
    #[inline]
    pub fn int32_field(&mut self) -> _p::AccessorMut<'_, 'p, T, i32> {
        unsafe {
            <i32 as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestAllTypes::INT32_FIELD,
            )
        }
    }
    #[inline]
    pub fn int64_field(&mut self) -> _p::AccessorMut<'_, 'p, T, i64> {
        unsafe {
            <i64 as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestAllTypes::INT64_FIELD,
            )
        }
    }
    #[inline]
    pub fn u_int8_field(&mut self) -> _p::AccessorMut<'_, 'p, T, u8> {
        unsafe {
            <u8 as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestAllTypes::U_INT8_FIELD,
            )
        }
    }
    #[inline]
    pub fn u_int16_field(&mut self) -> _p::AccessorMut<'_, 'p, T, u16> {
        unsafe {
            <u16 as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestAllTypes::U_INT16_FIELD,
            )
        }
    }
    #[inline]
    pub fn u_int32_field(&mut self) -> _p::AccessorMut<'_, 'p, T, u32> {
        unsafe {
            <u32 as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestAllTypes::U_INT32_FIELD,
            )
        }
    }
    #[inline]
    pub fn u_int64_field(&mut self) -> _p::AccessorMut<'_, 'p, T, u64> {
        unsafe {
            <u64 as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestAllTypes::U_INT64_FIELD,
            )
        }
    }
    #[inline]
    pub fn float32_field(&mut self) -> _p::AccessorMut<'_, 'p, T, f32> {
        unsafe {
            <f32 as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestAllTypes::FLOAT32_FIELD,
            )
        }
    }
    #[inline]
    pub fn float64_field(&mut self) -> _p::AccessorMut<'_, 'p, T, f64> {
        unsafe {
            <f64 as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestAllTypes::FLOAT64_FIELD,
            )
        }
    }
    #[inline]
    pub fn text_field(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestAllTypes::TEXT_FIELD,
            )
        }
    }
    #[inline]
    pub fn data_field(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Data> {
        unsafe {
            <_p::Data as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestAllTypes::DATA_FIELD,
            )
        }
    }
    #[inline]
    pub fn struct_field(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::Struct<TestAllTypes>> {
        unsafe {
            <_p::Struct<
                TestAllTypes,
            > as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestAllTypes::STRUCT_FIELD,
            )
        }
    }
    #[inline]
    pub fn enum_field(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Enum<TestEnum>> {
        unsafe {
            <_p::Enum<
                TestEnum,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestAllTypes::ENUM_FIELD)
        }
    }
    #[inline]
    pub fn interface_field(&mut self) -> _p::AccessorMut<'_, 'p, T, ()> {
        unsafe {
            <() as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestAllTypes::INTERFACE_FIELD,
            )
        }
    }
    #[inline]
    pub fn void_list(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::List<()>> {
        unsafe {
            <_p::List<
                (),
            > as _p::field::FieldType>::accessor(&mut self.0, &TestAllTypes::VOID_LIST)
        }
    }
    #[inline]
    pub fn bool_list(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::List<bool>> {
        unsafe {
            <_p::List<
                bool,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestAllTypes::BOOL_LIST)
        }
    }
    #[inline]
    pub fn int8_list(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::List<i8>> {
        unsafe {
            <_p::List<
                i8,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestAllTypes::INT8_LIST)
        }
    }
    #[inline]
    pub fn int16_list(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::List<i16>> {
        unsafe {
            <_p::List<
                i16,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestAllTypes::INT16_LIST)
        }
    }
    #[inline]
    pub fn int32_list(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::List<i32>> {
        unsafe {
            <_p::List<
                i32,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestAllTypes::INT32_LIST)
        }
    }
    #[inline]
    pub fn int64_list(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::List<i64>> {
        unsafe {
            <_p::List<
                i64,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestAllTypes::INT64_LIST)
        }
    }
    #[inline]
    pub fn u_int8_list(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::List<u8>> {
        unsafe {
            <_p::List<
                u8,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestAllTypes::U_INT8_LIST)
        }
    }
    #[inline]
    pub fn u_int16_list(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::List<u16>> {
        unsafe {
            <_p::List<
                u16,
            > as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestAllTypes::U_INT16_LIST,
            )
        }
    }
    #[inline]
    pub fn u_int32_list(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::List<u32>> {
        unsafe {
            <_p::List<
                u32,
            > as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestAllTypes::U_INT32_LIST,
            )
        }
    }
    #[inline]
    pub fn u_int64_list(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::List<u64>> {
        unsafe {
            <_p::List<
                u64,
            > as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestAllTypes::U_INT64_LIST,
            )
        }
    }
    #[inline]
    pub fn float32_list(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::List<f32>> {
        unsafe {
            <_p::List<
                f32,
            > as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestAllTypes::FLOAT32_LIST,
            )
        }
    }
    #[inline]
    pub fn float64_list(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::List<f64>> {
        unsafe {
            <_p::List<
                f64,
            > as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestAllTypes::FLOAT64_LIST,
            )
        }
    }
    #[inline]
    pub fn text_list(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::List<_p::Text>> {
        unsafe {
            <_p::List<
                _p::Text,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestAllTypes::TEXT_LIST)
        }
    }
    #[inline]
    pub fn data_list(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::List<_p::Data>> {
        unsafe {
            <_p::List<
                _p::Data,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestAllTypes::DATA_LIST)
        }
    }
    #[inline]
    pub fn struct_list(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::List<_p::Struct<TestAllTypes>>> {
        unsafe {
            <_p::List<
                _p::Struct<TestAllTypes>,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestAllTypes::STRUCT_LIST)
        }
    }
    #[inline]
    pub fn enum_list(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::List<_p::Enum<TestEnum>>> {
        unsafe {
            <_p::List<
                _p::Enum<TestEnum>,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestAllTypes::ENUM_LIST)
        }
    }
    #[inline]
    pub fn interface_list(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::List<()>> {
        unsafe {
            <_p::List<
                (),
            > as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestAllTypes::INTERFACE_LIST,
            )
        }
    }
    #[inline]
    pub fn into_text_field(self) -> _p::AccessorOwned<'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(
                self.0,
                &TestAllTypes::TEXT_FIELD,
            )
        }
    }
    #[inline]
    pub fn into_data_field(self) -> _p::AccessorOwned<'p, T, _p::Data> {
        unsafe {
            <_p::Data as _p::field::FieldType>::accessor(
                self.0,
                &TestAllTypes::DATA_FIELD,
            )
        }
    }
    #[inline]
    pub fn into_struct_field(
        self,
    ) -> _p::AccessorOwned<'p, T, _p::Struct<TestAllTypes>> {
        unsafe {
            <_p::Struct<
                TestAllTypes,
            > as _p::field::FieldType>::accessor(self.0, &TestAllTypes::STRUCT_FIELD)
        }
    }
    #[inline]
    pub fn into_void_list(self) -> _p::AccessorOwned<'p, T, _p::List<()>> {
        unsafe {
            <_p::List<
                (),
            > as _p::field::FieldType>::accessor(self.0, &TestAllTypes::VOID_LIST)
        }
    }
    #[inline]
    pub fn into_bool_list(self) -> _p::AccessorOwned<'p, T, _p::List<bool>> {
        unsafe {
            <_p::List<
                bool,
            > as _p::field::FieldType>::accessor(self.0, &TestAllTypes::BOOL_LIST)
        }
    }
    #[inline]
    pub fn into_int8_list(self) -> _p::AccessorOwned<'p, T, _p::List<i8>> {
        unsafe {
            <_p::List<
                i8,
            > as _p::field::FieldType>::accessor(self.0, &TestAllTypes::INT8_LIST)
        }
    }
    #[inline]
    pub fn into_int16_list(self) -> _p::AccessorOwned<'p, T, _p::List<i16>> {
        unsafe {
            <_p::List<
                i16,
            > as _p::field::FieldType>::accessor(self.0, &TestAllTypes::INT16_LIST)
        }
    }
    #[inline]
    pub fn into_int32_list(self) -> _p::AccessorOwned<'p, T, _p::List<i32>> {
        unsafe {
            <_p::List<
                i32,
            > as _p::field::FieldType>::accessor(self.0, &TestAllTypes::INT32_LIST)
        }
    }
    #[inline]
    pub fn into_int64_list(self) -> _p::AccessorOwned<'p, T, _p::List<i64>> {
        unsafe {
            <_p::List<
                i64,
            > as _p::field::FieldType>::accessor(self.0, &TestAllTypes::INT64_LIST)
        }
    }
    #[inline]
    pub fn into_u_int8_list(self) -> _p::AccessorOwned<'p, T, _p::List<u8>> {
        unsafe {
            <_p::List<
                u8,
            > as _p::field::FieldType>::accessor(self.0, &TestAllTypes::U_INT8_LIST)
        }
    }
    #[inline]
    pub fn into_u_int16_list(self) -> _p::AccessorOwned<'p, T, _p::List<u16>> {
        unsafe {
            <_p::List<
                u16,
            > as _p::field::FieldType>::accessor(self.0, &TestAllTypes::U_INT16_LIST)
        }
    }
    #[inline]
    pub fn into_u_int32_list(self) -> _p::AccessorOwned<'p, T, _p::List<u32>> {
        unsafe {
            <_p::List<
                u32,
            > as _p::field::FieldType>::accessor(self.0, &TestAllTypes::U_INT32_LIST)
        }
    }
    #[inline]
    pub fn into_u_int64_list(self) -> _p::AccessorOwned<'p, T, _p::List<u64>> {
        unsafe {
            <_p::List<
                u64,
            > as _p::field::FieldType>::accessor(self.0, &TestAllTypes::U_INT64_LIST)
        }
    }
    #[inline]
    pub fn into_float32_list(self) -> _p::AccessorOwned<'p, T, _p::List<f32>> {
        unsafe {
            <_p::List<
                f32,
            > as _p::field::FieldType>::accessor(self.0, &TestAllTypes::FLOAT32_LIST)
        }
    }
    #[inline]
    pub fn into_float64_list(self) -> _p::AccessorOwned<'p, T, _p::List<f64>> {
        unsafe {
            <_p::List<
                f64,
            > as _p::field::FieldType>::accessor(self.0, &TestAllTypes::FLOAT64_LIST)
        }
    }
    #[inline]
    pub fn into_text_list(self) -> _p::AccessorOwned<'p, T, _p::List<_p::Text>> {
        unsafe {
            <_p::List<
                _p::Text,
            > as _p::field::FieldType>::accessor(self.0, &TestAllTypes::TEXT_LIST)
        }
    }
    #[inline]
    pub fn into_data_list(self) -> _p::AccessorOwned<'p, T, _p::List<_p::Data>> {
        unsafe {
            <_p::List<
                _p::Data,
            > as _p::field::FieldType>::accessor(self.0, &TestAllTypes::DATA_LIST)
        }
    }
    #[inline]
    pub fn into_struct_list(
        self,
    ) -> _p::AccessorOwned<'p, T, _p::List<_p::Struct<TestAllTypes>>> {
        unsafe {
            <_p::List<
                _p::Struct<TestAllTypes>,
            > as _p::field::FieldType>::accessor(self.0, &TestAllTypes::STRUCT_LIST)
        }
    }
    #[inline]
    pub fn into_enum_list(
        self,
    ) -> _p::AccessorOwned<'p, T, _p::List<_p::Enum<TestEnum>>> {
        unsafe {
            <_p::List<
                _p::Enum<TestEnum>,
            > as _p::field::FieldType>::accessor(self.0, &TestAllTypes::ENUM_LIST)
        }
    }
    #[inline]
    pub fn into_interface_list(self) -> _p::AccessorOwned<'p, T, _p::List<()>> {
        unsafe {
            <_p::List<
                (),
            > as _p::field::FieldType>::accessor(self.0, &TestAllTypes::INTERFACE_LIST)
        }
    }
}
pub mod test_all_types {
    use super::{__file, __imports, _p};
    pub type Reader<'a, T = _p::rpc::Empty> = super::TestAllTypes<
        _p::StructReader<'a, T>,
    >;
    pub type Builder<'a, T = _p::rpc::Empty> = super::TestAllTypes<
        _p::StructBuilder<'a, T>,
    >;
}
#[derive(Clone)]
pub struct TestDefaults<T = _p::Family>(T);
impl _p::ty::SchemaType for TestDefaults {
    const ID: u64 = 16951442063890005174u64;
}
impl<T> _p::IntoFamily for TestDefaults<T> {
    type Family = TestDefaults;
}
impl<T: _p::Capable> _p::Capable for TestDefaults<T> {
    type Table = T::Table;
    type Imbued = T::Imbued;
    type ImbuedWith<T2: _p::rpc::Table> = TestDefaults<T::ImbuedWith<T2>>;
    #[inline]
    fn imbued(&self) -> &Self::Imbued {
        self.0.imbued()
    }
    #[inline]
    fn imbue_release<T2: _p::rpc::Table>(
        self,
        new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
    ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
        let (imbued, old) = self.0.imbue_release(new_table);
        (TestDefaults(imbued), old)
    }
    #[inline]
    fn imbue_release_into<U>(&self, other: U) -> (U::ImbuedWith<Self::Table>, U::Imbued)
    where
        U: _p::Capable,
        U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
    {
        self.0.imbue_release_into(other)
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_defaults::Reader<'a, T> {
    type Ptr = _p::StructReader<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
for test_defaults::Reader<'a, T> {
    #[inline]
    fn from(ptr: _p::StructReader<'a, T>) -> Self {
        TestDefaults(ptr)
    }
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_defaults::Reader<'a, T>>
for _p::StructReader<'a, T> {
    #[inline]
    fn from(reader: test_defaults::Reader<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
for test_defaults::Reader<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructReader<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructReader for test_defaults::Reader<'a, T> {}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_defaults::Builder<'a, T> {
    type Ptr = _p::StructBuilder<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_defaults::Builder<'a, T>>
for _p::StructBuilder<'a, T> {
    #[inline]
    fn from(reader: test_defaults::Builder<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
for test_defaults::Builder<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
for test_defaults::Builder<'a, T> {
    #[inline]
    fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
        &mut self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for test_defaults::Builder<'a, T> {
    unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
        Self(ptr)
    }
}
impl _p::StructView for TestDefaults {
    type Reader<'a, T: _p::rpc::Table> = test_defaults::Reader<'a, T>;
    type Builder<'a, T: _p::rpc::Table> = test_defaults::Builder<'a, T>;
}
impl _p::ty::Struct for TestDefaults {
    const SIZE: _p::StructSize = _p::StructSize {
        data: 6u16,
        ptrs: 20u16,
    };
}
impl TestDefaults {
    const VOID_FIELD: _p::Descriptor<()> = ();
    const BOOL_FIELD: _p::Descriptor<bool> = _p::Descriptor::<bool> {
        slot: 0u32,
        default: true,
    };
    const INT8_FIELD: _p::Descriptor<i8> = _p::Descriptor::<i8> {
        slot: 1u32,
        default: -123i8,
    };
    const INT16_FIELD: _p::Descriptor<i16> = _p::Descriptor::<i16> {
        slot: 1u32,
        default: -12345i16,
    };
    const INT32_FIELD: _p::Descriptor<i32> = _p::Descriptor::<i32> {
        slot: 1u32,
        default: -12345678i32,
    };
    const INT64_FIELD: _p::Descriptor<i64> = _p::Descriptor::<i64> {
        slot: 1u32,
        default: -123456789012345i64,
    };
    const U_INT8_FIELD: _p::Descriptor<u8> = _p::Descriptor::<u8> {
        slot: 16u32,
        default: 234u8,
    };
    const U_INT16_FIELD: _p::Descriptor<u16> = _p::Descriptor::<u16> {
        slot: 9u32,
        default: 45678u16,
    };
    const U_INT32_FIELD: _p::Descriptor<u32> = _p::Descriptor::<u32> {
        slot: 5u32,
        default: 3456789012u32,
    };
    const U_INT64_FIELD: _p::Descriptor<u64> = _p::Descriptor::<u64> {
        slot: 3u32,
        default: 12345678901234567890u64,
    };
    const FLOAT32_FIELD: _p::Descriptor<f32> = _p::Descriptor::<f32> {
        slot: 8u32,
        default: 1234.5f32,
    };
    const FLOAT64_FIELD: _p::Descriptor<f64> = _p::Descriptor::<f64> {
        slot: 5u32,
        default: -123000000000000000000000000000000000000000000000f64,
    };
    const TEXT_FIELD: _p::Descriptor<_p::Text> = _p::Descriptor::<_p::Text> {
        slot: 0u32,
        default: ::core::option::Option::Some(_p::text::Reader::from_slice(b"foo\0")),
    };
    const DATA_FIELD: _p::Descriptor<_p::Data> = _p::Descriptor::<_p::Data> {
        slot: 1u32,
        default: ::core::option::Option::Some(_p::data::Reader::from_slice(b"bar")),
    };
    const STRUCT_FIELD: _p::Descriptor<_p::Struct<TestAllTypes>> = _p::Descriptor::<
        _p::Struct<TestAllTypes>,
    > {
        slot: 2u32,
        default: ::core::option::Option::Some(unsafe {
            _p::StructReader::slice_unchecked(
                &[
                    _p::Word([1u8, 244u8, 128u8, 13u8, 14u8, 16u8, 76u8, 251u8]),
                    _p::Word([78u8, 115u8, 232u8, 56u8, 166u8, 51u8, 0u8, 0u8]),
                    _p::Word([90u8, 0u8, 210u8, 4u8, 20u8, 136u8, 98u8, 3u8]),
                    _p::Word([210u8, 10u8, 111u8, 18u8, 33u8, 25u8, 204u8, 4u8]),
                    _p::Word([95u8, 112u8, 9u8, 175u8, 2u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 144u8, 117u8, 64u8]),
                    _p::Word([77u8, 0u8, 0u8, 0u8, 34u8, 0u8, 0u8, 0u8]),
                    _p::Word([77u8, 0u8, 0u8, 0u8, 26u8, 0u8, 0u8, 0u8]),
                    _p::Word([76u8, 0u8, 0u8, 0u8, 6u8, 0u8, 20u8, 0u8]),
                    _p::Word([1u8, 0u8, 0u8, 0u8, 24u8, 0u8, 0u8, 0u8]),
                    _p::Word([33u8, 1u8, 0u8, 0u8, 41u8, 0u8, 0u8, 0u8]),
                    _p::Word([33u8, 1u8, 0u8, 0u8, 34u8, 0u8, 0u8, 0u8]),
                    _p::Word([33u8, 1u8, 0u8, 0u8, 35u8, 0u8, 0u8, 0u8]),
                    _p::Word([33u8, 1u8, 0u8, 0u8, 36u8, 0u8, 0u8, 0u8]),
                    _p::Word([37u8, 1u8, 0u8, 0u8, 37u8, 0u8, 0u8, 0u8]),
                    _p::Word([49u8, 1u8, 0u8, 0u8, 34u8, 0u8, 0u8, 0u8]),
                    _p::Word([49u8, 1u8, 0u8, 0u8, 35u8, 0u8, 0u8, 0u8]),
                    _p::Word([49u8, 1u8, 0u8, 0u8, 36u8, 0u8, 0u8, 0u8]),
                    _p::Word([53u8, 1u8, 0u8, 0u8, 37u8, 0u8, 0u8, 0u8]),
                    _p::Word([65u8, 1u8, 0u8, 0u8, 52u8, 0u8, 0u8, 0u8]),
                    _p::Word([73u8, 1u8, 0u8, 0u8, 53u8, 0u8, 0u8, 0u8]),
                    _p::Word([93u8, 1u8, 0u8, 0u8, 30u8, 0u8, 0u8, 0u8]),
                    _p::Word([113u8, 1u8, 0u8, 0u8, 30u8, 0u8, 0u8, 0u8]),
                    _p::Word([133u8, 1u8, 0u8, 0u8, 119u8, 2u8, 0u8, 0u8]),
                    _p::Word([213u8, 2u8, 0u8, 0u8, 27u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([98u8, 97u8, 122u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([113u8, 117u8, 120u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([77u8, 0u8, 0u8, 0u8, 58u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([72u8, 0u8, 0u8, 0u8, 6u8, 0u8, 20u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([110u8, 101u8, 115u8, 116u8, 101u8, 100u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([77u8, 0u8, 0u8, 0u8, 114u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([114u8, 101u8, 97u8, 108u8, 108u8, 121u8, 32u8, 110u8]),
                    _p::Word([101u8, 115u8, 116u8, 101u8, 100u8, 0u8, 0u8, 0u8]),
                    _p::Word([26u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([12u8, 222u8, 128u8, 127u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([210u8, 4u8, 210u8, 233u8, 0u8, 128u8, 255u8, 127u8]),
                    _p::Word([78u8, 97u8, 188u8, 0u8, 64u8, 211u8, 160u8, 250u8]),
                    _p::Word([0u8, 0u8, 0u8, 128u8, 255u8, 255u8, 255u8, 127u8]),
                    _p::Word([121u8, 223u8, 13u8, 134u8, 72u8, 112u8, 0u8, 0u8]),
                    _p::Word([46u8, 117u8, 19u8, 253u8, 138u8, 150u8, 253u8, 255u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 128u8]),
                    _p::Word([255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 127u8]),
                    _p::Word([12u8, 34u8, 0u8, 255u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([210u8, 4u8, 46u8, 22u8, 0u8, 0u8, 255u8, 255u8]),
                    _p::Word([78u8, 97u8, 188u8, 0u8, 192u8, 44u8, 95u8, 5u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 255u8, 255u8, 255u8, 255u8]),
                    _p::Word([121u8, 223u8, 13u8, 134u8, 72u8, 112u8, 0u8, 0u8]),
                    _p::Word([210u8, 138u8, 236u8, 2u8, 117u8, 105u8, 2u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 56u8, 180u8, 150u8, 73u8]),
                    _p::Word([194u8, 189u8, 240u8, 124u8, 194u8, 189u8, 240u8, 252u8]),
                    _p::Word([234u8, 28u8, 8u8, 2u8, 234u8, 28u8, 8u8, 130u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([64u8, 222u8, 119u8, 131u8, 33u8, 18u8, 220u8, 66u8]),
                    _p::Word([41u8, 144u8, 35u8, 202u8, 229u8, 200u8, 118u8, 127u8]),
                    _p::Word([41u8, 144u8, 35u8, 202u8, 229u8, 200u8, 118u8, 255u8]),
                    _p::Word([145u8, 247u8, 80u8, 55u8, 158u8, 120u8, 102u8, 0u8]),
                    _p::Word([145u8, 247u8, 80u8, 55u8, 158u8, 120u8, 102u8, 128u8]),
                    _p::Word([9u8, 0u8, 0u8, 0u8, 42u8, 0u8, 0u8, 0u8]),
                    _p::Word([9u8, 0u8, 0u8, 0u8, 50u8, 0u8, 0u8, 0u8]),
                    _p::Word([9u8, 0u8, 0u8, 0u8, 58u8, 0u8, 0u8, 0u8]),
                    _p::Word([113u8, 117u8, 117u8, 120u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([99u8, 111u8, 114u8, 103u8, 101u8, 0u8, 0u8, 0u8]),
                    _p::Word([103u8, 114u8, 97u8, 117u8, 108u8, 116u8, 0u8, 0u8]),
                    _p::Word([9u8, 0u8, 0u8, 0u8, 50u8, 0u8, 0u8, 0u8]),
                    _p::Word([9u8, 0u8, 0u8, 0u8, 42u8, 0u8, 0u8, 0u8]),
                    _p::Word([9u8, 0u8, 0u8, 0u8, 34u8, 0u8, 0u8, 0u8]),
                    _p::Word([103u8, 97u8, 114u8, 112u8, 108u8, 121u8, 0u8, 0u8]),
                    _p::Word([119u8, 97u8, 108u8, 100u8, 111u8, 0u8, 0u8, 0u8]),
                    _p::Word([102u8, 114u8, 101u8, 100u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([12u8, 0u8, 0u8, 0u8, 6u8, 0u8, 20u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([29u8, 1u8, 0u8, 0u8, 122u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([189u8, 0u8, 0u8, 0u8, 122u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([93u8, 0u8, 0u8, 0u8, 122u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([120u8, 32u8, 115u8, 116u8, 114u8, 117u8, 99u8, 116u8]),
                    _p::Word([108u8, 105u8, 115u8, 116u8, 32u8, 49u8, 0u8, 0u8]),
                    _p::Word([120u8, 32u8, 115u8, 116u8, 114u8, 117u8, 99u8, 116u8]),
                    _p::Word([108u8, 105u8, 115u8, 116u8, 32u8, 50u8, 0u8, 0u8]),
                    _p::Word([120u8, 32u8, 115u8, 116u8, 114u8, 117u8, 99u8, 116u8]),
                    _p::Word([108u8, 105u8, 115u8, 116u8, 32u8, 51u8, 0u8, 0u8]),
                    _p::Word([3u8, 0u8, 1u8, 0u8, 6u8, 0u8, 0u8, 0u8]),
                ],
                _p::StructSize {
                    data: 6u16,
                    ptrs: 20u16,
                },
            )
        }),
    };
    const ENUM_FIELD: _p::Descriptor<_p::Enum<TestEnum>> = _p::Descriptor::<
        _p::Enum<TestEnum>,
    > {
        slot: 18u32,
        default: TestEnum::Corge,
    };
    const INTERFACE_FIELD: _p::Descriptor<()> = ();
    const VOID_LIST: _p::Descriptor<_p::List<()>> = _p::Descriptor::<_p::List<()>> {
        slot: 3u32,
        default: ::core::option::Option::Some(unsafe {
            _p::ListReader::slice_unchecked(&[], 6u32, _p::ElementSize::Void)
        }),
    };
    const BOOL_LIST: _p::Descriptor<_p::List<bool>> = _p::Descriptor::<_p::List<bool>> {
        slot: 4u32,
        default: ::core::option::Option::Some(unsafe {
            _p::ListReader::slice_unchecked(
                &[_p::Word([9u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8])],
                4u32,
                _p::ElementSize::Bit,
            )
        }),
    };
    const INT8_LIST: _p::Descriptor<_p::List<i8>> = _p::Descriptor::<_p::List<i8>> {
        slot: 5u32,
        default: ::core::option::Option::Some(unsafe {
            _p::ListReader::slice_unchecked(
                &[_p::Word([111u8, 145u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8])],
                2u32,
                _p::ElementSize::Byte,
            )
        }),
    };
    const INT16_LIST: _p::Descriptor<_p::List<i16>> = _p::Descriptor::<_p::List<i16>> {
        slot: 6u32,
        default: ::core::option::Option::Some(unsafe {
            _p::ListReader::slice_unchecked(
                &[_p::Word([103u8, 43u8, 153u8, 212u8, 0u8, 0u8, 0u8, 0u8])],
                2u32,
                _p::ElementSize::TwoBytes,
            )
        }),
    };
    const INT32_LIST: _p::Descriptor<_p::List<i32>> = _p::Descriptor::<_p::List<i32>> {
        slot: 7u32,
        default: ::core::option::Option::Some(unsafe {
            _p::ListReader::slice_unchecked(
                &[_p::Word([199u8, 107u8, 159u8, 6u8, 57u8, 148u8, 96u8, 249u8])],
                2u32,
                _p::ElementSize::FourBytes,
            )
        }),
    };
    const INT64_LIST: _p::Descriptor<_p::List<i64>> = _p::Descriptor::<_p::List<i64>> {
        slot: 8u32,
        default: ::core::option::Option::Some(unsafe {
            _p::ListReader::slice_unchecked(
                &[
                    _p::Word([199u8, 113u8, 196u8, 43u8, 171u8, 117u8, 107u8, 15u8]),
                    _p::Word([57u8, 142u8, 59u8, 212u8, 84u8, 138u8, 148u8, 240u8]),
                ],
                2u32,
                _p::ElementSize::EightBytes,
            )
        }),
    };
    const U_INT8_LIST: _p::Descriptor<_p::List<u8>> = _p::Descriptor::<_p::List<u8>> {
        slot: 9u32,
        default: ::core::option::Option::Some(unsafe {
            _p::ListReader::slice_unchecked(
                &[_p::Word([111u8, 222u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8])],
                2u32,
                _p::ElementSize::Byte,
            )
        }),
    };
    const U_INT16_LIST: _p::Descriptor<_p::List<u16>> = _p::Descriptor::<_p::List<u16>> {
        slot: 10u32,
        default: ::core::option::Option::Some(unsafe {
            _p::ListReader::slice_unchecked(
                &[_p::Word([53u8, 130u8, 156u8, 173u8, 0u8, 0u8, 0u8, 0u8])],
                2u32,
                _p::ElementSize::TwoBytes,
            )
        }),
    };
    const U_INT32_LIST: _p::Descriptor<_p::List<u32>> = _p::Descriptor::<_p::List<u32>> {
        slot: 11u32,
        default: ::core::option::Option::Some(unsafe {
            _p::ListReader::slice_unchecked(
                &[_p::Word([85u8, 161u8, 174u8, 198u8, 0u8, 0u8, 0u8, 0u8])],
                1u32,
                _p::ElementSize::FourBytes,
            )
        }),
    };
    const U_INT64_LIST: _p::Descriptor<_p::List<u64>> = _p::Descriptor::<_p::List<u64>> {
        slot: 12u32,
        default: ::core::option::Option::Some(unsafe {
            _p::ListReader::slice_unchecked(
                &[_p::Word([199u8, 113u8, 172u8, 181u8, 175u8, 152u8, 50u8, 154u8])],
                1u32,
                _p::ElementSize::EightBytes,
            )
        }),
    };
    const FLOAT32_LIST: _p::Descriptor<_p::List<f32>> = _p::Descriptor::<_p::List<f32>> {
        slot: 13u32,
        default: ::core::option::Option::Some(unsafe {
            _p::ListReader::slice_unchecked(
                &[
                    _p::Word([0u8, 156u8, 173u8, 69u8, 0u8, 0u8, 128u8, 127u8]),
                    _p::Word([0u8, 0u8, 128u8, 255u8, 0u8, 0u8, 192u8, 127u8]),
                ],
                4u32,
                _p::ElementSize::FourBytes,
            )
        }),
    };
    const FLOAT64_LIST: _p::Descriptor<_p::List<f64>> = _p::Descriptor::<_p::List<f64>> {
        slot: 14u32,
        default: ::core::option::Option::Some(unsafe {
            _p::ListReader::slice_unchecked(
                &[
                    _p::Word([0u8, 0u8, 0u8, 0u8, 192u8, 97u8, 190u8, 64u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 240u8, 127u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 240u8, 255u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 248u8, 127u8]),
                ],
                4u32,
                _p::ElementSize::EightBytes,
            )
        }),
    };
    const TEXT_LIST: _p::Descriptor<_p::List<_p::Text>> = _p::Descriptor::<
        _p::List<_p::Text>,
    > {
        slot: 15u32,
        default: ::core::option::Option::Some(unsafe {
            _p::ListReader::slice_unchecked(
                &[
                    _p::Word([9u8, 0u8, 0u8, 0u8, 50u8, 0u8, 0u8, 0u8]),
                    _p::Word([9u8, 0u8, 0u8, 0u8, 50u8, 0u8, 0u8, 0u8]),
                    _p::Word([9u8, 0u8, 0u8, 0u8, 42u8, 0u8, 0u8, 0u8]),
                    _p::Word([112u8, 108u8, 117u8, 103u8, 104u8, 0u8, 0u8, 0u8]),
                    _p::Word([120u8, 121u8, 122u8, 122u8, 121u8, 0u8, 0u8, 0u8]),
                    _p::Word([116u8, 104u8, 117u8, 100u8, 0u8, 0u8, 0u8, 0u8]),
                ],
                3u32,
                _p::ElementSize::Pointer,
            )
        }),
    };
    const DATA_LIST: _p::Descriptor<_p::List<_p::Data>> = _p::Descriptor::<
        _p::List<_p::Data>,
    > {
        slot: 16u32,
        default: ::core::option::Option::Some(unsafe {
            _p::ListReader::slice_unchecked(
                &[
                    _p::Word([9u8, 0u8, 0u8, 0u8, 34u8, 0u8, 0u8, 0u8]),
                    _p::Word([9u8, 0u8, 0u8, 0u8, 74u8, 0u8, 0u8, 0u8]),
                    _p::Word([13u8, 0u8, 0u8, 0u8, 58u8, 0u8, 0u8, 0u8]),
                    _p::Word([111u8, 111u8, 112u8, 115u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([101u8, 120u8, 104u8, 97u8, 117u8, 115u8, 116u8, 101u8]),
                    _p::Word([100u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([114u8, 102u8, 99u8, 51u8, 48u8, 57u8, 50u8, 0u8]),
                ],
                3u32,
                _p::ElementSize::Pointer,
            )
        }),
    };
    const STRUCT_LIST: _p::Descriptor<_p::List<_p::Struct<TestAllTypes>>> = _p::Descriptor::<
        _p::List<_p::Struct<TestAllTypes>>,
    > {
        slot: 17u32,
        default: ::core::option::Option::Some(unsafe {
            _p::ListReader::slice_unchecked(
                &[
                    _p::Word([12u8, 0u8, 0u8, 0u8, 6u8, 0u8, 20u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([29u8, 1u8, 0u8, 0u8, 106u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([189u8, 0u8, 0u8, 0u8, 106u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([93u8, 0u8, 0u8, 0u8, 106u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([115u8, 116u8, 114u8, 117u8, 99u8, 116u8, 108u8, 105u8]),
                    _p::Word([115u8, 116u8, 32u8, 49u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([115u8, 116u8, 114u8, 117u8, 99u8, 116u8, 108u8, 105u8]),
                    _p::Word([115u8, 116u8, 32u8, 50u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([115u8, 116u8, 114u8, 117u8, 99u8, 116u8, 108u8, 105u8]),
                    _p::Word([115u8, 116u8, 32u8, 51u8, 0u8, 0u8, 0u8, 0u8]),
                ],
                3u32,
                _p::ElementSize::InlineComposite(_p::StructSize {
                    data: 6u16,
                    ptrs: 20u16,
                }),
            )
        }),
    };
    const ENUM_LIST: _p::Descriptor<_p::List<_p::Enum<TestEnum>>> = _p::Descriptor::<
        _p::List<_p::Enum<TestEnum>>,
    > {
        slot: 18u32,
        default: ::core::option::Option::Some(unsafe {
            _p::ListReader::slice_unchecked(
                &[_p::Word([0u8, 0u8, 7u8, 0u8, 0u8, 0u8, 0u8, 0u8])],
                2u32,
                _p::ElementSize::TwoBytes,
            )
        }),
    };
    const INTERFACE_LIST: _p::Descriptor<_p::List<()>> = _p::Descriptor::<_p::List<()>> {
        slot: 19u32,
        default: ::core::option::Option::None,
    };
}
impl<'p, T: _p::rpc::Table + 'p> test_defaults::Reader<'p, T> {
    #[inline]
    pub fn void_field(&self) -> _p::Accessor<'_, 'p, T, ()> {
        unsafe {
            <() as _p::field::FieldType>::accessor(&self.0, &TestDefaults::VOID_FIELD)
        }
    }
    #[inline]
    pub fn bool_field(&self) -> _p::Accessor<'_, 'p, T, bool> {
        unsafe {
            <bool as _p::field::FieldType>::accessor(&self.0, &TestDefaults::BOOL_FIELD)
        }
    }
    #[inline]
    pub fn int8_field(&self) -> _p::Accessor<'_, 'p, T, i8> {
        unsafe {
            <i8 as _p::field::FieldType>::accessor(&self.0, &TestDefaults::INT8_FIELD)
        }
    }
    #[inline]
    pub fn int16_field(&self) -> _p::Accessor<'_, 'p, T, i16> {
        unsafe {
            <i16 as _p::field::FieldType>::accessor(&self.0, &TestDefaults::INT16_FIELD)
        }
    }
    #[inline]
    pub fn int32_field(&self) -> _p::Accessor<'_, 'p, T, i32> {
        unsafe {
            <i32 as _p::field::FieldType>::accessor(&self.0, &TestDefaults::INT32_FIELD)
        }
    }
    #[inline]
    pub fn int64_field(&self) -> _p::Accessor<'_, 'p, T, i64> {
        unsafe {
            <i64 as _p::field::FieldType>::accessor(&self.0, &TestDefaults::INT64_FIELD)
        }
    }
    #[inline]
    pub fn u_int8_field(&self) -> _p::Accessor<'_, 'p, T, u8> {
        unsafe {
            <u8 as _p::field::FieldType>::accessor(&self.0, &TestDefaults::U_INT8_FIELD)
        }
    }
    #[inline]
    pub fn u_int16_field(&self) -> _p::Accessor<'_, 'p, T, u16> {
        unsafe {
            <u16 as _p::field::FieldType>::accessor(
                &self.0,
                &TestDefaults::U_INT16_FIELD,
            )
        }
    }
    #[inline]
    pub fn u_int32_field(&self) -> _p::Accessor<'_, 'p, T, u32> {
        unsafe {
            <u32 as _p::field::FieldType>::accessor(
                &self.0,
                &TestDefaults::U_INT32_FIELD,
            )
        }
    }
    #[inline]
    pub fn u_int64_field(&self) -> _p::Accessor<'_, 'p, T, u64> {
        unsafe {
            <u64 as _p::field::FieldType>::accessor(
                &self.0,
                &TestDefaults::U_INT64_FIELD,
            )
        }
    }
    #[inline]
    pub fn float32_field(&self) -> _p::Accessor<'_, 'p, T, f32> {
        unsafe {
            <f32 as _p::field::FieldType>::accessor(
                &self.0,
                &TestDefaults::FLOAT32_FIELD,
            )
        }
    }
    #[inline]
    pub fn float64_field(&self) -> _p::Accessor<'_, 'p, T, f64> {
        unsafe {
            <f64 as _p::field::FieldType>::accessor(
                &self.0,
                &TestDefaults::FLOAT64_FIELD,
            )
        }
    }
    #[inline]
    pub fn text_field(&self) -> _p::Accessor<'_, 'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(
                &self.0,
                &TestDefaults::TEXT_FIELD,
            )
        }
    }
    #[inline]
    pub fn data_field(&self) -> _p::Accessor<'_, 'p, T, _p::Data> {
        unsafe {
            <_p::Data as _p::field::FieldType>::accessor(
                &self.0,
                &TestDefaults::DATA_FIELD,
            )
        }
    }
    #[inline]
    pub fn struct_field(&self) -> _p::Accessor<'_, 'p, T, _p::Struct<TestAllTypes>> {
        unsafe {
            <_p::Struct<
                TestAllTypes,
            > as _p::field::FieldType>::accessor(&self.0, &TestDefaults::STRUCT_FIELD)
        }
    }
    #[inline]
    pub fn enum_field(&self) -> _p::Accessor<'_, 'p, T, _p::Enum<TestEnum>> {
        unsafe {
            <_p::Enum<
                TestEnum,
            > as _p::field::FieldType>::accessor(&self.0, &TestDefaults::ENUM_FIELD)
        }
    }
    #[inline]
    pub fn interface_field(&self) -> _p::Accessor<'_, 'p, T, ()> {
        unsafe {
            <() as _p::field::FieldType>::accessor(
                &self.0,
                &TestDefaults::INTERFACE_FIELD,
            )
        }
    }
    #[inline]
    pub fn void_list(&self) -> _p::Accessor<'_, 'p, T, _p::List<()>> {
        unsafe {
            <_p::List<
                (),
            > as _p::field::FieldType>::accessor(&self.0, &TestDefaults::VOID_LIST)
        }
    }
    #[inline]
    pub fn bool_list(&self) -> _p::Accessor<'_, 'p, T, _p::List<bool>> {
        unsafe {
            <_p::List<
                bool,
            > as _p::field::FieldType>::accessor(&self.0, &TestDefaults::BOOL_LIST)
        }
    }
    #[inline]
    pub fn int8_list(&self) -> _p::Accessor<'_, 'p, T, _p::List<i8>> {
        unsafe {
            <_p::List<
                i8,
            > as _p::field::FieldType>::accessor(&self.0, &TestDefaults::INT8_LIST)
        }
    }
    #[inline]
    pub fn int16_list(&self) -> _p::Accessor<'_, 'p, T, _p::List<i16>> {
        unsafe {
            <_p::List<
                i16,
            > as _p::field::FieldType>::accessor(&self.0, &TestDefaults::INT16_LIST)
        }
    }
    #[inline]
    pub fn int32_list(&self) -> _p::Accessor<'_, 'p, T, _p::List<i32>> {
        unsafe {
            <_p::List<
                i32,
            > as _p::field::FieldType>::accessor(&self.0, &TestDefaults::INT32_LIST)
        }
    }
    #[inline]
    pub fn int64_list(&self) -> _p::Accessor<'_, 'p, T, _p::List<i64>> {
        unsafe {
            <_p::List<
                i64,
            > as _p::field::FieldType>::accessor(&self.0, &TestDefaults::INT64_LIST)
        }
    }
    #[inline]
    pub fn u_int8_list(&self) -> _p::Accessor<'_, 'p, T, _p::List<u8>> {
        unsafe {
            <_p::List<
                u8,
            > as _p::field::FieldType>::accessor(&self.0, &TestDefaults::U_INT8_LIST)
        }
    }
    #[inline]
    pub fn u_int16_list(&self) -> _p::Accessor<'_, 'p, T, _p::List<u16>> {
        unsafe {
            <_p::List<
                u16,
            > as _p::field::FieldType>::accessor(&self.0, &TestDefaults::U_INT16_LIST)
        }
    }
    #[inline]
    pub fn u_int32_list(&self) -> _p::Accessor<'_, 'p, T, _p::List<u32>> {
        unsafe {
            <_p::List<
                u32,
            > as _p::field::FieldType>::accessor(&self.0, &TestDefaults::U_INT32_LIST)
        }
    }
    #[inline]
    pub fn u_int64_list(&self) -> _p::Accessor<'_, 'p, T, _p::List<u64>> {
        unsafe {
            <_p::List<
                u64,
            > as _p::field::FieldType>::accessor(&self.0, &TestDefaults::U_INT64_LIST)
        }
    }
    #[inline]
    pub fn float32_list(&self) -> _p::Accessor<'_, 'p, T, _p::List<f32>> {
        unsafe {
            <_p::List<
                f32,
            > as _p::field::FieldType>::accessor(&self.0, &TestDefaults::FLOAT32_LIST)
        }
    }
    #[inline]
    pub fn float64_list(&self) -> _p::Accessor<'_, 'p, T, _p::List<f64>> {
        unsafe {
            <_p::List<
                f64,
            > as _p::field::FieldType>::accessor(&self.0, &TestDefaults::FLOAT64_LIST)
        }
    }
    #[inline]
    pub fn text_list(&self) -> _p::Accessor<'_, 'p, T, _p::List<_p::Text>> {
        unsafe {
            <_p::List<
                _p::Text,
            > as _p::field::FieldType>::accessor(&self.0, &TestDefaults::TEXT_LIST)
        }
    }
    #[inline]
    pub fn data_list(&self) -> _p::Accessor<'_, 'p, T, _p::List<_p::Data>> {
        unsafe {
            <_p::List<
                _p::Data,
            > as _p::field::FieldType>::accessor(&self.0, &TestDefaults::DATA_LIST)
        }
    }
    #[inline]
    pub fn struct_list(
        &self,
    ) -> _p::Accessor<'_, 'p, T, _p::List<_p::Struct<TestAllTypes>>> {
        unsafe {
            <_p::List<
                _p::Struct<TestAllTypes>,
            > as _p::field::FieldType>::accessor(&self.0, &TestDefaults::STRUCT_LIST)
        }
    }
    #[inline]
    pub fn enum_list(&self) -> _p::Accessor<'_, 'p, T, _p::List<_p::Enum<TestEnum>>> {
        unsafe {
            <_p::List<
                _p::Enum<TestEnum>,
            > as _p::field::FieldType>::accessor(&self.0, &TestDefaults::ENUM_LIST)
        }
    }
    #[inline]
    pub fn interface_list(&self) -> _p::Accessor<'_, 'p, T, _p::List<()>> {
        unsafe {
            <_p::List<
                (),
            > as _p::field::FieldType>::accessor(&self.0, &TestDefaults::INTERFACE_LIST)
        }
    }
}
impl<'p, T: _p::rpc::Table + 'p> test_defaults::Builder<'p, T> {
    #[inline]
    pub fn void_field(&mut self) -> _p::AccessorMut<'_, 'p, T, ()> {
        unsafe {
            <() as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestDefaults::VOID_FIELD,
            )
        }
    }
    #[inline]
    pub fn bool_field(&mut self) -> _p::AccessorMut<'_, 'p, T, bool> {
        unsafe {
            <bool as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestDefaults::BOOL_FIELD,
            )
        }
    }
    #[inline]
    pub fn int8_field(&mut self) -> _p::AccessorMut<'_, 'p, T, i8> {
        unsafe {
            <i8 as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestDefaults::INT8_FIELD,
            )
        }
    }
    #[inline]
    pub fn int16_field(&mut self) -> _p::AccessorMut<'_, 'p, T, i16> {
        unsafe {
            <i16 as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestDefaults::INT16_FIELD,
            )
        }
    }
    #[inline]
    pub fn int32_field(&mut self) -> _p::AccessorMut<'_, 'p, T, i32> {
        unsafe {
            <i32 as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestDefaults::INT32_FIELD,
            )
        }
    }
    #[inline]
    pub fn int64_field(&mut self) -> _p::AccessorMut<'_, 'p, T, i64> {
        unsafe {
            <i64 as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestDefaults::INT64_FIELD,
            )
        }
    }
    #[inline]
    pub fn u_int8_field(&mut self) -> _p::AccessorMut<'_, 'p, T, u8> {
        unsafe {
            <u8 as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestDefaults::U_INT8_FIELD,
            )
        }
    }
    #[inline]
    pub fn u_int16_field(&mut self) -> _p::AccessorMut<'_, 'p, T, u16> {
        unsafe {
            <u16 as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestDefaults::U_INT16_FIELD,
            )
        }
    }
    #[inline]
    pub fn u_int32_field(&mut self) -> _p::AccessorMut<'_, 'p, T, u32> {
        unsafe {
            <u32 as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestDefaults::U_INT32_FIELD,
            )
        }
    }
    #[inline]
    pub fn u_int64_field(&mut self) -> _p::AccessorMut<'_, 'p, T, u64> {
        unsafe {
            <u64 as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestDefaults::U_INT64_FIELD,
            )
        }
    }
    #[inline]
    pub fn float32_field(&mut self) -> _p::AccessorMut<'_, 'p, T, f32> {
        unsafe {
            <f32 as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestDefaults::FLOAT32_FIELD,
            )
        }
    }
    #[inline]
    pub fn float64_field(&mut self) -> _p::AccessorMut<'_, 'p, T, f64> {
        unsafe {
            <f64 as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestDefaults::FLOAT64_FIELD,
            )
        }
    }
    #[inline]
    pub fn text_field(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestDefaults::TEXT_FIELD,
            )
        }
    }
    #[inline]
    pub fn data_field(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Data> {
        unsafe {
            <_p::Data as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestDefaults::DATA_FIELD,
            )
        }
    }
    #[inline]
    pub fn struct_field(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::Struct<TestAllTypes>> {
        unsafe {
            <_p::Struct<
                TestAllTypes,
            > as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestDefaults::STRUCT_FIELD,
            )
        }
    }
    #[inline]
    pub fn enum_field(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Enum<TestEnum>> {
        unsafe {
            <_p::Enum<
                TestEnum,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestDefaults::ENUM_FIELD)
        }
    }
    #[inline]
    pub fn interface_field(&mut self) -> _p::AccessorMut<'_, 'p, T, ()> {
        unsafe {
            <() as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestDefaults::INTERFACE_FIELD,
            )
        }
    }
    #[inline]
    pub fn void_list(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::List<()>> {
        unsafe {
            <_p::List<
                (),
            > as _p::field::FieldType>::accessor(&mut self.0, &TestDefaults::VOID_LIST)
        }
    }
    #[inline]
    pub fn bool_list(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::List<bool>> {
        unsafe {
            <_p::List<
                bool,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestDefaults::BOOL_LIST)
        }
    }
    #[inline]
    pub fn int8_list(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::List<i8>> {
        unsafe {
            <_p::List<
                i8,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestDefaults::INT8_LIST)
        }
    }
    #[inline]
    pub fn int16_list(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::List<i16>> {
        unsafe {
            <_p::List<
                i16,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestDefaults::INT16_LIST)
        }
    }
    #[inline]
    pub fn int32_list(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::List<i32>> {
        unsafe {
            <_p::List<
                i32,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestDefaults::INT32_LIST)
        }
    }
    #[inline]
    pub fn int64_list(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::List<i64>> {
        unsafe {
            <_p::List<
                i64,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestDefaults::INT64_LIST)
        }
    }
    #[inline]
    pub fn u_int8_list(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::List<u8>> {
        unsafe {
            <_p::List<
                u8,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestDefaults::U_INT8_LIST)
        }
    }
    #[inline]
    pub fn u_int16_list(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::List<u16>> {
        unsafe {
            <_p::List<
                u16,
            > as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestDefaults::U_INT16_LIST,
            )
        }
    }
    #[inline]
    pub fn u_int32_list(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::List<u32>> {
        unsafe {
            <_p::List<
                u32,
            > as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestDefaults::U_INT32_LIST,
            )
        }
    }
    #[inline]
    pub fn u_int64_list(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::List<u64>> {
        unsafe {
            <_p::List<
                u64,
            > as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestDefaults::U_INT64_LIST,
            )
        }
    }
    #[inline]
    pub fn float32_list(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::List<f32>> {
        unsafe {
            <_p::List<
                f32,
            > as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestDefaults::FLOAT32_LIST,
            )
        }
    }
    #[inline]
    pub fn float64_list(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::List<f64>> {
        unsafe {
            <_p::List<
                f64,
            > as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestDefaults::FLOAT64_LIST,
            )
        }
    }
    #[inline]
    pub fn text_list(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::List<_p::Text>> {
        unsafe {
            <_p::List<
                _p::Text,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestDefaults::TEXT_LIST)
        }
    }
    #[inline]
    pub fn data_list(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::List<_p::Data>> {
        unsafe {
            <_p::List<
                _p::Data,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestDefaults::DATA_LIST)
        }
    }
    #[inline]
    pub fn struct_list(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::List<_p::Struct<TestAllTypes>>> {
        unsafe {
            <_p::List<
                _p::Struct<TestAllTypes>,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestDefaults::STRUCT_LIST)
        }
    }
    #[inline]
    pub fn enum_list(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::List<_p::Enum<TestEnum>>> {
        unsafe {
            <_p::List<
                _p::Enum<TestEnum>,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestDefaults::ENUM_LIST)
        }
    }
    #[inline]
    pub fn interface_list(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::List<()>> {
        unsafe {
            <_p::List<
                (),
            > as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestDefaults::INTERFACE_LIST,
            )
        }
    }
    #[inline]
    pub fn into_text_field(self) -> _p::AccessorOwned<'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(
                self.0,
                &TestDefaults::TEXT_FIELD,
            )
        }
    }
    #[inline]
    pub fn into_data_field(self) -> _p::AccessorOwned<'p, T, _p::Data> {
        unsafe {
            <_p::Data as _p::field::FieldType>::accessor(
                self.0,
                &TestDefaults::DATA_FIELD,
            )
        }
    }
    #[inline]
    pub fn into_struct_field(
        self,
    ) -> _p::AccessorOwned<'p, T, _p::Struct<TestAllTypes>> {
        unsafe {
            <_p::Struct<
                TestAllTypes,
            > as _p::field::FieldType>::accessor(self.0, &TestDefaults::STRUCT_FIELD)
        }
    }
    #[inline]
    pub fn into_void_list(self) -> _p::AccessorOwned<'p, T, _p::List<()>> {
        unsafe {
            <_p::List<
                (),
            > as _p::field::FieldType>::accessor(self.0, &TestDefaults::VOID_LIST)
        }
    }
    #[inline]
    pub fn into_bool_list(self) -> _p::AccessorOwned<'p, T, _p::List<bool>> {
        unsafe {
            <_p::List<
                bool,
            > as _p::field::FieldType>::accessor(self.0, &TestDefaults::BOOL_LIST)
        }
    }
    #[inline]
    pub fn into_int8_list(self) -> _p::AccessorOwned<'p, T, _p::List<i8>> {
        unsafe {
            <_p::List<
                i8,
            > as _p::field::FieldType>::accessor(self.0, &TestDefaults::INT8_LIST)
        }
    }
    #[inline]
    pub fn into_int16_list(self) -> _p::AccessorOwned<'p, T, _p::List<i16>> {
        unsafe {
            <_p::List<
                i16,
            > as _p::field::FieldType>::accessor(self.0, &TestDefaults::INT16_LIST)
        }
    }
    #[inline]
    pub fn into_int32_list(self) -> _p::AccessorOwned<'p, T, _p::List<i32>> {
        unsafe {
            <_p::List<
                i32,
            > as _p::field::FieldType>::accessor(self.0, &TestDefaults::INT32_LIST)
        }
    }
    #[inline]
    pub fn into_int64_list(self) -> _p::AccessorOwned<'p, T, _p::List<i64>> {
        unsafe {
            <_p::List<
                i64,
            > as _p::field::FieldType>::accessor(self.0, &TestDefaults::INT64_LIST)
        }
    }
    #[inline]
    pub fn into_u_int8_list(self) -> _p::AccessorOwned<'p, T, _p::List<u8>> {
        unsafe {
            <_p::List<
                u8,
            > as _p::field::FieldType>::accessor(self.0, &TestDefaults::U_INT8_LIST)
        }
    }
    #[inline]
    pub fn into_u_int16_list(self) -> _p::AccessorOwned<'p, T, _p::List<u16>> {
        unsafe {
            <_p::List<
                u16,
            > as _p::field::FieldType>::accessor(self.0, &TestDefaults::U_INT16_LIST)
        }
    }
    #[inline]
    pub fn into_u_int32_list(self) -> _p::AccessorOwned<'p, T, _p::List<u32>> {
        unsafe {
            <_p::List<
                u32,
            > as _p::field::FieldType>::accessor(self.0, &TestDefaults::U_INT32_LIST)
        }
    }
    #[inline]
    pub fn into_u_int64_list(self) -> _p::AccessorOwned<'p, T, _p::List<u64>> {
        unsafe {
            <_p::List<
                u64,
            > as _p::field::FieldType>::accessor(self.0, &TestDefaults::U_INT64_LIST)
        }
    }
    #[inline]
    pub fn into_float32_list(self) -> _p::AccessorOwned<'p, T, _p::List<f32>> {
        unsafe {
            <_p::List<
                f32,
            > as _p::field::FieldType>::accessor(self.0, &TestDefaults::FLOAT32_LIST)
        }
    }
    #[inline]
    pub fn into_float64_list(self) -> _p::AccessorOwned<'p, T, _p::List<f64>> {
        unsafe {
            <_p::List<
                f64,
            > as _p::field::FieldType>::accessor(self.0, &TestDefaults::FLOAT64_LIST)
        }
    }
    #[inline]
    pub fn into_text_list(self) -> _p::AccessorOwned<'p, T, _p::List<_p::Text>> {
        unsafe {
            <_p::List<
                _p::Text,
            > as _p::field::FieldType>::accessor(self.0, &TestDefaults::TEXT_LIST)
        }
    }
    #[inline]
    pub fn into_data_list(self) -> _p::AccessorOwned<'p, T, _p::List<_p::Data>> {
        unsafe {
            <_p::List<
                _p::Data,
            > as _p::field::FieldType>::accessor(self.0, &TestDefaults::DATA_LIST)
        }
    }
    #[inline]
    pub fn into_struct_list(
        self,
    ) -> _p::AccessorOwned<'p, T, _p::List<_p::Struct<TestAllTypes>>> {
        unsafe {
            <_p::List<
                _p::Struct<TestAllTypes>,
            > as _p::field::FieldType>::accessor(self.0, &TestDefaults::STRUCT_LIST)
        }
    }
    #[inline]
    pub fn into_enum_list(
        self,
    ) -> _p::AccessorOwned<'p, T, _p::List<_p::Enum<TestEnum>>> {
        unsafe {
            <_p::List<
                _p::Enum<TestEnum>,
            > as _p::field::FieldType>::accessor(self.0, &TestDefaults::ENUM_LIST)
        }
    }
    #[inline]
    pub fn into_interface_list(self) -> _p::AccessorOwned<'p, T, _p::List<()>> {
        unsafe {
            <_p::List<
                (),
            > as _p::field::FieldType>::accessor(self.0, &TestDefaults::INTERFACE_LIST)
        }
    }
}
pub mod test_defaults {
    use super::{__file, __imports, _p};
    pub type Reader<'a, T = _p::rpc::Empty> = super::TestDefaults<
        _p::StructReader<'a, T>,
    >;
    pub type Builder<'a, T = _p::rpc::Empty> = super::TestDefaults<
        _p::StructBuilder<'a, T>,
    >;
}
#[derive(Clone)]
pub struct TestAnyPointer<T = _p::Family>(T);
impl _p::ty::SchemaType for TestAnyPointer {
    const ID: u64 = 16418534539999625432u64;
}
impl<T> _p::IntoFamily for TestAnyPointer<T> {
    type Family = TestAnyPointer;
}
impl<T: _p::Capable> _p::Capable for TestAnyPointer<T> {
    type Table = T::Table;
    type Imbued = T::Imbued;
    type ImbuedWith<T2: _p::rpc::Table> = TestAnyPointer<T::ImbuedWith<T2>>;
    #[inline]
    fn imbued(&self) -> &Self::Imbued {
        self.0.imbued()
    }
    #[inline]
    fn imbue_release<T2: _p::rpc::Table>(
        self,
        new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
    ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
        let (imbued, old) = self.0.imbue_release(new_table);
        (TestAnyPointer(imbued), old)
    }
    #[inline]
    fn imbue_release_into<U>(&self, other: U) -> (U::ImbuedWith<Self::Table>, U::Imbued)
    where
        U: _p::Capable,
        U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
    {
        self.0.imbue_release_into(other)
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_any_pointer::Reader<'a, T> {
    type Ptr = _p::StructReader<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
for test_any_pointer::Reader<'a, T> {
    #[inline]
    fn from(ptr: _p::StructReader<'a, T>) -> Self {
        TestAnyPointer(ptr)
    }
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_any_pointer::Reader<'a, T>>
for _p::StructReader<'a, T> {
    #[inline]
    fn from(reader: test_any_pointer::Reader<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
for test_any_pointer::Reader<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructReader<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructReader for test_any_pointer::Reader<'a, T> {}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_any_pointer::Builder<'a, T> {
    type Ptr = _p::StructBuilder<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_any_pointer::Builder<'a, T>>
for _p::StructBuilder<'a, T> {
    #[inline]
    fn from(reader: test_any_pointer::Builder<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
for test_any_pointer::Builder<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
for test_any_pointer::Builder<'a, T> {
    #[inline]
    fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
        &mut self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for test_any_pointer::Builder<'a, T> {
    unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
        Self(ptr)
    }
}
impl _p::StructView for TestAnyPointer {
    type Reader<'a, T: _p::rpc::Table> = test_any_pointer::Reader<'a, T>;
    type Builder<'a, T: _p::rpc::Table> = test_any_pointer::Builder<'a, T>;
}
impl _p::ty::Struct for TestAnyPointer {
    const SIZE: _p::StructSize = _p::StructSize {
        data: 0u16,
        ptrs: 1u16,
    };
}
impl TestAnyPointer {
    const ANY_POINTER_FIELD: _p::Descriptor<_p::AnyPtr> = _p::Descriptor::<_p::AnyPtr> {
        slot: 0u32,
        default: ::core::option::Option::None,
    };
}
impl<'p, T: _p::rpc::Table + 'p> test_any_pointer::Reader<'p, T> {
    #[inline]
    pub fn any_pointer_field(&self) -> _p::Accessor<'_, 'p, T, _p::AnyPtr> {
        unsafe {
            <_p::AnyPtr as _p::field::FieldType>::accessor(
                &self.0,
                &TestAnyPointer::ANY_POINTER_FIELD,
            )
        }
    }
}
impl<'p, T: _p::rpc::Table + 'p> test_any_pointer::Builder<'p, T> {
    #[inline]
    pub fn any_pointer_field(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::AnyPtr> {
        unsafe {
            <_p::AnyPtr as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestAnyPointer::ANY_POINTER_FIELD,
            )
        }
    }
    #[inline]
    pub fn into_any_pointer_field(self) -> _p::AccessorOwned<'p, T, _p::AnyPtr> {
        unsafe {
            <_p::AnyPtr as _p::field::FieldType>::accessor(
                self.0,
                &TestAnyPointer::ANY_POINTER_FIELD,
            )
        }
    }
}
pub mod test_any_pointer {
    use super::{__file, __imports, _p};
    pub type Reader<'a, T = _p::rpc::Empty> = super::TestAnyPointer<
        _p::StructReader<'a, T>,
    >;
    pub type Builder<'a, T = _p::rpc::Empty> = super::TestAnyPointer<
        _p::StructBuilder<'a, T>,
    >;
}
#[derive(Clone)]
pub struct TestAnyOthers<T = _p::Family>(T);
impl _p::ty::SchemaType for TestAnyOthers {
    const ID: u64 = 17624926160216128089u64;
}
impl<T> _p::IntoFamily for TestAnyOthers<T> {
    type Family = TestAnyOthers;
}
impl<T: _p::Capable> _p::Capable for TestAnyOthers<T> {
    type Table = T::Table;
    type Imbued = T::Imbued;
    type ImbuedWith<T2: _p::rpc::Table> = TestAnyOthers<T::ImbuedWith<T2>>;
    #[inline]
    fn imbued(&self) -> &Self::Imbued {
        self.0.imbued()
    }
    #[inline]
    fn imbue_release<T2: _p::rpc::Table>(
        self,
        new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
    ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
        let (imbued, old) = self.0.imbue_release(new_table);
        (TestAnyOthers(imbued), old)
    }
    #[inline]
    fn imbue_release_into<U>(&self, other: U) -> (U::ImbuedWith<Self::Table>, U::Imbued)
    where
        U: _p::Capable,
        U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
    {
        self.0.imbue_release_into(other)
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_any_others::Reader<'a, T> {
    type Ptr = _p::StructReader<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
for test_any_others::Reader<'a, T> {
    #[inline]
    fn from(ptr: _p::StructReader<'a, T>) -> Self {
        TestAnyOthers(ptr)
    }
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_any_others::Reader<'a, T>>
for _p::StructReader<'a, T> {
    #[inline]
    fn from(reader: test_any_others::Reader<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
for test_any_others::Reader<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructReader<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructReader for test_any_others::Reader<'a, T> {}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_any_others::Builder<'a, T> {
    type Ptr = _p::StructBuilder<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_any_others::Builder<'a, T>>
for _p::StructBuilder<'a, T> {
    #[inline]
    fn from(reader: test_any_others::Builder<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
for test_any_others::Builder<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
for test_any_others::Builder<'a, T> {
    #[inline]
    fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
        &mut self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for test_any_others::Builder<'a, T> {
    unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
        Self(ptr)
    }
}
impl _p::StructView for TestAnyOthers {
    type Reader<'a, T: _p::rpc::Table> = test_any_others::Reader<'a, T>;
    type Builder<'a, T: _p::rpc::Table> = test_any_others::Builder<'a, T>;
}
impl _p::ty::Struct for TestAnyOthers {
    const SIZE: _p::StructSize = _p::StructSize {
        data: 0u16,
        ptrs: 3u16,
    };
}
impl TestAnyOthers {
    const ANY_STRUCT_FIELD: _p::Descriptor<_p::AnyStruct> = _p::Descriptor::<
        _p::AnyStruct,
    > {
        slot: 0u32,
        default: ::core::option::Option::None,
    };
    const ANY_LIST_FIELD: _p::Descriptor<_p::AnyList> = _p::Descriptor::<_p::AnyList> {
        slot: 1u32,
        default: ::core::option::Option::None,
    };
    const CAPABILITY_FIELD: _p::Descriptor<_p::AnyPtr> = _p::Descriptor::<_p::AnyPtr> {
        slot: 2u32,
        default: ::core::option::Option::None,
    };
}
impl<'p, T: _p::rpc::Table + 'p> test_any_others::Reader<'p, T> {
    #[inline]
    pub fn any_struct_field(&self) -> _p::Accessor<'_, 'p, T, _p::AnyStruct> {
        unsafe {
            <_p::AnyStruct as _p::field::FieldType>::accessor(
                &self.0,
                &TestAnyOthers::ANY_STRUCT_FIELD,
            )
        }
    }
    #[inline]
    pub fn any_list_field(&self) -> _p::Accessor<'_, 'p, T, _p::AnyList> {
        unsafe {
            <_p::AnyList as _p::field::FieldType>::accessor(
                &self.0,
                &TestAnyOthers::ANY_LIST_FIELD,
            )
        }
    }
    #[inline]
    pub fn capability_field(&self) -> _p::Accessor<'_, 'p, T, _p::AnyPtr> {
        unsafe {
            <_p::AnyPtr as _p::field::FieldType>::accessor(
                &self.0,
                &TestAnyOthers::CAPABILITY_FIELD,
            )
        }
    }
}
impl<'p, T: _p::rpc::Table + 'p> test_any_others::Builder<'p, T> {
    #[inline]
    pub fn any_struct_field(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::AnyStruct> {
        unsafe {
            <_p::AnyStruct as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestAnyOthers::ANY_STRUCT_FIELD,
            )
        }
    }
    #[inline]
    pub fn any_list_field(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::AnyList> {
        unsafe {
            <_p::AnyList as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestAnyOthers::ANY_LIST_FIELD,
            )
        }
    }
    #[inline]
    pub fn capability_field(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::AnyPtr> {
        unsafe {
            <_p::AnyPtr as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestAnyOthers::CAPABILITY_FIELD,
            )
        }
    }
    #[inline]
    pub fn into_any_struct_field(self) -> _p::AccessorOwned<'p, T, _p::AnyStruct> {
        unsafe {
            <_p::AnyStruct as _p::field::FieldType>::accessor(
                self.0,
                &TestAnyOthers::ANY_STRUCT_FIELD,
            )
        }
    }
    #[inline]
    pub fn into_any_list_field(self) -> _p::AccessorOwned<'p, T, _p::AnyList> {
        unsafe {
            <_p::AnyList as _p::field::FieldType>::accessor(
                self.0,
                &TestAnyOthers::ANY_LIST_FIELD,
            )
        }
    }
    #[inline]
    pub fn into_capability_field(self) -> _p::AccessorOwned<'p, T, _p::AnyPtr> {
        unsafe {
            <_p::AnyPtr as _p::field::FieldType>::accessor(
                self.0,
                &TestAnyOthers::CAPABILITY_FIELD,
            )
        }
    }
}
pub mod test_any_others {
    use super::{__file, __imports, _p};
    pub type Reader<'a, T = _p::rpc::Empty> = super::TestAnyOthers<
        _p::StructReader<'a, T>,
    >;
    pub type Builder<'a, T = _p::rpc::Empty> = super::TestAnyOthers<
        _p::StructBuilder<'a, T>,
    >;
}
#[derive(Clone)]
pub struct TestOutOfOrder<T = _p::Family>(T);
impl _p::ty::SchemaType for TestOutOfOrder {
    const ID: u64 = 12237961271712940587u64;
}
impl<T> _p::IntoFamily for TestOutOfOrder<T> {
    type Family = TestOutOfOrder;
}
impl<T: _p::Capable> _p::Capable for TestOutOfOrder<T> {
    type Table = T::Table;
    type Imbued = T::Imbued;
    type ImbuedWith<T2: _p::rpc::Table> = TestOutOfOrder<T::ImbuedWith<T2>>;
    #[inline]
    fn imbued(&self) -> &Self::Imbued {
        self.0.imbued()
    }
    #[inline]
    fn imbue_release<T2: _p::rpc::Table>(
        self,
        new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
    ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
        let (imbued, old) = self.0.imbue_release(new_table);
        (TestOutOfOrder(imbued), old)
    }
    #[inline]
    fn imbue_release_into<U>(&self, other: U) -> (U::ImbuedWith<Self::Table>, U::Imbued)
    where
        U: _p::Capable,
        U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
    {
        self.0.imbue_release_into(other)
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_out_of_order::Reader<'a, T> {
    type Ptr = _p::StructReader<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
for test_out_of_order::Reader<'a, T> {
    #[inline]
    fn from(ptr: _p::StructReader<'a, T>) -> Self {
        TestOutOfOrder(ptr)
    }
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_out_of_order::Reader<'a, T>>
for _p::StructReader<'a, T> {
    #[inline]
    fn from(reader: test_out_of_order::Reader<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
for test_out_of_order::Reader<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructReader<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructReader for test_out_of_order::Reader<'a, T> {}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_out_of_order::Builder<'a, T> {
    type Ptr = _p::StructBuilder<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_out_of_order::Builder<'a, T>>
for _p::StructBuilder<'a, T> {
    #[inline]
    fn from(reader: test_out_of_order::Builder<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
for test_out_of_order::Builder<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
for test_out_of_order::Builder<'a, T> {
    #[inline]
    fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
        &mut self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for test_out_of_order::Builder<'a, T> {
    unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
        Self(ptr)
    }
}
impl _p::StructView for TestOutOfOrder {
    type Reader<'a, T: _p::rpc::Table> = test_out_of_order::Reader<'a, T>;
    type Builder<'a, T: _p::rpc::Table> = test_out_of_order::Builder<'a, T>;
}
impl _p::ty::Struct for TestOutOfOrder {
    const SIZE: _p::StructSize = _p::StructSize {
        data: 0u16,
        ptrs: 9u16,
    };
}
impl TestOutOfOrder {
    const QUX: _p::Descriptor<_p::Text> = _p::Descriptor::<_p::Text> {
        slot: 0u32,
        default: ::core::option::Option::None,
    };
    const GRAULT: _p::Descriptor<_p::Text> = _p::Descriptor::<_p::Text> {
        slot: 1u32,
        default: ::core::option::Option::None,
    };
    const BAR: _p::Descriptor<_p::Text> = _p::Descriptor::<_p::Text> {
        slot: 2u32,
        default: ::core::option::Option::None,
    };
    const FOO: _p::Descriptor<_p::Text> = _p::Descriptor::<_p::Text> {
        slot: 3u32,
        default: ::core::option::Option::None,
    };
    const CORGE: _p::Descriptor<_p::Text> = _p::Descriptor::<_p::Text> {
        slot: 4u32,
        default: ::core::option::Option::None,
    };
    const WALDO: _p::Descriptor<_p::Text> = _p::Descriptor::<_p::Text> {
        slot: 5u32,
        default: ::core::option::Option::None,
    };
    const QUUX: _p::Descriptor<_p::Text> = _p::Descriptor::<_p::Text> {
        slot: 6u32,
        default: ::core::option::Option::None,
    };
    const GARPLY: _p::Descriptor<_p::Text> = _p::Descriptor::<_p::Text> {
        slot: 7u32,
        default: ::core::option::Option::None,
    };
    const BAZ: _p::Descriptor<_p::Text> = _p::Descriptor::<_p::Text> {
        slot: 8u32,
        default: ::core::option::Option::None,
    };
}
impl<'p, T: _p::rpc::Table + 'p> test_out_of_order::Reader<'p, T> {
    #[inline]
    pub fn qux(&self) -> _p::Accessor<'_, 'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(&self.0, &TestOutOfOrder::QUX)
        }
    }
    #[inline]
    pub fn grault(&self) -> _p::Accessor<'_, 'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(
                &self.0,
                &TestOutOfOrder::GRAULT,
            )
        }
    }
    #[inline]
    pub fn bar(&self) -> _p::Accessor<'_, 'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(&self.0, &TestOutOfOrder::BAR)
        }
    }
    #[inline]
    pub fn foo(&self) -> _p::Accessor<'_, 'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(&self.0, &TestOutOfOrder::FOO)
        }
    }
    #[inline]
    pub fn corge(&self) -> _p::Accessor<'_, 'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(&self.0, &TestOutOfOrder::CORGE)
        }
    }
    #[inline]
    pub fn waldo(&self) -> _p::Accessor<'_, 'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(&self.0, &TestOutOfOrder::WALDO)
        }
    }
    #[inline]
    pub fn quux(&self) -> _p::Accessor<'_, 'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(&self.0, &TestOutOfOrder::QUUX)
        }
    }
    #[inline]
    pub fn garply(&self) -> _p::Accessor<'_, 'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(
                &self.0,
                &TestOutOfOrder::GARPLY,
            )
        }
    }
    #[inline]
    pub fn baz(&self) -> _p::Accessor<'_, 'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(&self.0, &TestOutOfOrder::BAZ)
        }
    }
}
impl<'p, T: _p::rpc::Table + 'p> test_out_of_order::Builder<'p, T> {
    #[inline]
    pub fn qux(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestOutOfOrder::QUX,
            )
        }
    }
    #[inline]
    pub fn grault(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestOutOfOrder::GRAULT,
            )
        }
    }
    #[inline]
    pub fn bar(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestOutOfOrder::BAR,
            )
        }
    }
    #[inline]
    pub fn foo(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestOutOfOrder::FOO,
            )
        }
    }
    #[inline]
    pub fn corge(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestOutOfOrder::CORGE,
            )
        }
    }
    #[inline]
    pub fn waldo(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestOutOfOrder::WALDO,
            )
        }
    }
    #[inline]
    pub fn quux(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestOutOfOrder::QUUX,
            )
        }
    }
    #[inline]
    pub fn garply(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestOutOfOrder::GARPLY,
            )
        }
    }
    #[inline]
    pub fn baz(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestOutOfOrder::BAZ,
            )
        }
    }
    #[inline]
    pub fn into_qux(self) -> _p::AccessorOwned<'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(self.0, &TestOutOfOrder::QUX)
        }
    }
    #[inline]
    pub fn into_grault(self) -> _p::AccessorOwned<'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(self.0, &TestOutOfOrder::GRAULT)
        }
    }
    #[inline]
    pub fn into_bar(self) -> _p::AccessorOwned<'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(self.0, &TestOutOfOrder::BAR)
        }
    }
    #[inline]
    pub fn into_foo(self) -> _p::AccessorOwned<'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(self.0, &TestOutOfOrder::FOO)
        }
    }
    #[inline]
    pub fn into_corge(self) -> _p::AccessorOwned<'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(self.0, &TestOutOfOrder::CORGE)
        }
    }
    #[inline]
    pub fn into_waldo(self) -> _p::AccessorOwned<'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(self.0, &TestOutOfOrder::WALDO)
        }
    }
    #[inline]
    pub fn into_quux(self) -> _p::AccessorOwned<'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(self.0, &TestOutOfOrder::QUUX)
        }
    }
    #[inline]
    pub fn into_garply(self) -> _p::AccessorOwned<'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(self.0, &TestOutOfOrder::GARPLY)
        }
    }
    #[inline]
    pub fn into_baz(self) -> _p::AccessorOwned<'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(self.0, &TestOutOfOrder::BAZ)
        }
    }
}
pub mod test_out_of_order {
    use super::{__file, __imports, _p};
    pub type Reader<'a, T = _p::rpc::Empty> = super::TestOutOfOrder<
        _p::StructReader<'a, T>,
    >;
    pub type Builder<'a, T = _p::rpc::Empty> = super::TestOutOfOrder<
        _p::StructBuilder<'a, T>,
    >;
}
#[derive(Clone)]
pub struct TestUnion<T = _p::Family>(T);
impl _p::ty::SchemaType for TestUnion {
    const ID: u64 = 17615433251264122450u64;
}
impl<T> _p::IntoFamily for TestUnion<T> {
    type Family = TestUnion;
}
impl<T: _p::Capable> _p::Capable for TestUnion<T> {
    type Table = T::Table;
    type Imbued = T::Imbued;
    type ImbuedWith<T2: _p::rpc::Table> = TestUnion<T::ImbuedWith<T2>>;
    #[inline]
    fn imbued(&self) -> &Self::Imbued {
        self.0.imbued()
    }
    #[inline]
    fn imbue_release<T2: _p::rpc::Table>(
        self,
        new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
    ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
        let (imbued, old) = self.0.imbue_release(new_table);
        (TestUnion(imbued), old)
    }
    #[inline]
    fn imbue_release_into<U>(&self, other: U) -> (U::ImbuedWith<Self::Table>, U::Imbued)
    where
        U: _p::Capable,
        U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
    {
        self.0.imbue_release_into(other)
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_union::Reader<'a, T> {
    type Ptr = _p::StructReader<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
for test_union::Reader<'a, T> {
    #[inline]
    fn from(ptr: _p::StructReader<'a, T>) -> Self {
        TestUnion(ptr)
    }
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_union::Reader<'a, T>>
for _p::StructReader<'a, T> {
    #[inline]
    fn from(reader: test_union::Reader<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
for test_union::Reader<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructReader<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructReader for test_union::Reader<'a, T> {}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_union::Builder<'a, T> {
    type Ptr = _p::StructBuilder<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_union::Builder<'a, T>>
for _p::StructBuilder<'a, T> {
    #[inline]
    fn from(reader: test_union::Builder<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
for test_union::Builder<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
for test_union::Builder<'a, T> {
    #[inline]
    fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
        &mut self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for test_union::Builder<'a, T> {
    unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
        Self(ptr)
    }
}
impl _p::StructView for TestUnion {
    type Reader<'a, T: _p::rpc::Table> = test_union::Reader<'a, T>;
    type Builder<'a, T: _p::rpc::Table> = test_union::Builder<'a, T>;
}
impl _p::ty::Struct for TestUnion {
    const SIZE: _p::StructSize = _p::StructSize {
        data: 8u16,
        ptrs: 2u16,
    };
}
impl TestUnion {
    const UNION0: _p::Descriptor<_p::Group<test_union::Union0>> = ();
    const UNION1: _p::Descriptor<_p::Group<test_union::Union1>> = ();
    const UNION2: _p::Descriptor<_p::Group<test_union::Union2>> = ();
    const UNION3: _p::Descriptor<_p::Group<test_union::Union3>> = ();
    const BIT0: _p::Descriptor<bool> = _p::Descriptor::<bool> {
        slot: 128u32,
        default: false,
    };
    const BIT2: _p::Descriptor<bool> = _p::Descriptor::<bool> {
        slot: 130u32,
        default: false,
    };
    const BIT3: _p::Descriptor<bool> = _p::Descriptor::<bool> {
        slot: 131u32,
        default: false,
    };
    const BIT4: _p::Descriptor<bool> = _p::Descriptor::<bool> {
        slot: 132u32,
        default: false,
    };
    const BIT5: _p::Descriptor<bool> = _p::Descriptor::<bool> {
        slot: 133u32,
        default: false,
    };
    const BIT6: _p::Descriptor<bool> = _p::Descriptor::<bool> {
        slot: 134u32,
        default: false,
    };
    const BIT7: _p::Descriptor<bool> = _p::Descriptor::<bool> {
        slot: 135u32,
        default: false,
    };
    const BYTE0: _p::Descriptor<u8> = _p::Descriptor::<u8> {
        slot: 35u32,
        default: 0u8,
    };
}
impl<'p, T: _p::rpc::Table + 'p> test_union::Reader<'p, T> {
    #[inline]
    pub fn union0(&self) -> _p::Accessor<'_, 'p, T, _p::Group<test_union::Union0>> {
        unsafe {
            <_p::Group<
                test_union::Union0,
            > as _p::field::FieldType>::accessor(&self.0, &TestUnion::UNION0)
        }
    }
    #[inline]
    pub fn union1(&self) -> _p::Accessor<'_, 'p, T, _p::Group<test_union::Union1>> {
        unsafe {
            <_p::Group<
                test_union::Union1,
            > as _p::field::FieldType>::accessor(&self.0, &TestUnion::UNION1)
        }
    }
    #[inline]
    pub fn union2(&self) -> _p::Accessor<'_, 'p, T, _p::Group<test_union::Union2>> {
        unsafe {
            <_p::Group<
                test_union::Union2,
            > as _p::field::FieldType>::accessor(&self.0, &TestUnion::UNION2)
        }
    }
    #[inline]
    pub fn union3(&self) -> _p::Accessor<'_, 'p, T, _p::Group<test_union::Union3>> {
        unsafe {
            <_p::Group<
                test_union::Union3,
            > as _p::field::FieldType>::accessor(&self.0, &TestUnion::UNION3)
        }
    }
    #[inline]
    pub fn bit0(&self) -> _p::Accessor<'_, 'p, T, bool> {
        unsafe { <bool as _p::field::FieldType>::accessor(&self.0, &TestUnion::BIT0) }
    }
    #[inline]
    pub fn bit2(&self) -> _p::Accessor<'_, 'p, T, bool> {
        unsafe { <bool as _p::field::FieldType>::accessor(&self.0, &TestUnion::BIT2) }
    }
    #[inline]
    pub fn bit3(&self) -> _p::Accessor<'_, 'p, T, bool> {
        unsafe { <bool as _p::field::FieldType>::accessor(&self.0, &TestUnion::BIT3) }
    }
    #[inline]
    pub fn bit4(&self) -> _p::Accessor<'_, 'p, T, bool> {
        unsafe { <bool as _p::field::FieldType>::accessor(&self.0, &TestUnion::BIT4) }
    }
    #[inline]
    pub fn bit5(&self) -> _p::Accessor<'_, 'p, T, bool> {
        unsafe { <bool as _p::field::FieldType>::accessor(&self.0, &TestUnion::BIT5) }
    }
    #[inline]
    pub fn bit6(&self) -> _p::Accessor<'_, 'p, T, bool> {
        unsafe { <bool as _p::field::FieldType>::accessor(&self.0, &TestUnion::BIT6) }
    }
    #[inline]
    pub fn bit7(&self) -> _p::Accessor<'_, 'p, T, bool> {
        unsafe { <bool as _p::field::FieldType>::accessor(&self.0, &TestUnion::BIT7) }
    }
    #[inline]
    pub fn byte0(&self) -> _p::Accessor<'_, 'p, T, u8> {
        unsafe { <u8 as _p::field::FieldType>::accessor(&self.0, &TestUnion::BYTE0) }
    }
}
impl<'p, T: _p::rpc::Table + 'p> test_union::Builder<'p, T> {
    #[inline]
    pub fn union0(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::Group<test_union::Union0>> {
        unsafe {
            <_p::Group<
                test_union::Union0,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestUnion::UNION0)
        }
    }
    #[inline]
    pub fn union1(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::Group<test_union::Union1>> {
        unsafe {
            <_p::Group<
                test_union::Union1,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestUnion::UNION1)
        }
    }
    #[inline]
    pub fn union2(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::Group<test_union::Union2>> {
        unsafe {
            <_p::Group<
                test_union::Union2,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestUnion::UNION2)
        }
    }
    #[inline]
    pub fn union3(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::Group<test_union::Union3>> {
        unsafe {
            <_p::Group<
                test_union::Union3,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestUnion::UNION3)
        }
    }
    #[inline]
    pub fn bit0(&mut self) -> _p::AccessorMut<'_, 'p, T, bool> {
        unsafe {
            <bool as _p::field::FieldType>::accessor(&mut self.0, &TestUnion::BIT0)
        }
    }
    #[inline]
    pub fn bit2(&mut self) -> _p::AccessorMut<'_, 'p, T, bool> {
        unsafe {
            <bool as _p::field::FieldType>::accessor(&mut self.0, &TestUnion::BIT2)
        }
    }
    #[inline]
    pub fn bit3(&mut self) -> _p::AccessorMut<'_, 'p, T, bool> {
        unsafe {
            <bool as _p::field::FieldType>::accessor(&mut self.0, &TestUnion::BIT3)
        }
    }
    #[inline]
    pub fn bit4(&mut self) -> _p::AccessorMut<'_, 'p, T, bool> {
        unsafe {
            <bool as _p::field::FieldType>::accessor(&mut self.0, &TestUnion::BIT4)
        }
    }
    #[inline]
    pub fn bit5(&mut self) -> _p::AccessorMut<'_, 'p, T, bool> {
        unsafe {
            <bool as _p::field::FieldType>::accessor(&mut self.0, &TestUnion::BIT5)
        }
    }
    #[inline]
    pub fn bit6(&mut self) -> _p::AccessorMut<'_, 'p, T, bool> {
        unsafe {
            <bool as _p::field::FieldType>::accessor(&mut self.0, &TestUnion::BIT6)
        }
    }
    #[inline]
    pub fn bit7(&mut self) -> _p::AccessorMut<'_, 'p, T, bool> {
        unsafe {
            <bool as _p::field::FieldType>::accessor(&mut self.0, &TestUnion::BIT7)
        }
    }
    #[inline]
    pub fn byte0(&mut self) -> _p::AccessorMut<'_, 'p, T, u8> {
        unsafe { <u8 as _p::field::FieldType>::accessor(&mut self.0, &TestUnion::BYTE0) }
    }
    #[inline]
    pub fn into_union0(self) -> _p::AccessorOwned<'p, T, _p::Group<test_union::Union0>> {
        unsafe {
            <_p::Group<
                test_union::Union0,
            > as _p::field::FieldType>::accessor(self.0, &TestUnion::UNION0)
        }
    }
    #[inline]
    pub fn into_union1(self) -> _p::AccessorOwned<'p, T, _p::Group<test_union::Union1>> {
        unsafe {
            <_p::Group<
                test_union::Union1,
            > as _p::field::FieldType>::accessor(self.0, &TestUnion::UNION1)
        }
    }
    #[inline]
    pub fn into_union2(self) -> _p::AccessorOwned<'p, T, _p::Group<test_union::Union2>> {
        unsafe {
            <_p::Group<
                test_union::Union2,
            > as _p::field::FieldType>::accessor(self.0, &TestUnion::UNION2)
        }
    }
    #[inline]
    pub fn into_union3(self) -> _p::AccessorOwned<'p, T, _p::Group<test_union::Union3>> {
        unsafe {
            <_p::Group<
                test_union::Union3,
            > as _p::field::FieldType>::accessor(self.0, &TestUnion::UNION3)
        }
    }
}
pub mod test_union {
    use super::{__file, __imports, _p};
    pub type Reader<'a, T = _p::rpc::Empty> = super::TestUnion<_p::StructReader<'a, T>>;
    pub type Builder<'a, T = _p::rpc::Empty> = super::TestUnion<
        _p::StructBuilder<'a, T>,
    >;
    #[derive(Clone)]
    pub struct Union0<T = _p::Family>(T);
    impl _p::ty::SchemaType for Union0 {
        const ID: u64 = 18191912664303118104u64;
    }
    impl<T> _p::IntoFamily for Union0<T> {
        type Family = Union0;
    }
    impl<T: _p::Capable> _p::Capable for Union0<T> {
        type Table = T::Table;
        type Imbued = T::Imbued;
        type ImbuedWith<T2: _p::rpc::Table> = Union0<T::ImbuedWith<T2>>;
        #[inline]
        fn imbued(&self) -> &Self::Imbued {
            self.0.imbued()
        }
        #[inline]
        fn imbue_release<T2: _p::rpc::Table>(
            self,
            new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
        ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
            let (imbued, old) = self.0.imbue_release(new_table);
            (Union0(imbued), old)
        }
        #[inline]
        fn imbue_release_into<U>(
            &self,
            other: U,
        ) -> (U::ImbuedWith<Self::Table>, U::Imbued)
        where
            U: _p::Capable,
            U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
        {
            self.0.imbue_release_into(other)
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for union0::Reader<'a, T> {
        type Ptr = _p::StructReader<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
    for union0::Reader<'a, T> {
        #[inline]
        fn from(ptr: _p::StructReader<'a, T>) -> Self {
            Union0(ptr)
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<union0::Reader<'a, T>>
    for _p::StructReader<'a, T> {
        #[inline]
        fn from(reader: union0::Reader<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
    for union0::Reader<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructReader<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructReader for union0::Reader<'a, T> {}
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for union0::Builder<'a, T> {
        type Ptr = _p::StructBuilder<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<union0::Builder<'a, T>>
    for _p::StructBuilder<'a, T> {
        #[inline]
        fn from(reader: union0::Builder<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
    for union0::Builder<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
    for union0::Builder<'a, T> {
        #[inline]
        fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
            &mut self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for union0::Builder<'a, T> {
        unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
            Self(ptr)
        }
    }
    impl _p::StructView for Union0 {
        type Reader<'a, T: _p::rpc::Table> = union0::Reader<'a, T>;
        type Builder<'a, T: _p::rpc::Table> = union0::Builder<'a, T>;
    }
    impl _p::FieldGroup for Union0 {
        unsafe fn clear<'a, 'b, T: _p::rpc::Table>(s: &'a mut _p::StructBuilder<'b, T>) {
            s.set_field_unchecked(0usize, 0);
            <() as _p::field::FieldType>::clear(s, &Union0::U0F0S0.field);
        }
    }
    impl Union0 {
        const U0F0S0: _p::VariantDescriptor<()> = _p::VariantDescriptor::<()> {
            variant: _p::VariantInfo {
                slot: 0u32,
                case: 0u16,
            },
            field: (),
        };
        const U0F0S1: _p::VariantDescriptor<bool> = _p::VariantDescriptor::<bool> {
            variant: _p::VariantInfo {
                slot: 0u32,
                case: 1u16,
            },
            field: _p::Descriptor::<bool> {
                slot: 64u32,
                default: false,
            },
        };
        const U0F0S8: _p::VariantDescriptor<i8> = _p::VariantDescriptor::<i8> {
            variant: _p::VariantInfo {
                slot: 0u32,
                case: 2u16,
            },
            field: _p::Descriptor::<i8> {
                slot: 8u32,
                default: 0i8,
            },
        };
        const U0F0S16: _p::VariantDescriptor<i16> = _p::VariantDescriptor::<i16> {
            variant: _p::VariantInfo {
                slot: 0u32,
                case: 3u16,
            },
            field: _p::Descriptor::<i16> {
                slot: 4u32,
                default: 0i16,
            },
        };
        const U0F0S32: _p::VariantDescriptor<i32> = _p::VariantDescriptor::<i32> {
            variant: _p::VariantInfo {
                slot: 0u32,
                case: 4u16,
            },
            field: _p::Descriptor::<i32> {
                slot: 2u32,
                default: 0i32,
            },
        };
        const U0F0S64: _p::VariantDescriptor<i64> = _p::VariantDescriptor::<i64> {
            variant: _p::VariantInfo {
                slot: 0u32,
                case: 5u16,
            },
            field: _p::Descriptor::<i64> {
                slot: 1u32,
                default: 0i64,
            },
        };
        const U0F0SP: _p::VariantDescriptor<_p::Text> = _p::VariantDescriptor::<
            _p::Text,
        > {
            variant: _p::VariantInfo {
                slot: 0u32,
                case: 6u16,
            },
            field: _p::Descriptor::<_p::Text> {
                slot: 0u32,
                default: ::core::option::Option::None,
            },
        };
        const U0F1S0: _p::VariantDescriptor<()> = _p::VariantDescriptor::<()> {
            variant: _p::VariantInfo {
                slot: 0u32,
                case: 7u16,
            },
            field: (),
        };
        const U0F1S1: _p::VariantDescriptor<bool> = _p::VariantDescriptor::<bool> {
            variant: _p::VariantInfo {
                slot: 0u32,
                case: 8u16,
            },
            field: _p::Descriptor::<bool> {
                slot: 64u32,
                default: false,
            },
        };
        const U0F1S8: _p::VariantDescriptor<i8> = _p::VariantDescriptor::<i8> {
            variant: _p::VariantInfo {
                slot: 0u32,
                case: 9u16,
            },
            field: _p::Descriptor::<i8> {
                slot: 8u32,
                default: 0i8,
            },
        };
        const U0F1S16: _p::VariantDescriptor<i16> = _p::VariantDescriptor::<i16> {
            variant: _p::VariantInfo {
                slot: 0u32,
                case: 10u16,
            },
            field: _p::Descriptor::<i16> {
                slot: 4u32,
                default: 0i16,
            },
        };
        const U0F1S32: _p::VariantDescriptor<i32> = _p::VariantDescriptor::<i32> {
            variant: _p::VariantInfo {
                slot: 0u32,
                case: 11u16,
            },
            field: _p::Descriptor::<i32> {
                slot: 2u32,
                default: 0i32,
            },
        };
        const U0F1S64: _p::VariantDescriptor<i64> = _p::VariantDescriptor::<i64> {
            variant: _p::VariantInfo {
                slot: 0u32,
                case: 12u16,
            },
            field: _p::Descriptor::<i64> {
                slot: 1u32,
                default: 0i64,
            },
        };
        const U0F1SP: _p::VariantDescriptor<_p::Text> = _p::VariantDescriptor::<
            _p::Text,
        > {
            variant: _p::VariantInfo {
                slot: 0u32,
                case: 13u16,
            },
            field: _p::Descriptor::<_p::Text> {
                slot: 0u32,
                default: ::core::option::Option::None,
            },
        };
    }
    impl<'p, T: _p::rpc::Table + 'p> union0::Reader<'p, T> {
        #[inline]
        pub fn u0f0s0(&self) -> _p::Variant<'_, 'p, T, ()> {
            unsafe { <() as _p::field::FieldType>::variant(&self.0, &Union0::U0F0S0) }
        }
        #[inline]
        pub fn u0f0s1(&self) -> _p::Variant<'_, 'p, T, bool> {
            unsafe { <bool as _p::field::FieldType>::variant(&self.0, &Union0::U0F0S1) }
        }
        #[inline]
        pub fn u0f0s8(&self) -> _p::Variant<'_, 'p, T, i8> {
            unsafe { <i8 as _p::field::FieldType>::variant(&self.0, &Union0::U0F0S8) }
        }
        #[inline]
        pub fn u0f0s16(&self) -> _p::Variant<'_, 'p, T, i16> {
            unsafe { <i16 as _p::field::FieldType>::variant(&self.0, &Union0::U0F0S16) }
        }
        #[inline]
        pub fn u0f0s32(&self) -> _p::Variant<'_, 'p, T, i32> {
            unsafe { <i32 as _p::field::FieldType>::variant(&self.0, &Union0::U0F0S32) }
        }
        #[inline]
        pub fn u0f0s64(&self) -> _p::Variant<'_, 'p, T, i64> {
            unsafe { <i64 as _p::field::FieldType>::variant(&self.0, &Union0::U0F0S64) }
        }
        #[inline]
        pub fn u0f0sp(&self) -> _p::Variant<'_, 'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::variant(&self.0, &Union0::U0F0SP)
            }
        }
        #[inline]
        pub fn u0f1s0(&self) -> _p::Variant<'_, 'p, T, ()> {
            unsafe { <() as _p::field::FieldType>::variant(&self.0, &Union0::U0F1S0) }
        }
        #[inline]
        pub fn u0f1s1(&self) -> _p::Variant<'_, 'p, T, bool> {
            unsafe { <bool as _p::field::FieldType>::variant(&self.0, &Union0::U0F1S1) }
        }
        #[inline]
        pub fn u0f1s8(&self) -> _p::Variant<'_, 'p, T, i8> {
            unsafe { <i8 as _p::field::FieldType>::variant(&self.0, &Union0::U0F1S8) }
        }
        #[inline]
        pub fn u0f1s16(&self) -> _p::Variant<'_, 'p, T, i16> {
            unsafe { <i16 as _p::field::FieldType>::variant(&self.0, &Union0::U0F1S16) }
        }
        #[inline]
        pub fn u0f1s32(&self) -> _p::Variant<'_, 'p, T, i32> {
            unsafe { <i32 as _p::field::FieldType>::variant(&self.0, &Union0::U0F1S32) }
        }
        #[inline]
        pub fn u0f1s64(&self) -> _p::Variant<'_, 'p, T, i64> {
            unsafe { <i64 as _p::field::FieldType>::variant(&self.0, &Union0::U0F1S64) }
        }
        #[inline]
        pub fn u0f1sp(&self) -> _p::Variant<'_, 'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::variant(&self.0, &Union0::U0F1SP)
            }
        }
        #[inline]
        pub fn which(&self) -> Result<union0::Which<&Self>, _p::NotInSchema> {
            unsafe { <union0::Which<_> as _p::UnionViewer<_>>::get(self) }
        }
    }
    impl<'p, T: _p::rpc::Table + 'p> union0::Builder<'p, T> {
        #[inline]
        pub fn u0f0s0(&mut self) -> _p::VariantMut<'_, 'p, T, ()> {
            unsafe {
                <() as _p::field::FieldType>::variant(&mut self.0, &Union0::U0F0S0)
            }
        }
        #[inline]
        pub fn u0f0s1(&mut self) -> _p::VariantMut<'_, 'p, T, bool> {
            unsafe {
                <bool as _p::field::FieldType>::variant(&mut self.0, &Union0::U0F0S1)
            }
        }
        #[inline]
        pub fn u0f0s8(&mut self) -> _p::VariantMut<'_, 'p, T, i8> {
            unsafe {
                <i8 as _p::field::FieldType>::variant(&mut self.0, &Union0::U0F0S8)
            }
        }
        #[inline]
        pub fn u0f0s16(&mut self) -> _p::VariantMut<'_, 'p, T, i16> {
            unsafe {
                <i16 as _p::field::FieldType>::variant(&mut self.0, &Union0::U0F0S16)
            }
        }
        #[inline]
        pub fn u0f0s32(&mut self) -> _p::VariantMut<'_, 'p, T, i32> {
            unsafe {
                <i32 as _p::field::FieldType>::variant(&mut self.0, &Union0::U0F0S32)
            }
        }
        #[inline]
        pub fn u0f0s64(&mut self) -> _p::VariantMut<'_, 'p, T, i64> {
            unsafe {
                <i64 as _p::field::FieldType>::variant(&mut self.0, &Union0::U0F0S64)
            }
        }
        #[inline]
        pub fn u0f0sp(&mut self) -> _p::VariantMut<'_, 'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::variant(&mut self.0, &Union0::U0F0SP)
            }
        }
        #[inline]
        pub fn u0f1s0(&mut self) -> _p::VariantMut<'_, 'p, T, ()> {
            unsafe {
                <() as _p::field::FieldType>::variant(&mut self.0, &Union0::U0F1S0)
            }
        }
        #[inline]
        pub fn u0f1s1(&mut self) -> _p::VariantMut<'_, 'p, T, bool> {
            unsafe {
                <bool as _p::field::FieldType>::variant(&mut self.0, &Union0::U0F1S1)
            }
        }
        #[inline]
        pub fn u0f1s8(&mut self) -> _p::VariantMut<'_, 'p, T, i8> {
            unsafe {
                <i8 as _p::field::FieldType>::variant(&mut self.0, &Union0::U0F1S8)
            }
        }
        #[inline]
        pub fn u0f1s16(&mut self) -> _p::VariantMut<'_, 'p, T, i16> {
            unsafe {
                <i16 as _p::field::FieldType>::variant(&mut self.0, &Union0::U0F1S16)
            }
        }
        #[inline]
        pub fn u0f1s32(&mut self) -> _p::VariantMut<'_, 'p, T, i32> {
            unsafe {
                <i32 as _p::field::FieldType>::variant(&mut self.0, &Union0::U0F1S32)
            }
        }
        #[inline]
        pub fn u0f1s64(&mut self) -> _p::VariantMut<'_, 'p, T, i64> {
            unsafe {
                <i64 as _p::field::FieldType>::variant(&mut self.0, &Union0::U0F1S64)
            }
        }
        #[inline]
        pub fn u0f1sp(&mut self) -> _p::VariantMut<'_, 'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::variant(&mut self.0, &Union0::U0F1SP)
            }
        }
        #[inline]
        pub fn into_u0f0sp(self) -> _p::VariantOwned<'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::variant(self.0, &Union0::U0F0SP)
            }
        }
        #[inline]
        pub fn into_u0f1sp(self) -> _p::VariantOwned<'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::variant(self.0, &Union0::U0F1SP)
            }
        }
        #[inline]
        pub fn which(&mut self) -> Result<union0::Which<&mut Self>, _p::NotInSchema> {
            unsafe { <union0::Which<_> as _p::UnionViewer<_>>::get(self) }
        }
    }
    pub mod union0 {
        use super::{__file, __imports, _p};
        pub type Reader<'a, T = _p::rpc::Empty> = super::Union0<_p::StructReader<'a, T>>;
        pub type Builder<'a, T = _p::rpc::Empty> = super::Union0<
            _p::StructBuilder<'a, T>,
        >;
        pub enum Which<T: _p::Viewable = _p::Family> {
            U0f0s0(_p::ViewOf<T, ()>),
            U0f0s1(_p::ViewOf<T, bool>),
            U0f0s8(_p::ViewOf<T, i8>),
            U0f0s16(_p::ViewOf<T, i16>),
            U0f0s32(_p::ViewOf<T, i32>),
            U0f0s64(_p::ViewOf<T, i64>),
            U0f0sp(_p::ViewOf<T, _p::Text>),
            U0f1s0(_p::ViewOf<T, ()>),
            U0f1s1(_p::ViewOf<T, bool>),
            U0f1s8(_p::ViewOf<T, i8>),
            U0f1s16(_p::ViewOf<T, i16>),
            U0f1s32(_p::ViewOf<T, i32>),
            U0f1s64(_p::ViewOf<T, i64>),
            U0f1sp(_p::ViewOf<T, _p::Text>),
        }
        impl<'b, 'p: 'b, T: _p::Table + 'p> _p::UnionViewer<&'b Reader<'p, T>>
        for Which {
            type View = Which<&'b Reader<'p, T>>;
            unsafe fn get(
                repr: &'b Reader<'p, T>,
            ) -> Result<Self::View, _p::NotInSchema> {
                let tag = repr.0.data_field::<u16>(0usize);
                match tag {
                    0u16 => {
                        Ok(
                            Which::U0f0s0(
                                <() as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Union0::U0F0S0.field,
                                ),
                            ),
                        )
                    }
                    1u16 => {
                        Ok(
                            Which::U0f0s1(
                                <bool as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Union0::U0F0S1.field,
                                ),
                            ),
                        )
                    }
                    2u16 => {
                        Ok(
                            Which::U0f0s8(
                                <i8 as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Union0::U0F0S8.field,
                                ),
                            ),
                        )
                    }
                    3u16 => {
                        Ok(
                            Which::U0f0s16(
                                <i16 as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Union0::U0F0S16.field,
                                ),
                            ),
                        )
                    }
                    4u16 => {
                        Ok(
                            Which::U0f0s32(
                                <i32 as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Union0::U0F0S32.field,
                                ),
                            ),
                        )
                    }
                    5u16 => {
                        Ok(
                            Which::U0f0s64(
                                <i64 as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Union0::U0F0S64.field,
                                ),
                            ),
                        )
                    }
                    6u16 => {
                        Ok(
                            Which::U0f0sp(
                                <_p::Text as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Union0::U0F0SP.field,
                                ),
                            ),
                        )
                    }
                    7u16 => {
                        Ok(
                            Which::U0f1s0(
                                <() as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Union0::U0F1S0.field,
                                ),
                            ),
                        )
                    }
                    8u16 => {
                        Ok(
                            Which::U0f1s1(
                                <bool as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Union0::U0F1S1.field,
                                ),
                            ),
                        )
                    }
                    9u16 => {
                        Ok(
                            Which::U0f1s8(
                                <i8 as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Union0::U0F1S8.field,
                                ),
                            ),
                        )
                    }
                    10u16 => {
                        Ok(
                            Which::U0f1s16(
                                <i16 as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Union0::U0F1S16.field,
                                ),
                            ),
                        )
                    }
                    11u16 => {
                        Ok(
                            Which::U0f1s32(
                                <i32 as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Union0::U0F1S32.field,
                                ),
                            ),
                        )
                    }
                    12u16 => {
                        Ok(
                            Which::U0f1s64(
                                <i64 as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Union0::U0F1S64.field,
                                ),
                            ),
                        )
                    }
                    13u16 => {
                        Ok(
                            Which::U0f1sp(
                                <_p::Text as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Union0::U0F1SP.field,
                                ),
                            ),
                        )
                    }
                    unknown => Err(_p::NotInSchema(unknown)),
                }
            }
        }
        impl<'b, 'p: 'b, T: _p::Table + 'p> _p::UnionViewer<&'b mut Builder<'p, T>>
        for Which {
            type View = Which<&'b mut Builder<'p, T>>;
            unsafe fn get(
                repr: &'b mut Builder<'p, T>,
            ) -> Result<Self::View, _p::NotInSchema> {
                let tag = repr.0.data_field::<u16>(0usize);
                match tag {
                    0u16 => {
                        Ok(
                            Which::U0f0s0(
                                <() as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Union0::U0F0S0.field,
                                ),
                            ),
                        )
                    }
                    1u16 => {
                        Ok(
                            Which::U0f0s1(
                                <bool as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Union0::U0F0S1.field,
                                ),
                            ),
                        )
                    }
                    2u16 => {
                        Ok(
                            Which::U0f0s8(
                                <i8 as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Union0::U0F0S8.field,
                                ),
                            ),
                        )
                    }
                    3u16 => {
                        Ok(
                            Which::U0f0s16(
                                <i16 as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Union0::U0F0S16.field,
                                ),
                            ),
                        )
                    }
                    4u16 => {
                        Ok(
                            Which::U0f0s32(
                                <i32 as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Union0::U0F0S32.field,
                                ),
                            ),
                        )
                    }
                    5u16 => {
                        Ok(
                            Which::U0f0s64(
                                <i64 as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Union0::U0F0S64.field,
                                ),
                            ),
                        )
                    }
                    6u16 => {
                        Ok(
                            Which::U0f0sp(
                                <_p::Text as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Union0::U0F0SP.field,
                                ),
                            ),
                        )
                    }
                    7u16 => {
                        Ok(
                            Which::U0f1s0(
                                <() as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Union0::U0F1S0.field,
                                ),
                            ),
                        )
                    }
                    8u16 => {
                        Ok(
                            Which::U0f1s1(
                                <bool as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Union0::U0F1S1.field,
                                ),
                            ),
                        )
                    }
                    9u16 => {
                        Ok(
                            Which::U0f1s8(
                                <i8 as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Union0::U0F1S8.field,
                                ),
                            ),
                        )
                    }
                    10u16 => {
                        Ok(
                            Which::U0f1s16(
                                <i16 as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Union0::U0F1S16.field,
                                ),
                            ),
                        )
                    }
                    11u16 => {
                        Ok(
                            Which::U0f1s32(
                                <i32 as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Union0::U0F1S32.field,
                                ),
                            ),
                        )
                    }
                    12u16 => {
                        Ok(
                            Which::U0f1s64(
                                <i64 as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Union0::U0F1S64.field,
                                ),
                            ),
                        )
                    }
                    13u16 => {
                        Ok(
                            Which::U0f1sp(
                                <_p::Text as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Union0::U0F1SP.field,
                                ),
                            ),
                        )
                    }
                    unknown => Err(_p::NotInSchema(unknown)),
                }
            }
        }
    }
    #[derive(Clone)]
    pub struct Union1<T = _p::Family>(T);
    impl _p::ty::SchemaType for Union1 {
        const ID: u64 = 17152640438752803506u64;
    }
    impl<T> _p::IntoFamily for Union1<T> {
        type Family = Union1;
    }
    impl<T: _p::Capable> _p::Capable for Union1<T> {
        type Table = T::Table;
        type Imbued = T::Imbued;
        type ImbuedWith<T2: _p::rpc::Table> = Union1<T::ImbuedWith<T2>>;
        #[inline]
        fn imbued(&self) -> &Self::Imbued {
            self.0.imbued()
        }
        #[inline]
        fn imbue_release<T2: _p::rpc::Table>(
            self,
            new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
        ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
            let (imbued, old) = self.0.imbue_release(new_table);
            (Union1(imbued), old)
        }
        #[inline]
        fn imbue_release_into<U>(
            &self,
            other: U,
        ) -> (U::ImbuedWith<Self::Table>, U::Imbued)
        where
            U: _p::Capable,
            U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
        {
            self.0.imbue_release_into(other)
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for union1::Reader<'a, T> {
        type Ptr = _p::StructReader<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
    for union1::Reader<'a, T> {
        #[inline]
        fn from(ptr: _p::StructReader<'a, T>) -> Self {
            Union1(ptr)
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<union1::Reader<'a, T>>
    for _p::StructReader<'a, T> {
        #[inline]
        fn from(reader: union1::Reader<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
    for union1::Reader<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructReader<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructReader for union1::Reader<'a, T> {}
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for union1::Builder<'a, T> {
        type Ptr = _p::StructBuilder<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<union1::Builder<'a, T>>
    for _p::StructBuilder<'a, T> {
        #[inline]
        fn from(reader: union1::Builder<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
    for union1::Builder<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
    for union1::Builder<'a, T> {
        #[inline]
        fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
            &mut self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for union1::Builder<'a, T> {
        unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
            Self(ptr)
        }
    }
    impl _p::StructView for Union1 {
        type Reader<'a, T: _p::rpc::Table> = union1::Reader<'a, T>;
        type Builder<'a, T: _p::rpc::Table> = union1::Builder<'a, T>;
    }
    impl _p::FieldGroup for Union1 {
        unsafe fn clear<'a, 'b, T: _p::rpc::Table>(s: &'a mut _p::StructBuilder<'b, T>) {
            s.set_field_unchecked(1usize, 0);
            <() as _p::field::FieldType>::clear(s, &Union1::U1F0S0.field);
        }
    }
    impl Union1 {
        const U1F0S0: _p::VariantDescriptor<()> = _p::VariantDescriptor::<()> {
            variant: _p::VariantInfo {
                slot: 1u32,
                case: 0u16,
            },
            field: (),
        };
        const U1F0S1: _p::VariantDescriptor<bool> = _p::VariantDescriptor::<bool> {
            variant: _p::VariantInfo {
                slot: 1u32,
                case: 1u16,
            },
            field: _p::Descriptor::<bool> {
                slot: 129u32,
                default: false,
            },
        };
        const U1F1S1: _p::VariantDescriptor<bool> = _p::VariantDescriptor::<bool> {
            variant: _p::VariantInfo {
                slot: 1u32,
                case: 2u16,
            },
            field: _p::Descriptor::<bool> {
                slot: 129u32,
                default: false,
            },
        };
        const U1F0S8: _p::VariantDescriptor<i8> = _p::VariantDescriptor::<i8> {
            variant: _p::VariantInfo {
                slot: 1u32,
                case: 3u16,
            },
            field: _p::Descriptor::<i8> {
                slot: 17u32,
                default: 0i8,
            },
        };
        const U1F1S8: _p::VariantDescriptor<i8> = _p::VariantDescriptor::<i8> {
            variant: _p::VariantInfo {
                slot: 1u32,
                case: 4u16,
            },
            field: _p::Descriptor::<i8> {
                slot: 17u32,
                default: 0i8,
            },
        };
        const U1F0S16: _p::VariantDescriptor<i16> = _p::VariantDescriptor::<i16> {
            variant: _p::VariantInfo {
                slot: 1u32,
                case: 5u16,
            },
            field: _p::Descriptor::<i16> {
                slot: 9u32,
                default: 0i16,
            },
        };
        const U1F1S16: _p::VariantDescriptor<i16> = _p::VariantDescriptor::<i16> {
            variant: _p::VariantInfo {
                slot: 1u32,
                case: 6u16,
            },
            field: _p::Descriptor::<i16> {
                slot: 9u32,
                default: 0i16,
            },
        };
        const U1F0S32: _p::VariantDescriptor<i32> = _p::VariantDescriptor::<i32> {
            variant: _p::VariantInfo {
                slot: 1u32,
                case: 7u16,
            },
            field: _p::Descriptor::<i32> {
                slot: 5u32,
                default: 0i32,
            },
        };
        const U1F1S32: _p::VariantDescriptor<i32> = _p::VariantDescriptor::<i32> {
            variant: _p::VariantInfo {
                slot: 1u32,
                case: 8u16,
            },
            field: _p::Descriptor::<i32> {
                slot: 5u32,
                default: 0i32,
            },
        };
        const U1F0S64: _p::VariantDescriptor<i64> = _p::VariantDescriptor::<i64> {
            variant: _p::VariantInfo {
                slot: 1u32,
                case: 9u16,
            },
            field: _p::Descriptor::<i64> {
                slot: 3u32,
                default: 0i64,
            },
        };
        const U1F1S64: _p::VariantDescriptor<i64> = _p::VariantDescriptor::<i64> {
            variant: _p::VariantInfo {
                slot: 1u32,
                case: 10u16,
            },
            field: _p::Descriptor::<i64> {
                slot: 3u32,
                default: 0i64,
            },
        };
        const U1F0SP: _p::VariantDescriptor<_p::Text> = _p::VariantDescriptor::<
            _p::Text,
        > {
            variant: _p::VariantInfo {
                slot: 1u32,
                case: 11u16,
            },
            field: _p::Descriptor::<_p::Text> {
                slot: 1u32,
                default: ::core::option::Option::None,
            },
        };
        const U1F1SP: _p::VariantDescriptor<_p::Text> = _p::VariantDescriptor::<
            _p::Text,
        > {
            variant: _p::VariantInfo {
                slot: 1u32,
                case: 12u16,
            },
            field: _p::Descriptor::<_p::Text> {
                slot: 1u32,
                default: ::core::option::Option::None,
            },
        };
        const U1F2S0: _p::VariantDescriptor<()> = _p::VariantDescriptor::<()> {
            variant: _p::VariantInfo {
                slot: 1u32,
                case: 13u16,
            },
            field: (),
        };
        const U1F2S1: _p::VariantDescriptor<bool> = _p::VariantDescriptor::<bool> {
            variant: _p::VariantInfo {
                slot: 1u32,
                case: 14u16,
            },
            field: _p::Descriptor::<bool> {
                slot: 129u32,
                default: false,
            },
        };
        const U1F2S8: _p::VariantDescriptor<i8> = _p::VariantDescriptor::<i8> {
            variant: _p::VariantInfo {
                slot: 1u32,
                case: 15u16,
            },
            field: _p::Descriptor::<i8> {
                slot: 17u32,
                default: 0i8,
            },
        };
        const U1F2S16: _p::VariantDescriptor<i16> = _p::VariantDescriptor::<i16> {
            variant: _p::VariantInfo {
                slot: 1u32,
                case: 16u16,
            },
            field: _p::Descriptor::<i16> {
                slot: 9u32,
                default: 0i16,
            },
        };
        const U1F2S32: _p::VariantDescriptor<i32> = _p::VariantDescriptor::<i32> {
            variant: _p::VariantInfo {
                slot: 1u32,
                case: 17u16,
            },
            field: _p::Descriptor::<i32> {
                slot: 5u32,
                default: 0i32,
            },
        };
        const U1F2S64: _p::VariantDescriptor<i64> = _p::VariantDescriptor::<i64> {
            variant: _p::VariantInfo {
                slot: 1u32,
                case: 18u16,
            },
            field: _p::Descriptor::<i64> {
                slot: 3u32,
                default: 0i64,
            },
        };
        const U1F2SP: _p::VariantDescriptor<_p::Text> = _p::VariantDescriptor::<
            _p::Text,
        > {
            variant: _p::VariantInfo {
                slot: 1u32,
                case: 19u16,
            },
            field: _p::Descriptor::<_p::Text> {
                slot: 1u32,
                default: ::core::option::Option::None,
            },
        };
    }
    impl<'p, T: _p::rpc::Table + 'p> union1::Reader<'p, T> {
        #[inline]
        pub fn u1f0s0(&self) -> _p::Variant<'_, 'p, T, ()> {
            unsafe { <() as _p::field::FieldType>::variant(&self.0, &Union1::U1F0S0) }
        }
        #[inline]
        pub fn u1f0s1(&self) -> _p::Variant<'_, 'p, T, bool> {
            unsafe { <bool as _p::field::FieldType>::variant(&self.0, &Union1::U1F0S1) }
        }
        #[inline]
        pub fn u1f1s1(&self) -> _p::Variant<'_, 'p, T, bool> {
            unsafe { <bool as _p::field::FieldType>::variant(&self.0, &Union1::U1F1S1) }
        }
        #[inline]
        pub fn u1f0s8(&self) -> _p::Variant<'_, 'p, T, i8> {
            unsafe { <i8 as _p::field::FieldType>::variant(&self.0, &Union1::U1F0S8) }
        }
        #[inline]
        pub fn u1f1s8(&self) -> _p::Variant<'_, 'p, T, i8> {
            unsafe { <i8 as _p::field::FieldType>::variant(&self.0, &Union1::U1F1S8) }
        }
        #[inline]
        pub fn u1f0s16(&self) -> _p::Variant<'_, 'p, T, i16> {
            unsafe { <i16 as _p::field::FieldType>::variant(&self.0, &Union1::U1F0S16) }
        }
        #[inline]
        pub fn u1f1s16(&self) -> _p::Variant<'_, 'p, T, i16> {
            unsafe { <i16 as _p::field::FieldType>::variant(&self.0, &Union1::U1F1S16) }
        }
        #[inline]
        pub fn u1f0s32(&self) -> _p::Variant<'_, 'p, T, i32> {
            unsafe { <i32 as _p::field::FieldType>::variant(&self.0, &Union1::U1F0S32) }
        }
        #[inline]
        pub fn u1f1s32(&self) -> _p::Variant<'_, 'p, T, i32> {
            unsafe { <i32 as _p::field::FieldType>::variant(&self.0, &Union1::U1F1S32) }
        }
        #[inline]
        pub fn u1f0s64(&self) -> _p::Variant<'_, 'p, T, i64> {
            unsafe { <i64 as _p::field::FieldType>::variant(&self.0, &Union1::U1F0S64) }
        }
        #[inline]
        pub fn u1f1s64(&self) -> _p::Variant<'_, 'p, T, i64> {
            unsafe { <i64 as _p::field::FieldType>::variant(&self.0, &Union1::U1F1S64) }
        }
        #[inline]
        pub fn u1f0sp(&self) -> _p::Variant<'_, 'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::variant(&self.0, &Union1::U1F0SP)
            }
        }
        #[inline]
        pub fn u1f1sp(&self) -> _p::Variant<'_, 'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::variant(&self.0, &Union1::U1F1SP)
            }
        }
        #[inline]
        pub fn u1f2s0(&self) -> _p::Variant<'_, 'p, T, ()> {
            unsafe { <() as _p::field::FieldType>::variant(&self.0, &Union1::U1F2S0) }
        }
        #[inline]
        pub fn u1f2s1(&self) -> _p::Variant<'_, 'p, T, bool> {
            unsafe { <bool as _p::field::FieldType>::variant(&self.0, &Union1::U1F2S1) }
        }
        #[inline]
        pub fn u1f2s8(&self) -> _p::Variant<'_, 'p, T, i8> {
            unsafe { <i8 as _p::field::FieldType>::variant(&self.0, &Union1::U1F2S8) }
        }
        #[inline]
        pub fn u1f2s16(&self) -> _p::Variant<'_, 'p, T, i16> {
            unsafe { <i16 as _p::field::FieldType>::variant(&self.0, &Union1::U1F2S16) }
        }
        #[inline]
        pub fn u1f2s32(&self) -> _p::Variant<'_, 'p, T, i32> {
            unsafe { <i32 as _p::field::FieldType>::variant(&self.0, &Union1::U1F2S32) }
        }
        #[inline]
        pub fn u1f2s64(&self) -> _p::Variant<'_, 'p, T, i64> {
            unsafe { <i64 as _p::field::FieldType>::variant(&self.0, &Union1::U1F2S64) }
        }
        #[inline]
        pub fn u1f2sp(&self) -> _p::Variant<'_, 'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::variant(&self.0, &Union1::U1F2SP)
            }
        }
        #[inline]
        pub fn which(&self) -> Result<union1::Which<&Self>, _p::NotInSchema> {
            unsafe { <union1::Which<_> as _p::UnionViewer<_>>::get(self) }
        }
    }
    impl<'p, T: _p::rpc::Table + 'p> union1::Builder<'p, T> {
        #[inline]
        pub fn u1f0s0(&mut self) -> _p::VariantMut<'_, 'p, T, ()> {
            unsafe {
                <() as _p::field::FieldType>::variant(&mut self.0, &Union1::U1F0S0)
            }
        }
        #[inline]
        pub fn u1f0s1(&mut self) -> _p::VariantMut<'_, 'p, T, bool> {
            unsafe {
                <bool as _p::field::FieldType>::variant(&mut self.0, &Union1::U1F0S1)
            }
        }
        #[inline]
        pub fn u1f1s1(&mut self) -> _p::VariantMut<'_, 'p, T, bool> {
            unsafe {
                <bool as _p::field::FieldType>::variant(&mut self.0, &Union1::U1F1S1)
            }
        }
        #[inline]
        pub fn u1f0s8(&mut self) -> _p::VariantMut<'_, 'p, T, i8> {
            unsafe {
                <i8 as _p::field::FieldType>::variant(&mut self.0, &Union1::U1F0S8)
            }
        }
        #[inline]
        pub fn u1f1s8(&mut self) -> _p::VariantMut<'_, 'p, T, i8> {
            unsafe {
                <i8 as _p::field::FieldType>::variant(&mut self.0, &Union1::U1F1S8)
            }
        }
        #[inline]
        pub fn u1f0s16(&mut self) -> _p::VariantMut<'_, 'p, T, i16> {
            unsafe {
                <i16 as _p::field::FieldType>::variant(&mut self.0, &Union1::U1F0S16)
            }
        }
        #[inline]
        pub fn u1f1s16(&mut self) -> _p::VariantMut<'_, 'p, T, i16> {
            unsafe {
                <i16 as _p::field::FieldType>::variant(&mut self.0, &Union1::U1F1S16)
            }
        }
        #[inline]
        pub fn u1f0s32(&mut self) -> _p::VariantMut<'_, 'p, T, i32> {
            unsafe {
                <i32 as _p::field::FieldType>::variant(&mut self.0, &Union1::U1F0S32)
            }
        }
        #[inline]
        pub fn u1f1s32(&mut self) -> _p::VariantMut<'_, 'p, T, i32> {
            unsafe {
                <i32 as _p::field::FieldType>::variant(&mut self.0, &Union1::U1F1S32)
            }
        }
        #[inline]
        pub fn u1f0s64(&mut self) -> _p::VariantMut<'_, 'p, T, i64> {
            unsafe {
                <i64 as _p::field::FieldType>::variant(&mut self.0, &Union1::U1F0S64)
            }
        }
        #[inline]
        pub fn u1f1s64(&mut self) -> _p::VariantMut<'_, 'p, T, i64> {
            unsafe {
                <i64 as _p::field::FieldType>::variant(&mut self.0, &Union1::U1F1S64)
            }
        }
        #[inline]
        pub fn u1f0sp(&mut self) -> _p::VariantMut<'_, 'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::variant(&mut self.0, &Union1::U1F0SP)
            }
        }
        #[inline]
        pub fn u1f1sp(&mut self) -> _p::VariantMut<'_, 'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::variant(&mut self.0, &Union1::U1F1SP)
            }
        }
        #[inline]
        pub fn u1f2s0(&mut self) -> _p::VariantMut<'_, 'p, T, ()> {
            unsafe {
                <() as _p::field::FieldType>::variant(&mut self.0, &Union1::U1F2S0)
            }
        }
        #[inline]
        pub fn u1f2s1(&mut self) -> _p::VariantMut<'_, 'p, T, bool> {
            unsafe {
                <bool as _p::field::FieldType>::variant(&mut self.0, &Union1::U1F2S1)
            }
        }
        #[inline]
        pub fn u1f2s8(&mut self) -> _p::VariantMut<'_, 'p, T, i8> {
            unsafe {
                <i8 as _p::field::FieldType>::variant(&mut self.0, &Union1::U1F2S8)
            }
        }
        #[inline]
        pub fn u1f2s16(&mut self) -> _p::VariantMut<'_, 'p, T, i16> {
            unsafe {
                <i16 as _p::field::FieldType>::variant(&mut self.0, &Union1::U1F2S16)
            }
        }
        #[inline]
        pub fn u1f2s32(&mut self) -> _p::VariantMut<'_, 'p, T, i32> {
            unsafe {
                <i32 as _p::field::FieldType>::variant(&mut self.0, &Union1::U1F2S32)
            }
        }
        #[inline]
        pub fn u1f2s64(&mut self) -> _p::VariantMut<'_, 'p, T, i64> {
            unsafe {
                <i64 as _p::field::FieldType>::variant(&mut self.0, &Union1::U1F2S64)
            }
        }
        #[inline]
        pub fn u1f2sp(&mut self) -> _p::VariantMut<'_, 'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::variant(&mut self.0, &Union1::U1F2SP)
            }
        }
        #[inline]
        pub fn into_u1f0sp(self) -> _p::VariantOwned<'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::variant(self.0, &Union1::U1F0SP)
            }
        }
        #[inline]
        pub fn into_u1f1sp(self) -> _p::VariantOwned<'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::variant(self.0, &Union1::U1F1SP)
            }
        }
        #[inline]
        pub fn into_u1f2sp(self) -> _p::VariantOwned<'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::variant(self.0, &Union1::U1F2SP)
            }
        }
        #[inline]
        pub fn which(&mut self) -> Result<union1::Which<&mut Self>, _p::NotInSchema> {
            unsafe { <union1::Which<_> as _p::UnionViewer<_>>::get(self) }
        }
    }
    pub mod union1 {
        use super::{__file, __imports, _p};
        pub type Reader<'a, T = _p::rpc::Empty> = super::Union1<_p::StructReader<'a, T>>;
        pub type Builder<'a, T = _p::rpc::Empty> = super::Union1<
            _p::StructBuilder<'a, T>,
        >;
        pub enum Which<T: _p::Viewable = _p::Family> {
            U1f0s0(_p::ViewOf<T, ()>),
            U1f0s1(_p::ViewOf<T, bool>),
            U1f1s1(_p::ViewOf<T, bool>),
            U1f0s8(_p::ViewOf<T, i8>),
            U1f1s8(_p::ViewOf<T, i8>),
            U1f0s16(_p::ViewOf<T, i16>),
            U1f1s16(_p::ViewOf<T, i16>),
            U1f0s32(_p::ViewOf<T, i32>),
            U1f1s32(_p::ViewOf<T, i32>),
            U1f0s64(_p::ViewOf<T, i64>),
            U1f1s64(_p::ViewOf<T, i64>),
            U1f0sp(_p::ViewOf<T, _p::Text>),
            U1f1sp(_p::ViewOf<T, _p::Text>),
            U1f2s0(_p::ViewOf<T, ()>),
            U1f2s1(_p::ViewOf<T, bool>),
            U1f2s8(_p::ViewOf<T, i8>),
            U1f2s16(_p::ViewOf<T, i16>),
            U1f2s32(_p::ViewOf<T, i32>),
            U1f2s64(_p::ViewOf<T, i64>),
            U1f2sp(_p::ViewOf<T, _p::Text>),
        }
        impl<'b, 'p: 'b, T: _p::Table + 'p> _p::UnionViewer<&'b Reader<'p, T>>
        for Which {
            type View = Which<&'b Reader<'p, T>>;
            unsafe fn get(
                repr: &'b Reader<'p, T>,
            ) -> Result<Self::View, _p::NotInSchema> {
                let tag = repr.0.data_field::<u16>(1usize);
                match tag {
                    0u16 => {
                        Ok(
                            Which::U1f0s0(
                                <() as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Union1::U1F0S0.field,
                                ),
                            ),
                        )
                    }
                    1u16 => {
                        Ok(
                            Which::U1f0s1(
                                <bool as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Union1::U1F0S1.field,
                                ),
                            ),
                        )
                    }
                    2u16 => {
                        Ok(
                            Which::U1f1s1(
                                <bool as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Union1::U1F1S1.field,
                                ),
                            ),
                        )
                    }
                    3u16 => {
                        Ok(
                            Which::U1f0s8(
                                <i8 as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Union1::U1F0S8.field,
                                ),
                            ),
                        )
                    }
                    4u16 => {
                        Ok(
                            Which::U1f1s8(
                                <i8 as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Union1::U1F1S8.field,
                                ),
                            ),
                        )
                    }
                    5u16 => {
                        Ok(
                            Which::U1f0s16(
                                <i16 as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Union1::U1F0S16.field,
                                ),
                            ),
                        )
                    }
                    6u16 => {
                        Ok(
                            Which::U1f1s16(
                                <i16 as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Union1::U1F1S16.field,
                                ),
                            ),
                        )
                    }
                    7u16 => {
                        Ok(
                            Which::U1f0s32(
                                <i32 as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Union1::U1F0S32.field,
                                ),
                            ),
                        )
                    }
                    8u16 => {
                        Ok(
                            Which::U1f1s32(
                                <i32 as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Union1::U1F1S32.field,
                                ),
                            ),
                        )
                    }
                    9u16 => {
                        Ok(
                            Which::U1f0s64(
                                <i64 as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Union1::U1F0S64.field,
                                ),
                            ),
                        )
                    }
                    10u16 => {
                        Ok(
                            Which::U1f1s64(
                                <i64 as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Union1::U1F1S64.field,
                                ),
                            ),
                        )
                    }
                    11u16 => {
                        Ok(
                            Which::U1f0sp(
                                <_p::Text as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Union1::U1F0SP.field,
                                ),
                            ),
                        )
                    }
                    12u16 => {
                        Ok(
                            Which::U1f1sp(
                                <_p::Text as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Union1::U1F1SP.field,
                                ),
                            ),
                        )
                    }
                    13u16 => {
                        Ok(
                            Which::U1f2s0(
                                <() as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Union1::U1F2S0.field,
                                ),
                            ),
                        )
                    }
                    14u16 => {
                        Ok(
                            Which::U1f2s1(
                                <bool as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Union1::U1F2S1.field,
                                ),
                            ),
                        )
                    }
                    15u16 => {
                        Ok(
                            Which::U1f2s8(
                                <i8 as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Union1::U1F2S8.field,
                                ),
                            ),
                        )
                    }
                    16u16 => {
                        Ok(
                            Which::U1f2s16(
                                <i16 as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Union1::U1F2S16.field,
                                ),
                            ),
                        )
                    }
                    17u16 => {
                        Ok(
                            Which::U1f2s32(
                                <i32 as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Union1::U1F2S32.field,
                                ),
                            ),
                        )
                    }
                    18u16 => {
                        Ok(
                            Which::U1f2s64(
                                <i64 as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Union1::U1F2S64.field,
                                ),
                            ),
                        )
                    }
                    19u16 => {
                        Ok(
                            Which::U1f2sp(
                                <_p::Text as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Union1::U1F2SP.field,
                                ),
                            ),
                        )
                    }
                    unknown => Err(_p::NotInSchema(unknown)),
                }
            }
        }
        impl<'b, 'p: 'b, T: _p::Table + 'p> _p::UnionViewer<&'b mut Builder<'p, T>>
        for Which {
            type View = Which<&'b mut Builder<'p, T>>;
            unsafe fn get(
                repr: &'b mut Builder<'p, T>,
            ) -> Result<Self::View, _p::NotInSchema> {
                let tag = repr.0.data_field::<u16>(1usize);
                match tag {
                    0u16 => {
                        Ok(
                            Which::U1f0s0(
                                <() as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Union1::U1F0S0.field,
                                ),
                            ),
                        )
                    }
                    1u16 => {
                        Ok(
                            Which::U1f0s1(
                                <bool as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Union1::U1F0S1.field,
                                ),
                            ),
                        )
                    }
                    2u16 => {
                        Ok(
                            Which::U1f1s1(
                                <bool as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Union1::U1F1S1.field,
                                ),
                            ),
                        )
                    }
                    3u16 => {
                        Ok(
                            Which::U1f0s8(
                                <i8 as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Union1::U1F0S8.field,
                                ),
                            ),
                        )
                    }
                    4u16 => {
                        Ok(
                            Which::U1f1s8(
                                <i8 as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Union1::U1F1S8.field,
                                ),
                            ),
                        )
                    }
                    5u16 => {
                        Ok(
                            Which::U1f0s16(
                                <i16 as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Union1::U1F0S16.field,
                                ),
                            ),
                        )
                    }
                    6u16 => {
                        Ok(
                            Which::U1f1s16(
                                <i16 as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Union1::U1F1S16.field,
                                ),
                            ),
                        )
                    }
                    7u16 => {
                        Ok(
                            Which::U1f0s32(
                                <i32 as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Union1::U1F0S32.field,
                                ),
                            ),
                        )
                    }
                    8u16 => {
                        Ok(
                            Which::U1f1s32(
                                <i32 as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Union1::U1F1S32.field,
                                ),
                            ),
                        )
                    }
                    9u16 => {
                        Ok(
                            Which::U1f0s64(
                                <i64 as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Union1::U1F0S64.field,
                                ),
                            ),
                        )
                    }
                    10u16 => {
                        Ok(
                            Which::U1f1s64(
                                <i64 as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Union1::U1F1S64.field,
                                ),
                            ),
                        )
                    }
                    11u16 => {
                        Ok(
                            Which::U1f0sp(
                                <_p::Text as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Union1::U1F0SP.field,
                                ),
                            ),
                        )
                    }
                    12u16 => {
                        Ok(
                            Which::U1f1sp(
                                <_p::Text as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Union1::U1F1SP.field,
                                ),
                            ),
                        )
                    }
                    13u16 => {
                        Ok(
                            Which::U1f2s0(
                                <() as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Union1::U1F2S0.field,
                                ),
                            ),
                        )
                    }
                    14u16 => {
                        Ok(
                            Which::U1f2s1(
                                <bool as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Union1::U1F2S1.field,
                                ),
                            ),
                        )
                    }
                    15u16 => {
                        Ok(
                            Which::U1f2s8(
                                <i8 as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Union1::U1F2S8.field,
                                ),
                            ),
                        )
                    }
                    16u16 => {
                        Ok(
                            Which::U1f2s16(
                                <i16 as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Union1::U1F2S16.field,
                                ),
                            ),
                        )
                    }
                    17u16 => {
                        Ok(
                            Which::U1f2s32(
                                <i32 as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Union1::U1F2S32.field,
                                ),
                            ),
                        )
                    }
                    18u16 => {
                        Ok(
                            Which::U1f2s64(
                                <i64 as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Union1::U1F2S64.field,
                                ),
                            ),
                        )
                    }
                    19u16 => {
                        Ok(
                            Which::U1f2sp(
                                <_p::Text as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Union1::U1F2SP.field,
                                ),
                            ),
                        )
                    }
                    unknown => Err(_p::NotInSchema(unknown)),
                }
            }
        }
    }
    #[derive(Clone)]
    pub struct Union2<T = _p::Family>(T);
    impl _p::ty::SchemaType for Union2 {
        const ID: u64 = 12665807985332545236u64;
    }
    impl<T> _p::IntoFamily for Union2<T> {
        type Family = Union2;
    }
    impl<T: _p::Capable> _p::Capable for Union2<T> {
        type Table = T::Table;
        type Imbued = T::Imbued;
        type ImbuedWith<T2: _p::rpc::Table> = Union2<T::ImbuedWith<T2>>;
        #[inline]
        fn imbued(&self) -> &Self::Imbued {
            self.0.imbued()
        }
        #[inline]
        fn imbue_release<T2: _p::rpc::Table>(
            self,
            new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
        ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
            let (imbued, old) = self.0.imbue_release(new_table);
            (Union2(imbued), old)
        }
        #[inline]
        fn imbue_release_into<U>(
            &self,
            other: U,
        ) -> (U::ImbuedWith<Self::Table>, U::Imbued)
        where
            U: _p::Capable,
            U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
        {
            self.0.imbue_release_into(other)
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for union2::Reader<'a, T> {
        type Ptr = _p::StructReader<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
    for union2::Reader<'a, T> {
        #[inline]
        fn from(ptr: _p::StructReader<'a, T>) -> Self {
            Union2(ptr)
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<union2::Reader<'a, T>>
    for _p::StructReader<'a, T> {
        #[inline]
        fn from(reader: union2::Reader<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
    for union2::Reader<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructReader<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructReader for union2::Reader<'a, T> {}
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for union2::Builder<'a, T> {
        type Ptr = _p::StructBuilder<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<union2::Builder<'a, T>>
    for _p::StructBuilder<'a, T> {
        #[inline]
        fn from(reader: union2::Builder<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
    for union2::Builder<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
    for union2::Builder<'a, T> {
        #[inline]
        fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
            &mut self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for union2::Builder<'a, T> {
        unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
            Self(ptr)
        }
    }
    impl _p::StructView for Union2 {
        type Reader<'a, T: _p::rpc::Table> = union2::Reader<'a, T>;
        type Builder<'a, T: _p::rpc::Table> = union2::Builder<'a, T>;
    }
    impl _p::FieldGroup for Union2 {
        unsafe fn clear<'a, 'b, T: _p::rpc::Table>(s: &'a mut _p::StructBuilder<'b, T>) {
            s.set_field_unchecked(2usize, 0);
            <bool as _p::field::FieldType>::clear(s, &Union2::U2F0S1.field);
        }
    }
    impl Union2 {
        const U2F0S1: _p::VariantDescriptor<bool> = _p::VariantDescriptor::<bool> {
            variant: _p::VariantInfo {
                slot: 2u32,
                case: 0u16,
            },
            field: _p::Descriptor::<bool> {
                slot: 256u32,
                default: false,
            },
        };
        const U2F0S8: _p::VariantDescriptor<i8> = _p::VariantDescriptor::<i8> {
            variant: _p::VariantInfo {
                slot: 2u32,
                case: 1u16,
            },
            field: _p::Descriptor::<i8> {
                slot: 33u32,
                default: 0i8,
            },
        };
        const U2F0S16: _p::VariantDescriptor<i16> = _p::VariantDescriptor::<i16> {
            variant: _p::VariantInfo {
                slot: 2u32,
                case: 2u16,
            },
            field: _p::Descriptor::<i16> {
                slot: 18u32,
                default: 0i16,
            },
        };
        const U2F0S32: _p::VariantDescriptor<i32> = _p::VariantDescriptor::<i32> {
            variant: _p::VariantInfo {
                slot: 2u32,
                case: 3u16,
            },
            field: _p::Descriptor::<i32> {
                slot: 10u32,
                default: 0i32,
            },
        };
        const U2F0S64: _p::VariantDescriptor<i64> = _p::VariantDescriptor::<i64> {
            variant: _p::VariantInfo {
                slot: 2u32,
                case: 4u16,
            },
            field: _p::Descriptor::<i64> {
                slot: 6u32,
                default: 0i64,
            },
        };
    }
    impl<'p, T: _p::rpc::Table + 'p> union2::Reader<'p, T> {
        #[inline]
        pub fn u2f0s1(&self) -> _p::Variant<'_, 'p, T, bool> {
            unsafe { <bool as _p::field::FieldType>::variant(&self.0, &Union2::U2F0S1) }
        }
        #[inline]
        pub fn u2f0s8(&self) -> _p::Variant<'_, 'p, T, i8> {
            unsafe { <i8 as _p::field::FieldType>::variant(&self.0, &Union2::U2F0S8) }
        }
        #[inline]
        pub fn u2f0s16(&self) -> _p::Variant<'_, 'p, T, i16> {
            unsafe { <i16 as _p::field::FieldType>::variant(&self.0, &Union2::U2F0S16) }
        }
        #[inline]
        pub fn u2f0s32(&self) -> _p::Variant<'_, 'p, T, i32> {
            unsafe { <i32 as _p::field::FieldType>::variant(&self.0, &Union2::U2F0S32) }
        }
        #[inline]
        pub fn u2f0s64(&self) -> _p::Variant<'_, 'p, T, i64> {
            unsafe { <i64 as _p::field::FieldType>::variant(&self.0, &Union2::U2F0S64) }
        }
        #[inline]
        pub fn which(&self) -> Result<union2::Which<&Self>, _p::NotInSchema> {
            unsafe { <union2::Which<_> as _p::UnionViewer<_>>::get(self) }
        }
    }
    impl<'p, T: _p::rpc::Table + 'p> union2::Builder<'p, T> {
        #[inline]
        pub fn u2f0s1(&mut self) -> _p::VariantMut<'_, 'p, T, bool> {
            unsafe {
                <bool as _p::field::FieldType>::variant(&mut self.0, &Union2::U2F0S1)
            }
        }
        #[inline]
        pub fn u2f0s8(&mut self) -> _p::VariantMut<'_, 'p, T, i8> {
            unsafe {
                <i8 as _p::field::FieldType>::variant(&mut self.0, &Union2::U2F0S8)
            }
        }
        #[inline]
        pub fn u2f0s16(&mut self) -> _p::VariantMut<'_, 'p, T, i16> {
            unsafe {
                <i16 as _p::field::FieldType>::variant(&mut self.0, &Union2::U2F0S16)
            }
        }
        #[inline]
        pub fn u2f0s32(&mut self) -> _p::VariantMut<'_, 'p, T, i32> {
            unsafe {
                <i32 as _p::field::FieldType>::variant(&mut self.0, &Union2::U2F0S32)
            }
        }
        #[inline]
        pub fn u2f0s64(&mut self) -> _p::VariantMut<'_, 'p, T, i64> {
            unsafe {
                <i64 as _p::field::FieldType>::variant(&mut self.0, &Union2::U2F0S64)
            }
        }
        #[inline]
        pub fn which(&mut self) -> Result<union2::Which<&mut Self>, _p::NotInSchema> {
            unsafe { <union2::Which<_> as _p::UnionViewer<_>>::get(self) }
        }
    }
    pub mod union2 {
        use super::{__file, __imports, _p};
        pub type Reader<'a, T = _p::rpc::Empty> = super::Union2<_p::StructReader<'a, T>>;
        pub type Builder<'a, T = _p::rpc::Empty> = super::Union2<
            _p::StructBuilder<'a, T>,
        >;
        pub enum Which<T: _p::Viewable = _p::Family> {
            U2f0s1(_p::ViewOf<T, bool>),
            U2f0s8(_p::ViewOf<T, i8>),
            U2f0s16(_p::ViewOf<T, i16>),
            U2f0s32(_p::ViewOf<T, i32>),
            U2f0s64(_p::ViewOf<T, i64>),
        }
        impl<'b, 'p: 'b, T: _p::Table + 'p> _p::UnionViewer<&'b Reader<'p, T>>
        for Which {
            type View = Which<&'b Reader<'p, T>>;
            unsafe fn get(
                repr: &'b Reader<'p, T>,
            ) -> Result<Self::View, _p::NotInSchema> {
                let tag = repr.0.data_field::<u16>(2usize);
                match tag {
                    0u16 => {
                        Ok(
                            Which::U2f0s1(
                                <bool as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Union2::U2F0S1.field,
                                ),
                            ),
                        )
                    }
                    1u16 => {
                        Ok(
                            Which::U2f0s8(
                                <i8 as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Union2::U2F0S8.field,
                                ),
                            ),
                        )
                    }
                    2u16 => {
                        Ok(
                            Which::U2f0s16(
                                <i16 as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Union2::U2F0S16.field,
                                ),
                            ),
                        )
                    }
                    3u16 => {
                        Ok(
                            Which::U2f0s32(
                                <i32 as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Union2::U2F0S32.field,
                                ),
                            ),
                        )
                    }
                    4u16 => {
                        Ok(
                            Which::U2f0s64(
                                <i64 as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Union2::U2F0S64.field,
                                ),
                            ),
                        )
                    }
                    unknown => Err(_p::NotInSchema(unknown)),
                }
            }
        }
        impl<'b, 'p: 'b, T: _p::Table + 'p> _p::UnionViewer<&'b mut Builder<'p, T>>
        for Which {
            type View = Which<&'b mut Builder<'p, T>>;
            unsafe fn get(
                repr: &'b mut Builder<'p, T>,
            ) -> Result<Self::View, _p::NotInSchema> {
                let tag = repr.0.data_field::<u16>(2usize);
                match tag {
                    0u16 => {
                        Ok(
                            Which::U2f0s1(
                                <bool as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Union2::U2F0S1.field,
                                ),
                            ),
                        )
                    }
                    1u16 => {
                        Ok(
                            Which::U2f0s8(
                                <i8 as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Union2::U2F0S8.field,
                                ),
                            ),
                        )
                    }
                    2u16 => {
                        Ok(
                            Which::U2f0s16(
                                <i16 as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Union2::U2F0S16.field,
                                ),
                            ),
                        )
                    }
                    3u16 => {
                        Ok(
                            Which::U2f0s32(
                                <i32 as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Union2::U2F0S32.field,
                                ),
                            ),
                        )
                    }
                    4u16 => {
                        Ok(
                            Which::U2f0s64(
                                <i64 as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Union2::U2F0S64.field,
                                ),
                            ),
                        )
                    }
                    unknown => Err(_p::NotInSchema(unknown)),
                }
            }
        }
    }
    #[derive(Clone)]
    pub struct Union3<T = _p::Family>(T);
    impl _p::ty::SchemaType for Union3 {
        const ID: u64 = 11743982853245042771u64;
    }
    impl<T> _p::IntoFamily for Union3<T> {
        type Family = Union3;
    }
    impl<T: _p::Capable> _p::Capable for Union3<T> {
        type Table = T::Table;
        type Imbued = T::Imbued;
        type ImbuedWith<T2: _p::rpc::Table> = Union3<T::ImbuedWith<T2>>;
        #[inline]
        fn imbued(&self) -> &Self::Imbued {
            self.0.imbued()
        }
        #[inline]
        fn imbue_release<T2: _p::rpc::Table>(
            self,
            new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
        ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
            let (imbued, old) = self.0.imbue_release(new_table);
            (Union3(imbued), old)
        }
        #[inline]
        fn imbue_release_into<U>(
            &self,
            other: U,
        ) -> (U::ImbuedWith<Self::Table>, U::Imbued)
        where
            U: _p::Capable,
            U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
        {
            self.0.imbue_release_into(other)
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for union3::Reader<'a, T> {
        type Ptr = _p::StructReader<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
    for union3::Reader<'a, T> {
        #[inline]
        fn from(ptr: _p::StructReader<'a, T>) -> Self {
            Union3(ptr)
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<union3::Reader<'a, T>>
    for _p::StructReader<'a, T> {
        #[inline]
        fn from(reader: union3::Reader<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
    for union3::Reader<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructReader<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructReader for union3::Reader<'a, T> {}
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for union3::Builder<'a, T> {
        type Ptr = _p::StructBuilder<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<union3::Builder<'a, T>>
    for _p::StructBuilder<'a, T> {
        #[inline]
        fn from(reader: union3::Builder<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
    for union3::Builder<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
    for union3::Builder<'a, T> {
        #[inline]
        fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
            &mut self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for union3::Builder<'a, T> {
        unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
            Self(ptr)
        }
    }
    impl _p::StructView for Union3 {
        type Reader<'a, T: _p::rpc::Table> = union3::Reader<'a, T>;
        type Builder<'a, T: _p::rpc::Table> = union3::Builder<'a, T>;
    }
    impl _p::FieldGroup for Union3 {
        unsafe fn clear<'a, 'b, T: _p::rpc::Table>(s: &'a mut _p::StructBuilder<'b, T>) {
            s.set_field_unchecked(3usize, 0);
            <bool as _p::field::FieldType>::clear(s, &Union3::U3F0S1.field);
        }
    }
    impl Union3 {
        const U3F0S1: _p::VariantDescriptor<bool> = _p::VariantDescriptor::<bool> {
            variant: _p::VariantInfo {
                slot: 3u32,
                case: 0u16,
            },
            field: _p::Descriptor::<bool> {
                slot: 257u32,
                default: false,
            },
        };
        const U3F0S8: _p::VariantDescriptor<i8> = _p::VariantDescriptor::<i8> {
            variant: _p::VariantInfo {
                slot: 3u32,
                case: 1u16,
            },
            field: _p::Descriptor::<i8> {
                slot: 34u32,
                default: 0i8,
            },
        };
        const U3F0S16: _p::VariantDescriptor<i16> = _p::VariantDescriptor::<i16> {
            variant: _p::VariantInfo {
                slot: 3u32,
                case: 2u16,
            },
            field: _p::Descriptor::<i16> {
                slot: 19u32,
                default: 0i16,
            },
        };
        const U3F0S32: _p::VariantDescriptor<i32> = _p::VariantDescriptor::<i32> {
            variant: _p::VariantInfo {
                slot: 3u32,
                case: 3u16,
            },
            field: _p::Descriptor::<i32> {
                slot: 11u32,
                default: 0i32,
            },
        };
        const U3F0S64: _p::VariantDescriptor<i64> = _p::VariantDescriptor::<i64> {
            variant: _p::VariantInfo {
                slot: 3u32,
                case: 4u16,
            },
            field: _p::Descriptor::<i64> {
                slot: 7u32,
                default: 0i64,
            },
        };
    }
    impl<'p, T: _p::rpc::Table + 'p> union3::Reader<'p, T> {
        #[inline]
        pub fn u3f0s1(&self) -> _p::Variant<'_, 'p, T, bool> {
            unsafe { <bool as _p::field::FieldType>::variant(&self.0, &Union3::U3F0S1) }
        }
        #[inline]
        pub fn u3f0s8(&self) -> _p::Variant<'_, 'p, T, i8> {
            unsafe { <i8 as _p::field::FieldType>::variant(&self.0, &Union3::U3F0S8) }
        }
        #[inline]
        pub fn u3f0s16(&self) -> _p::Variant<'_, 'p, T, i16> {
            unsafe { <i16 as _p::field::FieldType>::variant(&self.0, &Union3::U3F0S16) }
        }
        #[inline]
        pub fn u3f0s32(&self) -> _p::Variant<'_, 'p, T, i32> {
            unsafe { <i32 as _p::field::FieldType>::variant(&self.0, &Union3::U3F0S32) }
        }
        #[inline]
        pub fn u3f0s64(&self) -> _p::Variant<'_, 'p, T, i64> {
            unsafe { <i64 as _p::field::FieldType>::variant(&self.0, &Union3::U3F0S64) }
        }
        #[inline]
        pub fn which(&self) -> Result<union3::Which<&Self>, _p::NotInSchema> {
            unsafe { <union3::Which<_> as _p::UnionViewer<_>>::get(self) }
        }
    }
    impl<'p, T: _p::rpc::Table + 'p> union3::Builder<'p, T> {
        #[inline]
        pub fn u3f0s1(&mut self) -> _p::VariantMut<'_, 'p, T, bool> {
            unsafe {
                <bool as _p::field::FieldType>::variant(&mut self.0, &Union3::U3F0S1)
            }
        }
        #[inline]
        pub fn u3f0s8(&mut self) -> _p::VariantMut<'_, 'p, T, i8> {
            unsafe {
                <i8 as _p::field::FieldType>::variant(&mut self.0, &Union3::U3F0S8)
            }
        }
        #[inline]
        pub fn u3f0s16(&mut self) -> _p::VariantMut<'_, 'p, T, i16> {
            unsafe {
                <i16 as _p::field::FieldType>::variant(&mut self.0, &Union3::U3F0S16)
            }
        }
        #[inline]
        pub fn u3f0s32(&mut self) -> _p::VariantMut<'_, 'p, T, i32> {
            unsafe {
                <i32 as _p::field::FieldType>::variant(&mut self.0, &Union3::U3F0S32)
            }
        }
        #[inline]
        pub fn u3f0s64(&mut self) -> _p::VariantMut<'_, 'p, T, i64> {
            unsafe {
                <i64 as _p::field::FieldType>::variant(&mut self.0, &Union3::U3F0S64)
            }
        }
        #[inline]
        pub fn which(&mut self) -> Result<union3::Which<&mut Self>, _p::NotInSchema> {
            unsafe { <union3::Which<_> as _p::UnionViewer<_>>::get(self) }
        }
    }
    pub mod union3 {
        use super::{__file, __imports, _p};
        pub type Reader<'a, T = _p::rpc::Empty> = super::Union3<_p::StructReader<'a, T>>;
        pub type Builder<'a, T = _p::rpc::Empty> = super::Union3<
            _p::StructBuilder<'a, T>,
        >;
        pub enum Which<T: _p::Viewable = _p::Family> {
            U3f0s1(_p::ViewOf<T, bool>),
            U3f0s8(_p::ViewOf<T, i8>),
            U3f0s16(_p::ViewOf<T, i16>),
            U3f0s32(_p::ViewOf<T, i32>),
            U3f0s64(_p::ViewOf<T, i64>),
        }
        impl<'b, 'p: 'b, T: _p::Table + 'p> _p::UnionViewer<&'b Reader<'p, T>>
        for Which {
            type View = Which<&'b Reader<'p, T>>;
            unsafe fn get(
                repr: &'b Reader<'p, T>,
            ) -> Result<Self::View, _p::NotInSchema> {
                let tag = repr.0.data_field::<u16>(3usize);
                match tag {
                    0u16 => {
                        Ok(
                            Which::U3f0s1(
                                <bool as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Union3::U3F0S1.field,
                                ),
                            ),
                        )
                    }
                    1u16 => {
                        Ok(
                            Which::U3f0s8(
                                <i8 as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Union3::U3F0S8.field,
                                ),
                            ),
                        )
                    }
                    2u16 => {
                        Ok(
                            Which::U3f0s16(
                                <i16 as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Union3::U3F0S16.field,
                                ),
                            ),
                        )
                    }
                    3u16 => {
                        Ok(
                            Which::U3f0s32(
                                <i32 as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Union3::U3F0S32.field,
                                ),
                            ),
                        )
                    }
                    4u16 => {
                        Ok(
                            Which::U3f0s64(
                                <i64 as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Union3::U3F0S64.field,
                                ),
                            ),
                        )
                    }
                    unknown => Err(_p::NotInSchema(unknown)),
                }
            }
        }
        impl<'b, 'p: 'b, T: _p::Table + 'p> _p::UnionViewer<&'b mut Builder<'p, T>>
        for Which {
            type View = Which<&'b mut Builder<'p, T>>;
            unsafe fn get(
                repr: &'b mut Builder<'p, T>,
            ) -> Result<Self::View, _p::NotInSchema> {
                let tag = repr.0.data_field::<u16>(3usize);
                match tag {
                    0u16 => {
                        Ok(
                            Which::U3f0s1(
                                <bool as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Union3::U3F0S1.field,
                                ),
                            ),
                        )
                    }
                    1u16 => {
                        Ok(
                            Which::U3f0s8(
                                <i8 as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Union3::U3F0S8.field,
                                ),
                            ),
                        )
                    }
                    2u16 => {
                        Ok(
                            Which::U3f0s16(
                                <i16 as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Union3::U3F0S16.field,
                                ),
                            ),
                        )
                    }
                    3u16 => {
                        Ok(
                            Which::U3f0s32(
                                <i32 as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Union3::U3F0S32.field,
                                ),
                            ),
                        )
                    }
                    4u16 => {
                        Ok(
                            Which::U3f0s64(
                                <i64 as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Union3::U3F0S64.field,
                                ),
                            ),
                        )
                    }
                    unknown => Err(_p::NotInSchema(unknown)),
                }
            }
        }
    }
}
#[derive(Clone)]
pub struct TestUnnamedUnion<T = _p::Family>(T);
impl _p::ty::SchemaType for TestUnnamedUnion {
    const ID: u64 = 11398179977172298166u64;
}
impl<T> _p::IntoFamily for TestUnnamedUnion<T> {
    type Family = TestUnnamedUnion;
}
impl<T: _p::Capable> _p::Capable for TestUnnamedUnion<T> {
    type Table = T::Table;
    type Imbued = T::Imbued;
    type ImbuedWith<T2: _p::rpc::Table> = TestUnnamedUnion<T::ImbuedWith<T2>>;
    #[inline]
    fn imbued(&self) -> &Self::Imbued {
        self.0.imbued()
    }
    #[inline]
    fn imbue_release<T2: _p::rpc::Table>(
        self,
        new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
    ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
        let (imbued, old) = self.0.imbue_release(new_table);
        (TestUnnamedUnion(imbued), old)
    }
    #[inline]
    fn imbue_release_into<U>(&self, other: U) -> (U::ImbuedWith<Self::Table>, U::Imbued)
    where
        U: _p::Capable,
        U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
    {
        self.0.imbue_release_into(other)
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_unnamed_union::Reader<'a, T> {
    type Ptr = _p::StructReader<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
for test_unnamed_union::Reader<'a, T> {
    #[inline]
    fn from(ptr: _p::StructReader<'a, T>) -> Self {
        TestUnnamedUnion(ptr)
    }
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_unnamed_union::Reader<'a, T>>
for _p::StructReader<'a, T> {
    #[inline]
    fn from(reader: test_unnamed_union::Reader<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
for test_unnamed_union::Reader<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructReader<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructReader for test_unnamed_union::Reader<'a, T> {}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_unnamed_union::Builder<'a, T> {
    type Ptr = _p::StructBuilder<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_unnamed_union::Builder<'a, T>>
for _p::StructBuilder<'a, T> {
    #[inline]
    fn from(reader: test_unnamed_union::Builder<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
for test_unnamed_union::Builder<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
for test_unnamed_union::Builder<'a, T> {
    #[inline]
    fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
        &mut self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder
for test_unnamed_union::Builder<'a, T> {
    unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
        Self(ptr)
    }
}
impl _p::StructView for TestUnnamedUnion {
    type Reader<'a, T: _p::rpc::Table> = test_unnamed_union::Reader<'a, T>;
    type Builder<'a, T: _p::rpc::Table> = test_unnamed_union::Builder<'a, T>;
}
impl _p::ty::Struct for TestUnnamedUnion {
    const SIZE: _p::StructSize = _p::StructSize {
        data: 2u16,
        ptrs: 2u16,
    };
}
impl TestUnnamedUnion {
    const BEFORE: _p::Descriptor<_p::Text> = _p::Descriptor::<_p::Text> {
        slot: 0u32,
        default: ::core::option::Option::None,
    };
    const MIDDLE: _p::Descriptor<u16> = _p::Descriptor::<u16> {
        slot: 1u32,
        default: 0u16,
    };
    const AFTER: _p::Descriptor<_p::Text> = _p::Descriptor::<_p::Text> {
        slot: 1u32,
        default: ::core::option::Option::None,
    };
    const FOO: _p::VariantDescriptor<u16> = _p::VariantDescriptor::<u16> {
        variant: _p::VariantInfo {
            slot: 2u32,
            case: 0u16,
        },
        field: _p::Descriptor::<u16> {
            slot: 0u32,
            default: 0u16,
        },
    };
    const BAR: _p::VariantDescriptor<u32> = _p::VariantDescriptor::<u32> {
        variant: _p::VariantInfo {
            slot: 2u32,
            case: 1u16,
        },
        field: _p::Descriptor::<u32> {
            slot: 2u32,
            default: 0u32,
        },
    };
}
impl<'p, T: _p::rpc::Table + 'p> test_unnamed_union::Reader<'p, T> {
    #[inline]
    pub fn before(&self) -> _p::Accessor<'_, 'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(
                &self.0,
                &TestUnnamedUnion::BEFORE,
            )
        }
    }
    #[inline]
    pub fn middle(&self) -> _p::Accessor<'_, 'p, T, u16> {
        unsafe {
            <u16 as _p::field::FieldType>::accessor(&self.0, &TestUnnamedUnion::MIDDLE)
        }
    }
    #[inline]
    pub fn after(&self) -> _p::Accessor<'_, 'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(
                &self.0,
                &TestUnnamedUnion::AFTER,
            )
        }
    }
    #[inline]
    pub fn foo(&self) -> _p::Variant<'_, 'p, T, u16> {
        unsafe {
            <u16 as _p::field::FieldType>::variant(&self.0, &TestUnnamedUnion::FOO)
        }
    }
    #[inline]
    pub fn bar(&self) -> _p::Variant<'_, 'p, T, u32> {
        unsafe {
            <u32 as _p::field::FieldType>::variant(&self.0, &TestUnnamedUnion::BAR)
        }
    }
    #[inline]
    pub fn which(&self) -> Result<test_unnamed_union::Which<&Self>, _p::NotInSchema> {
        unsafe { <test_unnamed_union::Which<_> as _p::UnionViewer<_>>::get(self) }
    }
}
impl<'p, T: _p::rpc::Table + 'p> test_unnamed_union::Builder<'p, T> {
    #[inline]
    pub fn before(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestUnnamedUnion::BEFORE,
            )
        }
    }
    #[inline]
    pub fn middle(&mut self) -> _p::AccessorMut<'_, 'p, T, u16> {
        unsafe {
            <u16 as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestUnnamedUnion::MIDDLE,
            )
        }
    }
    #[inline]
    pub fn after(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestUnnamedUnion::AFTER,
            )
        }
    }
    #[inline]
    pub fn foo(&mut self) -> _p::VariantMut<'_, 'p, T, u16> {
        unsafe {
            <u16 as _p::field::FieldType>::variant(&mut self.0, &TestUnnamedUnion::FOO)
        }
    }
    #[inline]
    pub fn bar(&mut self) -> _p::VariantMut<'_, 'p, T, u32> {
        unsafe {
            <u32 as _p::field::FieldType>::variant(&mut self.0, &TestUnnamedUnion::BAR)
        }
    }
    #[inline]
    pub fn into_before(self) -> _p::AccessorOwned<'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(
                self.0,
                &TestUnnamedUnion::BEFORE,
            )
        }
    }
    #[inline]
    pub fn into_after(self) -> _p::AccessorOwned<'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(
                self.0,
                &TestUnnamedUnion::AFTER,
            )
        }
    }
    #[inline]
    pub fn which(
        &mut self,
    ) -> Result<test_unnamed_union::Which<&mut Self>, _p::NotInSchema> {
        unsafe { <test_unnamed_union::Which<_> as _p::UnionViewer<_>>::get(self) }
    }
}
pub mod test_unnamed_union {
    use super::{__file, __imports, _p};
    pub type Reader<'a, T = _p::rpc::Empty> = super::TestUnnamedUnion<
        _p::StructReader<'a, T>,
    >;
    pub type Builder<'a, T = _p::rpc::Empty> = super::TestUnnamedUnion<
        _p::StructBuilder<'a, T>,
    >;
    pub enum Which<T: _p::Viewable = _p::Family> {
        Foo(_p::ViewOf<T, u16>),
        Bar(_p::ViewOf<T, u32>),
    }
    impl<'b, 'p: 'b, T: _p::Table + 'p> _p::UnionViewer<&'b Reader<'p, T>> for Which {
        type View = Which<&'b Reader<'p, T>>;
        unsafe fn get(repr: &'b Reader<'p, T>) -> Result<Self::View, _p::NotInSchema> {
            let tag = repr.0.data_field::<u16>(2usize);
            match tag {
                0u16 => {
                    Ok(
                        Which::Foo(
                            <u16 as _p::field::FieldType>::accessor(
                                &repr.0,
                                &super::TestUnnamedUnion::FOO.field,
                            ),
                        ),
                    )
                }
                1u16 => {
                    Ok(
                        Which::Bar(
                            <u32 as _p::field::FieldType>::accessor(
                                &repr.0,
                                &super::TestUnnamedUnion::BAR.field,
                            ),
                        ),
                    )
                }
                unknown => Err(_p::NotInSchema(unknown)),
            }
        }
    }
    impl<'b, 'p: 'b, T: _p::Table + 'p> _p::UnionViewer<&'b mut Builder<'p, T>>
    for Which {
        type View = Which<&'b mut Builder<'p, T>>;
        unsafe fn get(
            repr: &'b mut Builder<'p, T>,
        ) -> Result<Self::View, _p::NotInSchema> {
            let tag = repr.0.data_field::<u16>(2usize);
            match tag {
                0u16 => {
                    Ok(
                        Which::Foo(
                            <u16 as _p::field::FieldType>::accessor(
                                &mut repr.0,
                                &super::TestUnnamedUnion::FOO.field,
                            ),
                        ),
                    )
                }
                1u16 => {
                    Ok(
                        Which::Bar(
                            <u32 as _p::field::FieldType>::accessor(
                                &mut repr.0,
                                &super::TestUnnamedUnion::BAR.field,
                            ),
                        ),
                    )
                }
                unknown => Err(_p::NotInSchema(unknown)),
            }
        }
    }
}
#[derive(Clone)]
pub struct TestUnionInUnion<T = _p::Family>(T);
impl _p::ty::SchemaType for TestUnionInUnion {
    const ID: u64 = 9919540258373898018u64;
}
impl<T> _p::IntoFamily for TestUnionInUnion<T> {
    type Family = TestUnionInUnion;
}
impl<T: _p::Capable> _p::Capable for TestUnionInUnion<T> {
    type Table = T::Table;
    type Imbued = T::Imbued;
    type ImbuedWith<T2: _p::rpc::Table> = TestUnionInUnion<T::ImbuedWith<T2>>;
    #[inline]
    fn imbued(&self) -> &Self::Imbued {
        self.0.imbued()
    }
    #[inline]
    fn imbue_release<T2: _p::rpc::Table>(
        self,
        new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
    ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
        let (imbued, old) = self.0.imbue_release(new_table);
        (TestUnionInUnion(imbued), old)
    }
    #[inline]
    fn imbue_release_into<U>(&self, other: U) -> (U::ImbuedWith<Self::Table>, U::Imbued)
    where
        U: _p::Capable,
        U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
    {
        self.0.imbue_release_into(other)
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_union_in_union::Reader<'a, T> {
    type Ptr = _p::StructReader<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
for test_union_in_union::Reader<'a, T> {
    #[inline]
    fn from(ptr: _p::StructReader<'a, T>) -> Self {
        TestUnionInUnion(ptr)
    }
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_union_in_union::Reader<'a, T>>
for _p::StructReader<'a, T> {
    #[inline]
    fn from(reader: test_union_in_union::Reader<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
for test_union_in_union::Reader<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructReader<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructReader for test_union_in_union::Reader<'a, T> {}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_union_in_union::Builder<'a, T> {
    type Ptr = _p::StructBuilder<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_union_in_union::Builder<'a, T>>
for _p::StructBuilder<'a, T> {
    #[inline]
    fn from(reader: test_union_in_union::Builder<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
for test_union_in_union::Builder<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
for test_union_in_union::Builder<'a, T> {
    #[inline]
    fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
        &mut self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder
for test_union_in_union::Builder<'a, T> {
    unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
        Self(ptr)
    }
}
impl _p::StructView for TestUnionInUnion {
    type Reader<'a, T: _p::rpc::Table> = test_union_in_union::Reader<'a, T>;
    type Builder<'a, T: _p::rpc::Table> = test_union_in_union::Builder<'a, T>;
}
impl _p::ty::Struct for TestUnionInUnion {
    const SIZE: _p::StructSize = _p::StructSize {
        data: 2u16,
        ptrs: 0u16,
    };
}
impl TestUnionInUnion {
    const OUTER: _p::Descriptor<_p::Group<test_union_in_union::Outer>> = ();
}
impl<'p, T: _p::rpc::Table + 'p> test_union_in_union::Reader<'p, T> {
    #[inline]
    pub fn outer(
        &self,
    ) -> _p::Accessor<'_, 'p, T, _p::Group<test_union_in_union::Outer>> {
        unsafe {
            <_p::Group<
                test_union_in_union::Outer,
            > as _p::field::FieldType>::accessor(&self.0, &TestUnionInUnion::OUTER)
        }
    }
}
impl<'p, T: _p::rpc::Table + 'p> test_union_in_union::Builder<'p, T> {
    #[inline]
    pub fn outer(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::Group<test_union_in_union::Outer>> {
        unsafe {
            <_p::Group<
                test_union_in_union::Outer,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestUnionInUnion::OUTER)
        }
    }
    #[inline]
    pub fn into_outer(
        self,
    ) -> _p::AccessorOwned<'p, T, _p::Group<test_union_in_union::Outer>> {
        unsafe {
            <_p::Group<
                test_union_in_union::Outer,
            > as _p::field::FieldType>::accessor(self.0, &TestUnionInUnion::OUTER)
        }
    }
}
pub mod test_union_in_union {
    use super::{__file, __imports, _p};
    pub type Reader<'a, T = _p::rpc::Empty> = super::TestUnionInUnion<
        _p::StructReader<'a, T>,
    >;
    pub type Builder<'a, T = _p::rpc::Empty> = super::TestUnionInUnion<
        _p::StructBuilder<'a, T>,
    >;
    #[derive(Clone)]
    pub struct Outer<T = _p::Family>(T);
    impl _p::ty::SchemaType for Outer {
        const ID: u64 = 14989658265959753484u64;
    }
    impl<T> _p::IntoFamily for Outer<T> {
        type Family = Outer;
    }
    impl<T: _p::Capable> _p::Capable for Outer<T> {
        type Table = T::Table;
        type Imbued = T::Imbued;
        type ImbuedWith<T2: _p::rpc::Table> = Outer<T::ImbuedWith<T2>>;
        #[inline]
        fn imbued(&self) -> &Self::Imbued {
            self.0.imbued()
        }
        #[inline]
        fn imbue_release<T2: _p::rpc::Table>(
            self,
            new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
        ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
            let (imbued, old) = self.0.imbue_release(new_table);
            (Outer(imbued), old)
        }
        #[inline]
        fn imbue_release_into<U>(
            &self,
            other: U,
        ) -> (U::ImbuedWith<Self::Table>, U::Imbued)
        where
            U: _p::Capable,
            U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
        {
            self.0.imbue_release_into(other)
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for outer::Reader<'a, T> {
        type Ptr = _p::StructReader<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
    for outer::Reader<'a, T> {
        #[inline]
        fn from(ptr: _p::StructReader<'a, T>) -> Self {
            Outer(ptr)
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<outer::Reader<'a, T>>
    for _p::StructReader<'a, T> {
        #[inline]
        fn from(reader: outer::Reader<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
    for outer::Reader<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructReader<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructReader for outer::Reader<'a, T> {}
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for outer::Builder<'a, T> {
        type Ptr = _p::StructBuilder<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<outer::Builder<'a, T>>
    for _p::StructBuilder<'a, T> {
        #[inline]
        fn from(reader: outer::Builder<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
    for outer::Builder<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
    for outer::Builder<'a, T> {
        #[inline]
        fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
            &mut self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for outer::Builder<'a, T> {
        unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
            Self(ptr)
        }
    }
    impl _p::StructView for Outer {
        type Reader<'a, T: _p::rpc::Table> = outer::Reader<'a, T>;
        type Builder<'a, T: _p::rpc::Table> = outer::Builder<'a, T>;
    }
    impl _p::FieldGroup for Outer {
        unsafe fn clear<'a, 'b, T: _p::rpc::Table>(s: &'a mut _p::StructBuilder<'b, T>) {
            s.set_field_unchecked(4usize, 0);
            <_p::Group<
                outer::Inner,
            > as _p::field::FieldType>::clear(s, &Outer::INNER.field);
        }
    }
    impl Outer {
        const INNER: _p::VariantDescriptor<_p::Group<outer::Inner>> = _p::VariantDescriptor::<
            _p::Group<outer::Inner>,
        > {
            variant: _p::VariantInfo {
                slot: 4u32,
                case: 0u16,
            },
            field: (),
        };
        const BAZ: _p::VariantDescriptor<i32> = _p::VariantDescriptor::<i32> {
            variant: _p::VariantInfo {
                slot: 4u32,
                case: 1u16,
            },
            field: _p::Descriptor::<i32> {
                slot: 0u32,
                default: 0i32,
            },
        };
    }
    impl<'p, T: _p::rpc::Table + 'p> outer::Reader<'p, T> {
        #[inline]
        pub fn inner(&self) -> _p::Variant<'_, 'p, T, _p::Group<outer::Inner>> {
            unsafe {
                <_p::Group<
                    outer::Inner,
                > as _p::field::FieldType>::variant(&self.0, &Outer::INNER)
            }
        }
        #[inline]
        pub fn baz(&self) -> _p::Variant<'_, 'p, T, i32> {
            unsafe { <i32 as _p::field::FieldType>::variant(&self.0, &Outer::BAZ) }
        }
        #[inline]
        pub fn which(&self) -> Result<outer::Which<&Self>, _p::NotInSchema> {
            unsafe { <outer::Which<_> as _p::UnionViewer<_>>::get(self) }
        }
    }
    impl<'p, T: _p::rpc::Table + 'p> outer::Builder<'p, T> {
        #[inline]
        pub fn inner(&mut self) -> _p::VariantMut<'_, 'p, T, _p::Group<outer::Inner>> {
            unsafe {
                <_p::Group<
                    outer::Inner,
                > as _p::field::FieldType>::variant(&mut self.0, &Outer::INNER)
            }
        }
        #[inline]
        pub fn baz(&mut self) -> _p::VariantMut<'_, 'p, T, i32> {
            unsafe { <i32 as _p::field::FieldType>::variant(&mut self.0, &Outer::BAZ) }
        }
        #[inline]
        pub fn into_inner(self) -> _p::VariantOwned<'p, T, _p::Group<outer::Inner>> {
            unsafe {
                <_p::Group<
                    outer::Inner,
                > as _p::field::FieldType>::variant(self.0, &Outer::INNER)
            }
        }
        #[inline]
        pub fn which(&mut self) -> Result<outer::Which<&mut Self>, _p::NotInSchema> {
            unsafe { <outer::Which<_> as _p::UnionViewer<_>>::get(self) }
        }
    }
    pub mod outer {
        use super::{__file, __imports, _p};
        pub type Reader<'a, T = _p::rpc::Empty> = super::Outer<_p::StructReader<'a, T>>;
        pub type Builder<'a, T = _p::rpc::Empty> = super::Outer<
            _p::StructBuilder<'a, T>,
        >;
        pub enum Which<T: _p::Viewable = _p::Family> {
            Inner(_p::ViewOf<T, _p::Group<Inner>>),
            Baz(_p::ViewOf<T, i32>),
        }
        impl<'b, 'p: 'b, T: _p::Table + 'p> _p::UnionViewer<&'b Reader<'p, T>>
        for Which {
            type View = Which<&'b Reader<'p, T>>;
            unsafe fn get(
                repr: &'b Reader<'p, T>,
            ) -> Result<Self::View, _p::NotInSchema> {
                let tag = repr.0.data_field::<u16>(4usize);
                match tag {
                    0u16 => {
                        Ok(
                            Which::Inner(
                                <_p::Group<
                                    Inner,
                                > as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Outer::INNER.field,
                                ),
                            ),
                        )
                    }
                    1u16 => {
                        Ok(
                            Which::Baz(
                                <i32 as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Outer::BAZ.field,
                                ),
                            ),
                        )
                    }
                    unknown => Err(_p::NotInSchema(unknown)),
                }
            }
        }
        impl<'b, 'p: 'b, T: _p::Table + 'p> _p::UnionViewer<&'b mut Builder<'p, T>>
        for Which {
            type View = Which<&'b mut Builder<'p, T>>;
            unsafe fn get(
                repr: &'b mut Builder<'p, T>,
            ) -> Result<Self::View, _p::NotInSchema> {
                let tag = repr.0.data_field::<u16>(4usize);
                match tag {
                    0u16 => {
                        Ok(
                            Which::Inner(
                                <_p::Group<
                                    Inner,
                                > as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Outer::INNER.field,
                                ),
                            ),
                        )
                    }
                    1u16 => {
                        Ok(
                            Which::Baz(
                                <i32 as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Outer::BAZ.field,
                                ),
                            ),
                        )
                    }
                    unknown => Err(_p::NotInSchema(unknown)),
                }
            }
        }
        #[derive(Clone)]
        pub struct Inner<T = _p::Family>(T);
        impl _p::ty::SchemaType for Inner {
            const ID: u64 = 18418844042507380187u64;
        }
        impl<T> _p::IntoFamily for Inner<T> {
            type Family = Inner;
        }
        impl<T: _p::Capable> _p::Capable for Inner<T> {
            type Table = T::Table;
            type Imbued = T::Imbued;
            type ImbuedWith<T2: _p::rpc::Table> = Inner<T::ImbuedWith<T2>>;
            #[inline]
            fn imbued(&self) -> &Self::Imbued {
                self.0.imbued()
            }
            #[inline]
            fn imbue_release<T2: _p::rpc::Table>(
                self,
                new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
            ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
                let (imbued, old) = self.0.imbue_release(new_table);
                (Inner(imbued), old)
            }
            #[inline]
            fn imbue_release_into<U>(
                &self,
                other: U,
            ) -> (U::ImbuedWith<Self::Table>, U::Imbued)
            where
                U: _p::Capable,
                U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
            {
                self.0.imbue_release_into(other)
            }
        }
        impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for inner::Reader<'a, T> {
            type Ptr = _p::StructReader<'a, T>;
        }
        impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
        for inner::Reader<'a, T> {
            #[inline]
            fn from(ptr: _p::StructReader<'a, T>) -> Self {
                Inner(ptr)
            }
        }
        impl<'a, T: _p::rpc::Table> core::convert::From<inner::Reader<'a, T>>
        for _p::StructReader<'a, T> {
            #[inline]
            fn from(reader: inner::Reader<'a, T>) -> Self {
                reader.0
            }
        }
        impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
        for inner::Reader<'a, T> {
            #[inline]
            fn as_ref(&self) -> &_p::StructReader<'a, T> {
                &self.0
            }
        }
        impl<'a, T: _p::rpc::Table> _p::ty::StructReader for inner::Reader<'a, T> {}
        impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for inner::Builder<'a, T> {
            type Ptr = _p::StructBuilder<'a, T>;
        }
        impl<'a, T: _p::rpc::Table> core::convert::From<inner::Builder<'a, T>>
        for _p::StructBuilder<'a, T> {
            #[inline]
            fn from(reader: inner::Builder<'a, T>) -> Self {
                reader.0
            }
        }
        impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
        for inner::Builder<'a, T> {
            #[inline]
            fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
                &self.0
            }
        }
        impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
        for inner::Builder<'a, T> {
            #[inline]
            fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
                &mut self.0
            }
        }
        impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for inner::Builder<'a, T> {
            unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
                Self(ptr)
            }
        }
        impl _p::StructView for Inner {
            type Reader<'a, T: _p::rpc::Table> = inner::Reader<'a, T>;
            type Builder<'a, T: _p::rpc::Table> = inner::Builder<'a, T>;
        }
        impl _p::FieldGroup for Inner {
            unsafe fn clear<'a, 'b, T: _p::rpc::Table>(
                s: &'a mut _p::StructBuilder<'b, T>,
            ) {
                s.set_field_unchecked(2usize, 0);
                <i32 as _p::field::FieldType>::clear(s, &Inner::FOO.field);
            }
        }
        impl Inner {
            const FOO: _p::VariantDescriptor<i32> = _p::VariantDescriptor::<i32> {
                variant: _p::VariantInfo {
                    slot: 2u32,
                    case: 0u16,
                },
                field: _p::Descriptor::<i32> {
                    slot: 0u32,
                    default: 0i32,
                },
            };
            const BAR: _p::VariantDescriptor<i32> = _p::VariantDescriptor::<i32> {
                variant: _p::VariantInfo {
                    slot: 2u32,
                    case: 1u16,
                },
                field: _p::Descriptor::<i32> {
                    slot: 0u32,
                    default: 0i32,
                },
            };
        }
        impl<'p, T: _p::rpc::Table + 'p> inner::Reader<'p, T> {
            #[inline]
            pub fn foo(&self) -> _p::Variant<'_, 'p, T, i32> {
                unsafe { <i32 as _p::field::FieldType>::variant(&self.0, &Inner::FOO) }
            }
            #[inline]
            pub fn bar(&self) -> _p::Variant<'_, 'p, T, i32> {
                unsafe { <i32 as _p::field::FieldType>::variant(&self.0, &Inner::BAR) }
            }
            #[inline]
            pub fn which(&self) -> Result<inner::Which<&Self>, _p::NotInSchema> {
                unsafe { <inner::Which<_> as _p::UnionViewer<_>>::get(self) }
            }
        }
        impl<'p, T: _p::rpc::Table + 'p> inner::Builder<'p, T> {
            #[inline]
            pub fn foo(&mut self) -> _p::VariantMut<'_, 'p, T, i32> {
                unsafe {
                    <i32 as _p::field::FieldType>::variant(&mut self.0, &Inner::FOO)
                }
            }
            #[inline]
            pub fn bar(&mut self) -> _p::VariantMut<'_, 'p, T, i32> {
                unsafe {
                    <i32 as _p::field::FieldType>::variant(&mut self.0, &Inner::BAR)
                }
            }
            #[inline]
            pub fn which(&mut self) -> Result<inner::Which<&mut Self>, _p::NotInSchema> {
                unsafe { <inner::Which<_> as _p::UnionViewer<_>>::get(self) }
            }
        }
        pub mod inner {
            use super::{__file, __imports, _p};
            pub type Reader<'a, T = _p::rpc::Empty> = super::Inner<
                _p::StructReader<'a, T>,
            >;
            pub type Builder<'a, T = _p::rpc::Empty> = super::Inner<
                _p::StructBuilder<'a, T>,
            >;
            pub enum Which<T: _p::Viewable = _p::Family> {
                Foo(_p::ViewOf<T, i32>),
                Bar(_p::ViewOf<T, i32>),
            }
            impl<'b, 'p: 'b, T: _p::Table + 'p> _p::UnionViewer<&'b Reader<'p, T>>
            for Which {
                type View = Which<&'b Reader<'p, T>>;
                unsafe fn get(
                    repr: &'b Reader<'p, T>,
                ) -> Result<Self::View, _p::NotInSchema> {
                    let tag = repr.0.data_field::<u16>(2usize);
                    match tag {
                        0u16 => {
                            Ok(
                                Which::Foo(
                                    <i32 as _p::field::FieldType>::accessor(
                                        &repr.0,
                                        &super::Inner::FOO.field,
                                    ),
                                ),
                            )
                        }
                        1u16 => {
                            Ok(
                                Which::Bar(
                                    <i32 as _p::field::FieldType>::accessor(
                                        &repr.0,
                                        &super::Inner::BAR.field,
                                    ),
                                ),
                            )
                        }
                        unknown => Err(_p::NotInSchema(unknown)),
                    }
                }
            }
            impl<'b, 'p: 'b, T: _p::Table + 'p> _p::UnionViewer<&'b mut Builder<'p, T>>
            for Which {
                type View = Which<&'b mut Builder<'p, T>>;
                unsafe fn get(
                    repr: &'b mut Builder<'p, T>,
                ) -> Result<Self::View, _p::NotInSchema> {
                    let tag = repr.0.data_field::<u16>(2usize);
                    match tag {
                        0u16 => {
                            Ok(
                                Which::Foo(
                                    <i32 as _p::field::FieldType>::accessor(
                                        &mut repr.0,
                                        &super::Inner::FOO.field,
                                    ),
                                ),
                            )
                        }
                        1u16 => {
                            Ok(
                                Which::Bar(
                                    <i32 as _p::field::FieldType>::accessor(
                                        &mut repr.0,
                                        &super::Inner::BAR.field,
                                    ),
                                ),
                            )
                        }
                        unknown => Err(_p::NotInSchema(unknown)),
                    }
                }
            }
        }
    }
}
#[derive(Clone)]
pub struct TestGroups<T = _p::Family>(T);
impl _p::ty::SchemaType for TestGroups {
    const ID: u64 = 15889848844705083651u64;
}
impl<T> _p::IntoFamily for TestGroups<T> {
    type Family = TestGroups;
}
impl<T: _p::Capable> _p::Capable for TestGroups<T> {
    type Table = T::Table;
    type Imbued = T::Imbued;
    type ImbuedWith<T2: _p::rpc::Table> = TestGroups<T::ImbuedWith<T2>>;
    #[inline]
    fn imbued(&self) -> &Self::Imbued {
        self.0.imbued()
    }
    #[inline]
    fn imbue_release<T2: _p::rpc::Table>(
        self,
        new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
    ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
        let (imbued, old) = self.0.imbue_release(new_table);
        (TestGroups(imbued), old)
    }
    #[inline]
    fn imbue_release_into<U>(&self, other: U) -> (U::ImbuedWith<Self::Table>, U::Imbued)
    where
        U: _p::Capable,
        U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
    {
        self.0.imbue_release_into(other)
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_groups::Reader<'a, T> {
    type Ptr = _p::StructReader<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
for test_groups::Reader<'a, T> {
    #[inline]
    fn from(ptr: _p::StructReader<'a, T>) -> Self {
        TestGroups(ptr)
    }
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_groups::Reader<'a, T>>
for _p::StructReader<'a, T> {
    #[inline]
    fn from(reader: test_groups::Reader<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
for test_groups::Reader<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructReader<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructReader for test_groups::Reader<'a, T> {}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_groups::Builder<'a, T> {
    type Ptr = _p::StructBuilder<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_groups::Builder<'a, T>>
for _p::StructBuilder<'a, T> {
    #[inline]
    fn from(reader: test_groups::Builder<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
for test_groups::Builder<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
for test_groups::Builder<'a, T> {
    #[inline]
    fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
        &mut self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for test_groups::Builder<'a, T> {
    unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
        Self(ptr)
    }
}
impl _p::StructView for TestGroups {
    type Reader<'a, T: _p::rpc::Table> = test_groups::Reader<'a, T>;
    type Builder<'a, T: _p::rpc::Table> = test_groups::Builder<'a, T>;
}
impl _p::ty::Struct for TestGroups {
    const SIZE: _p::StructSize = _p::StructSize {
        data: 2u16,
        ptrs: 2u16,
    };
}
impl TestGroups {
    const GROUPS: _p::Descriptor<_p::Group<test_groups::Groups>> = ();
}
impl<'p, T: _p::rpc::Table + 'p> test_groups::Reader<'p, T> {
    #[inline]
    pub fn groups(&self) -> _p::Accessor<'_, 'p, T, _p::Group<test_groups::Groups>> {
        unsafe {
            <_p::Group<
                test_groups::Groups,
            > as _p::field::FieldType>::accessor(&self.0, &TestGroups::GROUPS)
        }
    }
}
impl<'p, T: _p::rpc::Table + 'p> test_groups::Builder<'p, T> {
    #[inline]
    pub fn groups(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::Group<test_groups::Groups>> {
        unsafe {
            <_p::Group<
                test_groups::Groups,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestGroups::GROUPS)
        }
    }
    #[inline]
    pub fn into_groups(
        self,
    ) -> _p::AccessorOwned<'p, T, _p::Group<test_groups::Groups>> {
        unsafe {
            <_p::Group<
                test_groups::Groups,
            > as _p::field::FieldType>::accessor(self.0, &TestGroups::GROUPS)
        }
    }
}
pub mod test_groups {
    use super::{__file, __imports, _p};
    pub type Reader<'a, T = _p::rpc::Empty> = super::TestGroups<_p::StructReader<'a, T>>;
    pub type Builder<'a, T = _p::rpc::Empty> = super::TestGroups<
        _p::StructBuilder<'a, T>,
    >;
    #[derive(Clone)]
    pub struct Groups<T = _p::Family>(T);
    impl _p::ty::SchemaType for Groups {
        const ID: u64 = 16297092532260647528u64;
    }
    impl<T> _p::IntoFamily for Groups<T> {
        type Family = Groups;
    }
    impl<T: _p::Capable> _p::Capable for Groups<T> {
        type Table = T::Table;
        type Imbued = T::Imbued;
        type ImbuedWith<T2: _p::rpc::Table> = Groups<T::ImbuedWith<T2>>;
        #[inline]
        fn imbued(&self) -> &Self::Imbued {
            self.0.imbued()
        }
        #[inline]
        fn imbue_release<T2: _p::rpc::Table>(
            self,
            new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
        ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
            let (imbued, old) = self.0.imbue_release(new_table);
            (Groups(imbued), old)
        }
        #[inline]
        fn imbue_release_into<U>(
            &self,
            other: U,
        ) -> (U::ImbuedWith<Self::Table>, U::Imbued)
        where
            U: _p::Capable,
            U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
        {
            self.0.imbue_release_into(other)
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for groups::Reader<'a, T> {
        type Ptr = _p::StructReader<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
    for groups::Reader<'a, T> {
        #[inline]
        fn from(ptr: _p::StructReader<'a, T>) -> Self {
            Groups(ptr)
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<groups::Reader<'a, T>>
    for _p::StructReader<'a, T> {
        #[inline]
        fn from(reader: groups::Reader<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
    for groups::Reader<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructReader<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructReader for groups::Reader<'a, T> {}
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for groups::Builder<'a, T> {
        type Ptr = _p::StructBuilder<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<groups::Builder<'a, T>>
    for _p::StructBuilder<'a, T> {
        #[inline]
        fn from(reader: groups::Builder<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
    for groups::Builder<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
    for groups::Builder<'a, T> {
        #[inline]
        fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
            &mut self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for groups::Builder<'a, T> {
        unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
            Self(ptr)
        }
    }
    impl _p::StructView for Groups {
        type Reader<'a, T: _p::rpc::Table> = groups::Reader<'a, T>;
        type Builder<'a, T: _p::rpc::Table> = groups::Builder<'a, T>;
    }
    impl _p::FieldGroup for Groups {
        unsafe fn clear<'a, 'b, T: _p::rpc::Table>(s: &'a mut _p::StructBuilder<'b, T>) {
            s.set_field_unchecked(2usize, 0);
            <_p::Group<
                groups::Foo,
            > as _p::field::FieldType>::clear(s, &Groups::FOO.field);
        }
    }
    impl Groups {
        const FOO: _p::VariantDescriptor<_p::Group<groups::Foo>> = _p::VariantDescriptor::<
            _p::Group<groups::Foo>,
        > {
            variant: _p::VariantInfo {
                slot: 2u32,
                case: 0u16,
            },
            field: (),
        };
        const BAZ: _p::VariantDescriptor<_p::Group<groups::Baz>> = _p::VariantDescriptor::<
            _p::Group<groups::Baz>,
        > {
            variant: _p::VariantInfo {
                slot: 2u32,
                case: 1u16,
            },
            field: (),
        };
        const BAR: _p::VariantDescriptor<_p::Group<groups::Bar>> = _p::VariantDescriptor::<
            _p::Group<groups::Bar>,
        > {
            variant: _p::VariantInfo {
                slot: 2u32,
                case: 2u16,
            },
            field: (),
        };
    }
    impl<'p, T: _p::rpc::Table + 'p> groups::Reader<'p, T> {
        #[inline]
        pub fn foo(&self) -> _p::Variant<'_, 'p, T, _p::Group<groups::Foo>> {
            unsafe {
                <_p::Group<
                    groups::Foo,
                > as _p::field::FieldType>::variant(&self.0, &Groups::FOO)
            }
        }
        #[inline]
        pub fn baz(&self) -> _p::Variant<'_, 'p, T, _p::Group<groups::Baz>> {
            unsafe {
                <_p::Group<
                    groups::Baz,
                > as _p::field::FieldType>::variant(&self.0, &Groups::BAZ)
            }
        }
        #[inline]
        pub fn bar(&self) -> _p::Variant<'_, 'p, T, _p::Group<groups::Bar>> {
            unsafe {
                <_p::Group<
                    groups::Bar,
                > as _p::field::FieldType>::variant(&self.0, &Groups::BAR)
            }
        }
        #[inline]
        pub fn which(&self) -> Result<groups::Which<&Self>, _p::NotInSchema> {
            unsafe { <groups::Which<_> as _p::UnionViewer<_>>::get(self) }
        }
    }
    impl<'p, T: _p::rpc::Table + 'p> groups::Builder<'p, T> {
        #[inline]
        pub fn foo(&mut self) -> _p::VariantMut<'_, 'p, T, _p::Group<groups::Foo>> {
            unsafe {
                <_p::Group<
                    groups::Foo,
                > as _p::field::FieldType>::variant(&mut self.0, &Groups::FOO)
            }
        }
        #[inline]
        pub fn baz(&mut self) -> _p::VariantMut<'_, 'p, T, _p::Group<groups::Baz>> {
            unsafe {
                <_p::Group<
                    groups::Baz,
                > as _p::field::FieldType>::variant(&mut self.0, &Groups::BAZ)
            }
        }
        #[inline]
        pub fn bar(&mut self) -> _p::VariantMut<'_, 'p, T, _p::Group<groups::Bar>> {
            unsafe {
                <_p::Group<
                    groups::Bar,
                > as _p::field::FieldType>::variant(&mut self.0, &Groups::BAR)
            }
        }
        #[inline]
        pub fn into_foo(self) -> _p::VariantOwned<'p, T, _p::Group<groups::Foo>> {
            unsafe {
                <_p::Group<
                    groups::Foo,
                > as _p::field::FieldType>::variant(self.0, &Groups::FOO)
            }
        }
        #[inline]
        pub fn into_baz(self) -> _p::VariantOwned<'p, T, _p::Group<groups::Baz>> {
            unsafe {
                <_p::Group<
                    groups::Baz,
                > as _p::field::FieldType>::variant(self.0, &Groups::BAZ)
            }
        }
        #[inline]
        pub fn into_bar(self) -> _p::VariantOwned<'p, T, _p::Group<groups::Bar>> {
            unsafe {
                <_p::Group<
                    groups::Bar,
                > as _p::field::FieldType>::variant(self.0, &Groups::BAR)
            }
        }
        #[inline]
        pub fn which(&mut self) -> Result<groups::Which<&mut Self>, _p::NotInSchema> {
            unsafe { <groups::Which<_> as _p::UnionViewer<_>>::get(self) }
        }
    }
    pub mod groups {
        use super::{__file, __imports, _p};
        pub type Reader<'a, T = _p::rpc::Empty> = super::Groups<_p::StructReader<'a, T>>;
        pub type Builder<'a, T = _p::rpc::Empty> = super::Groups<
            _p::StructBuilder<'a, T>,
        >;
        pub enum Which<T: _p::Viewable = _p::Family> {
            Foo(_p::ViewOf<T, _p::Group<Foo>>),
            Baz(_p::ViewOf<T, _p::Group<Baz>>),
            Bar(_p::ViewOf<T, _p::Group<Bar>>),
        }
        impl<'b, 'p: 'b, T: _p::Table + 'p> _p::UnionViewer<&'b Reader<'p, T>>
        for Which {
            type View = Which<&'b Reader<'p, T>>;
            unsafe fn get(
                repr: &'b Reader<'p, T>,
            ) -> Result<Self::View, _p::NotInSchema> {
                let tag = repr.0.data_field::<u16>(2usize);
                match tag {
                    0u16 => {
                        Ok(
                            Which::Foo(
                                <_p::Group<
                                    Foo,
                                > as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Groups::FOO.field,
                                ),
                            ),
                        )
                    }
                    1u16 => {
                        Ok(
                            Which::Baz(
                                <_p::Group<
                                    Baz,
                                > as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Groups::BAZ.field,
                                ),
                            ),
                        )
                    }
                    2u16 => {
                        Ok(
                            Which::Bar(
                                <_p::Group<
                                    Bar,
                                > as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Groups::BAR.field,
                                ),
                            ),
                        )
                    }
                    unknown => Err(_p::NotInSchema(unknown)),
                }
            }
        }
        impl<'b, 'p: 'b, T: _p::Table + 'p> _p::UnionViewer<&'b mut Builder<'p, T>>
        for Which {
            type View = Which<&'b mut Builder<'p, T>>;
            unsafe fn get(
                repr: &'b mut Builder<'p, T>,
            ) -> Result<Self::View, _p::NotInSchema> {
                let tag = repr.0.data_field::<u16>(2usize);
                match tag {
                    0u16 => {
                        Ok(
                            Which::Foo(
                                <_p::Group<
                                    Foo,
                                > as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Groups::FOO.field,
                                ),
                            ),
                        )
                    }
                    1u16 => {
                        Ok(
                            Which::Baz(
                                <_p::Group<
                                    Baz,
                                > as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Groups::BAZ.field,
                                ),
                            ),
                        )
                    }
                    2u16 => {
                        Ok(
                            Which::Bar(
                                <_p::Group<
                                    Bar,
                                > as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Groups::BAR.field,
                                ),
                            ),
                        )
                    }
                    unknown => Err(_p::NotInSchema(unknown)),
                }
            }
        }
        #[derive(Clone)]
        pub struct Foo<T = _p::Family>(T);
        impl _p::ty::SchemaType for Foo {
            const ID: u64 = 17725247334230595951u64;
        }
        impl<T> _p::IntoFamily for Foo<T> {
            type Family = Foo;
        }
        impl<T: _p::Capable> _p::Capable for Foo<T> {
            type Table = T::Table;
            type Imbued = T::Imbued;
            type ImbuedWith<T2: _p::rpc::Table> = Foo<T::ImbuedWith<T2>>;
            #[inline]
            fn imbued(&self) -> &Self::Imbued {
                self.0.imbued()
            }
            #[inline]
            fn imbue_release<T2: _p::rpc::Table>(
                self,
                new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
            ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
                let (imbued, old) = self.0.imbue_release(new_table);
                (Foo(imbued), old)
            }
            #[inline]
            fn imbue_release_into<U>(
                &self,
                other: U,
            ) -> (U::ImbuedWith<Self::Table>, U::Imbued)
            where
                U: _p::Capable,
                U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
            {
                self.0.imbue_release_into(other)
            }
        }
        impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for foo::Reader<'a, T> {
            type Ptr = _p::StructReader<'a, T>;
        }
        impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
        for foo::Reader<'a, T> {
            #[inline]
            fn from(ptr: _p::StructReader<'a, T>) -> Self {
                Foo(ptr)
            }
        }
        impl<'a, T: _p::rpc::Table> core::convert::From<foo::Reader<'a, T>>
        for _p::StructReader<'a, T> {
            #[inline]
            fn from(reader: foo::Reader<'a, T>) -> Self {
                reader.0
            }
        }
        impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
        for foo::Reader<'a, T> {
            #[inline]
            fn as_ref(&self) -> &_p::StructReader<'a, T> {
                &self.0
            }
        }
        impl<'a, T: _p::rpc::Table> _p::ty::StructReader for foo::Reader<'a, T> {}
        impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for foo::Builder<'a, T> {
            type Ptr = _p::StructBuilder<'a, T>;
        }
        impl<'a, T: _p::rpc::Table> core::convert::From<foo::Builder<'a, T>>
        for _p::StructBuilder<'a, T> {
            #[inline]
            fn from(reader: foo::Builder<'a, T>) -> Self {
                reader.0
            }
        }
        impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
        for foo::Builder<'a, T> {
            #[inline]
            fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
                &self.0
            }
        }
        impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
        for foo::Builder<'a, T> {
            #[inline]
            fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
                &mut self.0
            }
        }
        impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for foo::Builder<'a, T> {
            unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
                Self(ptr)
            }
        }
        impl _p::StructView for Foo {
            type Reader<'a, T: _p::rpc::Table> = foo::Reader<'a, T>;
            type Builder<'a, T: _p::rpc::Table> = foo::Builder<'a, T>;
        }
        impl _p::FieldGroup for Foo {
            unsafe fn clear<'a, 'b, T: _p::rpc::Table>(
                s: &'a mut _p::StructBuilder<'b, T>,
            ) {
                <i32 as _p::field::FieldType>::clear(s, &Foo::CORGE);
                <i64 as _p::field::FieldType>::clear(s, &Foo::GRAULT);
                <_p::Text as _p::field::FieldType>::clear(s, &Foo::GARPLY);
            }
        }
        impl Foo {
            const CORGE: _p::Descriptor<i32> = _p::Descriptor::<i32> {
                slot: 0u32,
                default: 0i32,
            };
            const GRAULT: _p::Descriptor<i64> = _p::Descriptor::<i64> {
                slot: 1u32,
                default: 0i64,
            };
            const GARPLY: _p::Descriptor<_p::Text> = _p::Descriptor::<_p::Text> {
                slot: 0u32,
                default: ::core::option::Option::None,
            };
        }
        impl<'p, T: _p::rpc::Table + 'p> foo::Reader<'p, T> {
            #[inline]
            pub fn corge(&self) -> _p::Accessor<'_, 'p, T, i32> {
                unsafe { <i32 as _p::field::FieldType>::accessor(&self.0, &Foo::CORGE) }
            }
            #[inline]
            pub fn grault(&self) -> _p::Accessor<'_, 'p, T, i64> {
                unsafe { <i64 as _p::field::FieldType>::accessor(&self.0, &Foo::GRAULT) }
            }
            #[inline]
            pub fn garply(&self) -> _p::Accessor<'_, 'p, T, _p::Text> {
                unsafe {
                    <_p::Text as _p::field::FieldType>::accessor(&self.0, &Foo::GARPLY)
                }
            }
        }
        impl<'p, T: _p::rpc::Table + 'p> foo::Builder<'p, T> {
            #[inline]
            pub fn corge(&mut self) -> _p::AccessorMut<'_, 'p, T, i32> {
                unsafe {
                    <i32 as _p::field::FieldType>::accessor(&mut self.0, &Foo::CORGE)
                }
            }
            #[inline]
            pub fn grault(&mut self) -> _p::AccessorMut<'_, 'p, T, i64> {
                unsafe {
                    <i64 as _p::field::FieldType>::accessor(&mut self.0, &Foo::GRAULT)
                }
            }
            #[inline]
            pub fn garply(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Text> {
                unsafe {
                    <_p::Text as _p::field::FieldType>::accessor(
                        &mut self.0,
                        &Foo::GARPLY,
                    )
                }
            }
            #[inline]
            pub fn into_garply(self) -> _p::AccessorOwned<'p, T, _p::Text> {
                unsafe {
                    <_p::Text as _p::field::FieldType>::accessor(self.0, &Foo::GARPLY)
                }
            }
        }
        pub mod foo {
            use super::{__file, __imports, _p};
            pub type Reader<'a, T = _p::rpc::Empty> = super::Foo<
                _p::StructReader<'a, T>,
            >;
            pub type Builder<'a, T = _p::rpc::Empty> = super::Foo<
                _p::StructBuilder<'a, T>,
            >;
        }
        #[derive(Clone)]
        pub struct Baz<T = _p::Family>(T);
        impl _p::ty::SchemaType for Baz {
            const ID: u64 = 17364244297077400755u64;
        }
        impl<T> _p::IntoFamily for Baz<T> {
            type Family = Baz;
        }
        impl<T: _p::Capable> _p::Capable for Baz<T> {
            type Table = T::Table;
            type Imbued = T::Imbued;
            type ImbuedWith<T2: _p::rpc::Table> = Baz<T::ImbuedWith<T2>>;
            #[inline]
            fn imbued(&self) -> &Self::Imbued {
                self.0.imbued()
            }
            #[inline]
            fn imbue_release<T2: _p::rpc::Table>(
                self,
                new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
            ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
                let (imbued, old) = self.0.imbue_release(new_table);
                (Baz(imbued), old)
            }
            #[inline]
            fn imbue_release_into<U>(
                &self,
                other: U,
            ) -> (U::ImbuedWith<Self::Table>, U::Imbued)
            where
                U: _p::Capable,
                U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
            {
                self.0.imbue_release_into(other)
            }
        }
        impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for baz::Reader<'a, T> {
            type Ptr = _p::StructReader<'a, T>;
        }
        impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
        for baz::Reader<'a, T> {
            #[inline]
            fn from(ptr: _p::StructReader<'a, T>) -> Self {
                Baz(ptr)
            }
        }
        impl<'a, T: _p::rpc::Table> core::convert::From<baz::Reader<'a, T>>
        for _p::StructReader<'a, T> {
            #[inline]
            fn from(reader: baz::Reader<'a, T>) -> Self {
                reader.0
            }
        }
        impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
        for baz::Reader<'a, T> {
            #[inline]
            fn as_ref(&self) -> &_p::StructReader<'a, T> {
                &self.0
            }
        }
        impl<'a, T: _p::rpc::Table> _p::ty::StructReader for baz::Reader<'a, T> {}
        impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for baz::Builder<'a, T> {
            type Ptr = _p::StructBuilder<'a, T>;
        }
        impl<'a, T: _p::rpc::Table> core::convert::From<baz::Builder<'a, T>>
        for _p::StructBuilder<'a, T> {
            #[inline]
            fn from(reader: baz::Builder<'a, T>) -> Self {
                reader.0
            }
        }
        impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
        for baz::Builder<'a, T> {
            #[inline]
            fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
                &self.0
            }
        }
        impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
        for baz::Builder<'a, T> {
            #[inline]
            fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
                &mut self.0
            }
        }
        impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for baz::Builder<'a, T> {
            unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
                Self(ptr)
            }
        }
        impl _p::StructView for Baz {
            type Reader<'a, T: _p::rpc::Table> = baz::Reader<'a, T>;
            type Builder<'a, T: _p::rpc::Table> = baz::Builder<'a, T>;
        }
        impl _p::FieldGroup for Baz {
            unsafe fn clear<'a, 'b, T: _p::rpc::Table>(
                s: &'a mut _p::StructBuilder<'b, T>,
            ) {
                <i32 as _p::field::FieldType>::clear(s, &Baz::CORGE);
                <_p::Text as _p::field::FieldType>::clear(s, &Baz::GRAULT);
                <_p::Text as _p::field::FieldType>::clear(s, &Baz::GARPLY);
            }
        }
        impl Baz {
            const CORGE: _p::Descriptor<i32> = _p::Descriptor::<i32> {
                slot: 0u32,
                default: 0i32,
            };
            const GRAULT: _p::Descriptor<_p::Text> = _p::Descriptor::<_p::Text> {
                slot: 0u32,
                default: ::core::option::Option::None,
            };
            const GARPLY: _p::Descriptor<_p::Text> = _p::Descriptor::<_p::Text> {
                slot: 1u32,
                default: ::core::option::Option::None,
            };
        }
        impl<'p, T: _p::rpc::Table + 'p> baz::Reader<'p, T> {
            #[inline]
            pub fn corge(&self) -> _p::Accessor<'_, 'p, T, i32> {
                unsafe { <i32 as _p::field::FieldType>::accessor(&self.0, &Baz::CORGE) }
            }
            #[inline]
            pub fn grault(&self) -> _p::Accessor<'_, 'p, T, _p::Text> {
                unsafe {
                    <_p::Text as _p::field::FieldType>::accessor(&self.0, &Baz::GRAULT)
                }
            }
            #[inline]
            pub fn garply(&self) -> _p::Accessor<'_, 'p, T, _p::Text> {
                unsafe {
                    <_p::Text as _p::field::FieldType>::accessor(&self.0, &Baz::GARPLY)
                }
            }
        }
        impl<'p, T: _p::rpc::Table + 'p> baz::Builder<'p, T> {
            #[inline]
            pub fn corge(&mut self) -> _p::AccessorMut<'_, 'p, T, i32> {
                unsafe {
                    <i32 as _p::field::FieldType>::accessor(&mut self.0, &Baz::CORGE)
                }
            }
            #[inline]
            pub fn grault(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Text> {
                unsafe {
                    <_p::Text as _p::field::FieldType>::accessor(
                        &mut self.0,
                        &Baz::GRAULT,
                    )
                }
            }
            #[inline]
            pub fn garply(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Text> {
                unsafe {
                    <_p::Text as _p::field::FieldType>::accessor(
                        &mut self.0,
                        &Baz::GARPLY,
                    )
                }
            }
            #[inline]
            pub fn into_grault(self) -> _p::AccessorOwned<'p, T, _p::Text> {
                unsafe {
                    <_p::Text as _p::field::FieldType>::accessor(self.0, &Baz::GRAULT)
                }
            }
            #[inline]
            pub fn into_garply(self) -> _p::AccessorOwned<'p, T, _p::Text> {
                unsafe {
                    <_p::Text as _p::field::FieldType>::accessor(self.0, &Baz::GARPLY)
                }
            }
        }
        pub mod baz {
            use super::{__file, __imports, _p};
            pub type Reader<'a, T = _p::rpc::Empty> = super::Baz<
                _p::StructReader<'a, T>,
            >;
            pub type Builder<'a, T = _p::rpc::Empty> = super::Baz<
                _p::StructBuilder<'a, T>,
            >;
        }
        #[derive(Clone)]
        pub struct Bar<T = _p::Family>(T);
        impl _p::ty::SchemaType for Bar {
            const ID: u64 = 13197729232770957341u64;
        }
        impl<T> _p::IntoFamily for Bar<T> {
            type Family = Bar;
        }
        impl<T: _p::Capable> _p::Capable for Bar<T> {
            type Table = T::Table;
            type Imbued = T::Imbued;
            type ImbuedWith<T2: _p::rpc::Table> = Bar<T::ImbuedWith<T2>>;
            #[inline]
            fn imbued(&self) -> &Self::Imbued {
                self.0.imbued()
            }
            #[inline]
            fn imbue_release<T2: _p::rpc::Table>(
                self,
                new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
            ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
                let (imbued, old) = self.0.imbue_release(new_table);
                (Bar(imbued), old)
            }
            #[inline]
            fn imbue_release_into<U>(
                &self,
                other: U,
            ) -> (U::ImbuedWith<Self::Table>, U::Imbued)
            where
                U: _p::Capable,
                U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
            {
                self.0.imbue_release_into(other)
            }
        }
        impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for bar::Reader<'a, T> {
            type Ptr = _p::StructReader<'a, T>;
        }
        impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
        for bar::Reader<'a, T> {
            #[inline]
            fn from(ptr: _p::StructReader<'a, T>) -> Self {
                Bar(ptr)
            }
        }
        impl<'a, T: _p::rpc::Table> core::convert::From<bar::Reader<'a, T>>
        for _p::StructReader<'a, T> {
            #[inline]
            fn from(reader: bar::Reader<'a, T>) -> Self {
                reader.0
            }
        }
        impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
        for bar::Reader<'a, T> {
            #[inline]
            fn as_ref(&self) -> &_p::StructReader<'a, T> {
                &self.0
            }
        }
        impl<'a, T: _p::rpc::Table> _p::ty::StructReader for bar::Reader<'a, T> {}
        impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for bar::Builder<'a, T> {
            type Ptr = _p::StructBuilder<'a, T>;
        }
        impl<'a, T: _p::rpc::Table> core::convert::From<bar::Builder<'a, T>>
        for _p::StructBuilder<'a, T> {
            #[inline]
            fn from(reader: bar::Builder<'a, T>) -> Self {
                reader.0
            }
        }
        impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
        for bar::Builder<'a, T> {
            #[inline]
            fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
                &self.0
            }
        }
        impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
        for bar::Builder<'a, T> {
            #[inline]
            fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
                &mut self.0
            }
        }
        impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for bar::Builder<'a, T> {
            unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
                Self(ptr)
            }
        }
        impl _p::StructView for Bar {
            type Reader<'a, T: _p::rpc::Table> = bar::Reader<'a, T>;
            type Builder<'a, T: _p::rpc::Table> = bar::Builder<'a, T>;
        }
        impl _p::FieldGroup for Bar {
            unsafe fn clear<'a, 'b, T: _p::rpc::Table>(
                s: &'a mut _p::StructBuilder<'b, T>,
            ) {
                <i32 as _p::field::FieldType>::clear(s, &Bar::CORGE);
                <_p::Text as _p::field::FieldType>::clear(s, &Bar::GRAULT);
                <i64 as _p::field::FieldType>::clear(s, &Bar::GARPLY);
            }
        }
        impl Bar {
            const CORGE: _p::Descriptor<i32> = _p::Descriptor::<i32> {
                slot: 0u32,
                default: 0i32,
            };
            const GRAULT: _p::Descriptor<_p::Text> = _p::Descriptor::<_p::Text> {
                slot: 0u32,
                default: ::core::option::Option::None,
            };
            const GARPLY: _p::Descriptor<i64> = _p::Descriptor::<i64> {
                slot: 1u32,
                default: 0i64,
            };
        }
        impl<'p, T: _p::rpc::Table + 'p> bar::Reader<'p, T> {
            #[inline]
            pub fn corge(&self) -> _p::Accessor<'_, 'p, T, i32> {
                unsafe { <i32 as _p::field::FieldType>::accessor(&self.0, &Bar::CORGE) }
            }
            #[inline]
            pub fn grault(&self) -> _p::Accessor<'_, 'p, T, _p::Text> {
                unsafe {
                    <_p::Text as _p::field::FieldType>::accessor(&self.0, &Bar::GRAULT)
                }
            }
            #[inline]
            pub fn garply(&self) -> _p::Accessor<'_, 'p, T, i64> {
                unsafe { <i64 as _p::field::FieldType>::accessor(&self.0, &Bar::GARPLY) }
            }
        }
        impl<'p, T: _p::rpc::Table + 'p> bar::Builder<'p, T> {
            #[inline]
            pub fn corge(&mut self) -> _p::AccessorMut<'_, 'p, T, i32> {
                unsafe {
                    <i32 as _p::field::FieldType>::accessor(&mut self.0, &Bar::CORGE)
                }
            }
            #[inline]
            pub fn grault(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Text> {
                unsafe {
                    <_p::Text as _p::field::FieldType>::accessor(
                        &mut self.0,
                        &Bar::GRAULT,
                    )
                }
            }
            #[inline]
            pub fn garply(&mut self) -> _p::AccessorMut<'_, 'p, T, i64> {
                unsafe {
                    <i64 as _p::field::FieldType>::accessor(&mut self.0, &Bar::GARPLY)
                }
            }
            #[inline]
            pub fn into_grault(self) -> _p::AccessorOwned<'p, T, _p::Text> {
                unsafe {
                    <_p::Text as _p::field::FieldType>::accessor(self.0, &Bar::GRAULT)
                }
            }
        }
        pub mod bar {
            use super::{__file, __imports, _p};
            pub type Reader<'a, T = _p::rpc::Empty> = super::Bar<
                _p::StructReader<'a, T>,
            >;
            pub type Builder<'a, T = _p::rpc::Empty> = super::Bar<
                _p::StructBuilder<'a, T>,
            >;
        }
    }
}
#[derive(Clone)]
pub struct TestInterleavedGroups<T = _p::Family>(T);
impl _p::ty::SchemaType for TestInterleavedGroups {
    const ID: u64 = 17833927931941809216u64;
}
impl<T> _p::IntoFamily for TestInterleavedGroups<T> {
    type Family = TestInterleavedGroups;
}
impl<T: _p::Capable> _p::Capable for TestInterleavedGroups<T> {
    type Table = T::Table;
    type Imbued = T::Imbued;
    type ImbuedWith<T2: _p::rpc::Table> = TestInterleavedGroups<T::ImbuedWith<T2>>;
    #[inline]
    fn imbued(&self) -> &Self::Imbued {
        self.0.imbued()
    }
    #[inline]
    fn imbue_release<T2: _p::rpc::Table>(
        self,
        new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
    ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
        let (imbued, old) = self.0.imbue_release(new_table);
        (TestInterleavedGroups(imbued), old)
    }
    #[inline]
    fn imbue_release_into<U>(&self, other: U) -> (U::ImbuedWith<Self::Table>, U::Imbued)
    where
        U: _p::Capable,
        U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
    {
        self.0.imbue_release_into(other)
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_interleaved_groups::Reader<'a, T> {
    type Ptr = _p::StructReader<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
for test_interleaved_groups::Reader<'a, T> {
    #[inline]
    fn from(ptr: _p::StructReader<'a, T>) -> Self {
        TestInterleavedGroups(ptr)
    }
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_interleaved_groups::Reader<'a, T>>
for _p::StructReader<'a, T> {
    #[inline]
    fn from(reader: test_interleaved_groups::Reader<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
for test_interleaved_groups::Reader<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructReader<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructReader
for test_interleaved_groups::Reader<'a, T> {}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr
for test_interleaved_groups::Builder<'a, T> {
    type Ptr = _p::StructBuilder<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_interleaved_groups::Builder<'a, T>>
for _p::StructBuilder<'a, T> {
    #[inline]
    fn from(reader: test_interleaved_groups::Builder<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
for test_interleaved_groups::Builder<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
for test_interleaved_groups::Builder<'a, T> {
    #[inline]
    fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
        &mut self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder
for test_interleaved_groups::Builder<'a, T> {
    unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
        Self(ptr)
    }
}
impl _p::StructView for TestInterleavedGroups {
    type Reader<'a, T: _p::rpc::Table> = test_interleaved_groups::Reader<'a, T>;
    type Builder<'a, T: _p::rpc::Table> = test_interleaved_groups::Builder<'a, T>;
}
impl _p::ty::Struct for TestInterleavedGroups {
    const SIZE: _p::StructSize = _p::StructSize {
        data: 6u16,
        ptrs: 6u16,
    };
}
impl TestInterleavedGroups {
    const GROUP1: _p::Descriptor<_p::Group<test_interleaved_groups::Group1>> = ();
    const GROUP2: _p::Descriptor<_p::Group<test_interleaved_groups::Group2>> = ();
}
impl<'p, T: _p::rpc::Table + 'p> test_interleaved_groups::Reader<'p, T> {
    #[inline]
    pub fn group1(
        &self,
    ) -> _p::Accessor<'_, 'p, T, _p::Group<test_interleaved_groups::Group1>> {
        unsafe {
            <_p::Group<
                test_interleaved_groups::Group1,
            > as _p::field::FieldType>::accessor(&self.0, &TestInterleavedGroups::GROUP1)
        }
    }
    #[inline]
    pub fn group2(
        &self,
    ) -> _p::Accessor<'_, 'p, T, _p::Group<test_interleaved_groups::Group2>> {
        unsafe {
            <_p::Group<
                test_interleaved_groups::Group2,
            > as _p::field::FieldType>::accessor(&self.0, &TestInterleavedGroups::GROUP2)
        }
    }
}
impl<'p, T: _p::rpc::Table + 'p> test_interleaved_groups::Builder<'p, T> {
    #[inline]
    pub fn group1(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::Group<test_interleaved_groups::Group1>> {
        unsafe {
            <_p::Group<
                test_interleaved_groups::Group1,
            > as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestInterleavedGroups::GROUP1,
            )
        }
    }
    #[inline]
    pub fn group2(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::Group<test_interleaved_groups::Group2>> {
        unsafe {
            <_p::Group<
                test_interleaved_groups::Group2,
            > as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestInterleavedGroups::GROUP2,
            )
        }
    }
    #[inline]
    pub fn into_group1(
        self,
    ) -> _p::AccessorOwned<'p, T, _p::Group<test_interleaved_groups::Group1>> {
        unsafe {
            <_p::Group<
                test_interleaved_groups::Group1,
            > as _p::field::FieldType>::accessor(self.0, &TestInterleavedGroups::GROUP1)
        }
    }
    #[inline]
    pub fn into_group2(
        self,
    ) -> _p::AccessorOwned<'p, T, _p::Group<test_interleaved_groups::Group2>> {
        unsafe {
            <_p::Group<
                test_interleaved_groups::Group2,
            > as _p::field::FieldType>::accessor(self.0, &TestInterleavedGroups::GROUP2)
        }
    }
}
pub mod test_interleaved_groups {
    use super::{__file, __imports, _p};
    pub type Reader<'a, T = _p::rpc::Empty> = super::TestInterleavedGroups<
        _p::StructReader<'a, T>,
    >;
    pub type Builder<'a, T = _p::rpc::Empty> = super::TestInterleavedGroups<
        _p::StructBuilder<'a, T>,
    >;
    #[derive(Clone)]
    pub struct Group1<T = _p::Family>(T);
    impl _p::ty::SchemaType for Group1 {
        const ID: u64 = 14359826595932787656u64;
    }
    impl<T> _p::IntoFamily for Group1<T> {
        type Family = Group1;
    }
    impl<T: _p::Capable> _p::Capable for Group1<T> {
        type Table = T::Table;
        type Imbued = T::Imbued;
        type ImbuedWith<T2: _p::rpc::Table> = Group1<T::ImbuedWith<T2>>;
        #[inline]
        fn imbued(&self) -> &Self::Imbued {
            self.0.imbued()
        }
        #[inline]
        fn imbue_release<T2: _p::rpc::Table>(
            self,
            new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
        ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
            let (imbued, old) = self.0.imbue_release(new_table);
            (Group1(imbued), old)
        }
        #[inline]
        fn imbue_release_into<U>(
            &self,
            other: U,
        ) -> (U::ImbuedWith<Self::Table>, U::Imbued)
        where
            U: _p::Capable,
            U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
        {
            self.0.imbue_release_into(other)
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for group1::Reader<'a, T> {
        type Ptr = _p::StructReader<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
    for group1::Reader<'a, T> {
        #[inline]
        fn from(ptr: _p::StructReader<'a, T>) -> Self {
            Group1(ptr)
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<group1::Reader<'a, T>>
    for _p::StructReader<'a, T> {
        #[inline]
        fn from(reader: group1::Reader<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
    for group1::Reader<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructReader<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructReader for group1::Reader<'a, T> {}
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for group1::Builder<'a, T> {
        type Ptr = _p::StructBuilder<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<group1::Builder<'a, T>>
    for _p::StructBuilder<'a, T> {
        #[inline]
        fn from(reader: group1::Builder<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
    for group1::Builder<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
    for group1::Builder<'a, T> {
        #[inline]
        fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
            &mut self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for group1::Builder<'a, T> {
        unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
            Self(ptr)
        }
    }
    impl _p::StructView for Group1 {
        type Reader<'a, T: _p::rpc::Table> = group1::Reader<'a, T>;
        type Builder<'a, T: _p::rpc::Table> = group1::Builder<'a, T>;
    }
    impl _p::FieldGroup for Group1 {
        unsafe fn clear<'a, 'b, T: _p::rpc::Table>(s: &'a mut _p::StructBuilder<'b, T>) {
            <u32 as _p::field::FieldType>::clear(s, &Group1::FOO);
            <u64 as _p::field::FieldType>::clear(s, &Group1::BAR);
            <_p::Text as _p::field::FieldType>::clear(s, &Group1::WALDO);
            s.set_field_unchecked(14usize, 0);
            <u16 as _p::field::FieldType>::clear(s, &Group1::QUX.field);
        }
    }
    impl Group1 {
        const FOO: _p::Descriptor<u32> = _p::Descriptor::<u32> {
            slot: 0u32,
            default: 0u32,
        };
        const BAR: _p::Descriptor<u64> = _p::Descriptor::<u64> {
            slot: 1u32,
            default: 0u64,
        };
        const WALDO: _p::Descriptor<_p::Text> = _p::Descriptor::<_p::Text> {
            slot: 0u32,
            default: ::core::option::Option::None,
        };
        const QUX: _p::VariantDescriptor<u16> = _p::VariantDescriptor::<u16> {
            variant: _p::VariantInfo {
                slot: 14u32,
                case: 0u16,
            },
            field: _p::Descriptor::<u16> {
                slot: 12u32,
                default: 0u16,
            },
        };
        const CORGE: _p::VariantDescriptor<_p::Group<group1::Corge>> = _p::VariantDescriptor::<
            _p::Group<group1::Corge>,
        > {
            variant: _p::VariantInfo {
                slot: 14u32,
                case: 1u16,
            },
            field: (),
        };
        const FRED: _p::VariantDescriptor<_p::Text> = _p::VariantDescriptor::<_p::Text> {
            variant: _p::VariantInfo {
                slot: 14u32,
                case: 2u16,
            },
            field: _p::Descriptor::<_p::Text> {
                slot: 2u32,
                default: ::core::option::Option::None,
            },
        };
    }
    impl<'p, T: _p::rpc::Table + 'p> group1::Reader<'p, T> {
        #[inline]
        pub fn foo(&self) -> _p::Accessor<'_, 'p, T, u32> {
            unsafe { <u32 as _p::field::FieldType>::accessor(&self.0, &Group1::FOO) }
        }
        #[inline]
        pub fn bar(&self) -> _p::Accessor<'_, 'p, T, u64> {
            unsafe { <u64 as _p::field::FieldType>::accessor(&self.0, &Group1::BAR) }
        }
        #[inline]
        pub fn waldo(&self) -> _p::Accessor<'_, 'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::accessor(&self.0, &Group1::WALDO)
            }
        }
        #[inline]
        pub fn qux(&self) -> _p::Variant<'_, 'p, T, u16> {
            unsafe { <u16 as _p::field::FieldType>::variant(&self.0, &Group1::QUX) }
        }
        #[inline]
        pub fn corge(&self) -> _p::Variant<'_, 'p, T, _p::Group<group1::Corge>> {
            unsafe {
                <_p::Group<
                    group1::Corge,
                > as _p::field::FieldType>::variant(&self.0, &Group1::CORGE)
            }
        }
        #[inline]
        pub fn fred(&self) -> _p::Variant<'_, 'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::variant(&self.0, &Group1::FRED)
            }
        }
        #[inline]
        pub fn which(&self) -> Result<group1::Which<&Self>, _p::NotInSchema> {
            unsafe { <group1::Which<_> as _p::UnionViewer<_>>::get(self) }
        }
    }
    impl<'p, T: _p::rpc::Table + 'p> group1::Builder<'p, T> {
        #[inline]
        pub fn foo(&mut self) -> _p::AccessorMut<'_, 'p, T, u32> {
            unsafe { <u32 as _p::field::FieldType>::accessor(&mut self.0, &Group1::FOO) }
        }
        #[inline]
        pub fn bar(&mut self) -> _p::AccessorMut<'_, 'p, T, u64> {
            unsafe { <u64 as _p::field::FieldType>::accessor(&mut self.0, &Group1::BAR) }
        }
        #[inline]
        pub fn waldo(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::accessor(&mut self.0, &Group1::WALDO)
            }
        }
        #[inline]
        pub fn qux(&mut self) -> _p::VariantMut<'_, 'p, T, u16> {
            unsafe { <u16 as _p::field::FieldType>::variant(&mut self.0, &Group1::QUX) }
        }
        #[inline]
        pub fn corge(&mut self) -> _p::VariantMut<'_, 'p, T, _p::Group<group1::Corge>> {
            unsafe {
                <_p::Group<
                    group1::Corge,
                > as _p::field::FieldType>::variant(&mut self.0, &Group1::CORGE)
            }
        }
        #[inline]
        pub fn fred(&mut self) -> _p::VariantMut<'_, 'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::variant(&mut self.0, &Group1::FRED)
            }
        }
        #[inline]
        pub fn into_waldo(self) -> _p::AccessorOwned<'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::accessor(self.0, &Group1::WALDO)
            }
        }
        #[inline]
        pub fn into_corge(self) -> _p::VariantOwned<'p, T, _p::Group<group1::Corge>> {
            unsafe {
                <_p::Group<
                    group1::Corge,
                > as _p::field::FieldType>::variant(self.0, &Group1::CORGE)
            }
        }
        #[inline]
        pub fn into_fred(self) -> _p::VariantOwned<'p, T, _p::Text> {
            unsafe { <_p::Text as _p::field::FieldType>::variant(self.0, &Group1::FRED) }
        }
        #[inline]
        pub fn which(&mut self) -> Result<group1::Which<&mut Self>, _p::NotInSchema> {
            unsafe { <group1::Which<_> as _p::UnionViewer<_>>::get(self) }
        }
    }
    pub mod group1 {
        use super::{__file, __imports, _p};
        pub type Reader<'a, T = _p::rpc::Empty> = super::Group1<_p::StructReader<'a, T>>;
        pub type Builder<'a, T = _p::rpc::Empty> = super::Group1<
            _p::StructBuilder<'a, T>,
        >;
        pub enum Which<T: _p::Viewable = _p::Family> {
            Qux(_p::ViewOf<T, u16>),
            Corge(_p::ViewOf<T, _p::Group<Corge>>),
            Fred(_p::ViewOf<T, _p::Text>),
        }
        impl<'b, 'p: 'b, T: _p::Table + 'p> _p::UnionViewer<&'b Reader<'p, T>>
        for Which {
            type View = Which<&'b Reader<'p, T>>;
            unsafe fn get(
                repr: &'b Reader<'p, T>,
            ) -> Result<Self::View, _p::NotInSchema> {
                let tag = repr.0.data_field::<u16>(14usize);
                match tag {
                    0u16 => {
                        Ok(
                            Which::Qux(
                                <u16 as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Group1::QUX.field,
                                ),
                            ),
                        )
                    }
                    1u16 => {
                        Ok(
                            Which::Corge(
                                <_p::Group<
                                    Corge,
                                > as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Group1::CORGE.field,
                                ),
                            ),
                        )
                    }
                    2u16 => {
                        Ok(
                            Which::Fred(
                                <_p::Text as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Group1::FRED.field,
                                ),
                            ),
                        )
                    }
                    unknown => Err(_p::NotInSchema(unknown)),
                }
            }
        }
        impl<'b, 'p: 'b, T: _p::Table + 'p> _p::UnionViewer<&'b mut Builder<'p, T>>
        for Which {
            type View = Which<&'b mut Builder<'p, T>>;
            unsafe fn get(
                repr: &'b mut Builder<'p, T>,
            ) -> Result<Self::View, _p::NotInSchema> {
                let tag = repr.0.data_field::<u16>(14usize);
                match tag {
                    0u16 => {
                        Ok(
                            Which::Qux(
                                <u16 as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Group1::QUX.field,
                                ),
                            ),
                        )
                    }
                    1u16 => {
                        Ok(
                            Which::Corge(
                                <_p::Group<
                                    Corge,
                                > as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Group1::CORGE.field,
                                ),
                            ),
                        )
                    }
                    2u16 => {
                        Ok(
                            Which::Fred(
                                <_p::Text as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Group1::FRED.field,
                                ),
                            ),
                        )
                    }
                    unknown => Err(_p::NotInSchema(unknown)),
                }
            }
        }
        #[derive(Clone)]
        pub struct Corge<T = _p::Family>(T);
        impl _p::ty::SchemaType for Corge {
            const ID: u64 = 15783706300749852986u64;
        }
        impl<T> _p::IntoFamily for Corge<T> {
            type Family = Corge;
        }
        impl<T: _p::Capable> _p::Capable for Corge<T> {
            type Table = T::Table;
            type Imbued = T::Imbued;
            type ImbuedWith<T2: _p::rpc::Table> = Corge<T::ImbuedWith<T2>>;
            #[inline]
            fn imbued(&self) -> &Self::Imbued {
                self.0.imbued()
            }
            #[inline]
            fn imbue_release<T2: _p::rpc::Table>(
                self,
                new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
            ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
                let (imbued, old) = self.0.imbue_release(new_table);
                (Corge(imbued), old)
            }
            #[inline]
            fn imbue_release_into<U>(
                &self,
                other: U,
            ) -> (U::ImbuedWith<Self::Table>, U::Imbued)
            where
                U: _p::Capable,
                U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
            {
                self.0.imbue_release_into(other)
            }
        }
        impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for corge::Reader<'a, T> {
            type Ptr = _p::StructReader<'a, T>;
        }
        impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
        for corge::Reader<'a, T> {
            #[inline]
            fn from(ptr: _p::StructReader<'a, T>) -> Self {
                Corge(ptr)
            }
        }
        impl<'a, T: _p::rpc::Table> core::convert::From<corge::Reader<'a, T>>
        for _p::StructReader<'a, T> {
            #[inline]
            fn from(reader: corge::Reader<'a, T>) -> Self {
                reader.0
            }
        }
        impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
        for corge::Reader<'a, T> {
            #[inline]
            fn as_ref(&self) -> &_p::StructReader<'a, T> {
                &self.0
            }
        }
        impl<'a, T: _p::rpc::Table> _p::ty::StructReader for corge::Reader<'a, T> {}
        impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for corge::Builder<'a, T> {
            type Ptr = _p::StructBuilder<'a, T>;
        }
        impl<'a, T: _p::rpc::Table> core::convert::From<corge::Builder<'a, T>>
        for _p::StructBuilder<'a, T> {
            #[inline]
            fn from(reader: corge::Builder<'a, T>) -> Self {
                reader.0
            }
        }
        impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
        for corge::Builder<'a, T> {
            #[inline]
            fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
                &self.0
            }
        }
        impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
        for corge::Builder<'a, T> {
            #[inline]
            fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
                &mut self.0
            }
        }
        impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for corge::Builder<'a, T> {
            unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
                Self(ptr)
            }
        }
        impl _p::StructView for Corge {
            type Reader<'a, T: _p::rpc::Table> = corge::Reader<'a, T>;
            type Builder<'a, T: _p::rpc::Table> = corge::Builder<'a, T>;
        }
        impl _p::FieldGroup for Corge {
            unsafe fn clear<'a, 'b, T: _p::rpc::Table>(
                s: &'a mut _p::StructBuilder<'b, T>,
            ) {
                <u64 as _p::field::FieldType>::clear(s, &Corge::GRAULT);
                <u16 as _p::field::FieldType>::clear(s, &Corge::GARPLY);
                <_p::Text as _p::field::FieldType>::clear(s, &Corge::PLUGH);
                <_p::Text as _p::field::FieldType>::clear(s, &Corge::XYZZY);
            }
        }
        impl Corge {
            const GRAULT: _p::Descriptor<u64> = _p::Descriptor::<u64> {
                slot: 4u32,
                default: 0u64,
            };
            const GARPLY: _p::Descriptor<u16> = _p::Descriptor::<u16> {
                slot: 12u32,
                default: 0u16,
            };
            const PLUGH: _p::Descriptor<_p::Text> = _p::Descriptor::<_p::Text> {
                slot: 2u32,
                default: ::core::option::Option::None,
            };
            const XYZZY: _p::Descriptor<_p::Text> = _p::Descriptor::<_p::Text> {
                slot: 4u32,
                default: ::core::option::Option::None,
            };
        }
        impl<'p, T: _p::rpc::Table + 'p> corge::Reader<'p, T> {
            #[inline]
            pub fn grault(&self) -> _p::Accessor<'_, 'p, T, u64> {
                unsafe {
                    <u64 as _p::field::FieldType>::accessor(&self.0, &Corge::GRAULT)
                }
            }
            #[inline]
            pub fn garply(&self) -> _p::Accessor<'_, 'p, T, u16> {
                unsafe {
                    <u16 as _p::field::FieldType>::accessor(&self.0, &Corge::GARPLY)
                }
            }
            #[inline]
            pub fn plugh(&self) -> _p::Accessor<'_, 'p, T, _p::Text> {
                unsafe {
                    <_p::Text as _p::field::FieldType>::accessor(&self.0, &Corge::PLUGH)
                }
            }
            #[inline]
            pub fn xyzzy(&self) -> _p::Accessor<'_, 'p, T, _p::Text> {
                unsafe {
                    <_p::Text as _p::field::FieldType>::accessor(&self.0, &Corge::XYZZY)
                }
            }
        }
        impl<'p, T: _p::rpc::Table + 'p> corge::Builder<'p, T> {
            #[inline]
            pub fn grault(&mut self) -> _p::AccessorMut<'_, 'p, T, u64> {
                unsafe {
                    <u64 as _p::field::FieldType>::accessor(&mut self.0, &Corge::GRAULT)
                }
            }
            #[inline]
            pub fn garply(&mut self) -> _p::AccessorMut<'_, 'p, T, u16> {
                unsafe {
                    <u16 as _p::field::FieldType>::accessor(&mut self.0, &Corge::GARPLY)
                }
            }
            #[inline]
            pub fn plugh(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Text> {
                unsafe {
                    <_p::Text as _p::field::FieldType>::accessor(
                        &mut self.0,
                        &Corge::PLUGH,
                    )
                }
            }
            #[inline]
            pub fn xyzzy(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Text> {
                unsafe {
                    <_p::Text as _p::field::FieldType>::accessor(
                        &mut self.0,
                        &Corge::XYZZY,
                    )
                }
            }
            #[inline]
            pub fn into_plugh(self) -> _p::AccessorOwned<'p, T, _p::Text> {
                unsafe {
                    <_p::Text as _p::field::FieldType>::accessor(self.0, &Corge::PLUGH)
                }
            }
            #[inline]
            pub fn into_xyzzy(self) -> _p::AccessorOwned<'p, T, _p::Text> {
                unsafe {
                    <_p::Text as _p::field::FieldType>::accessor(self.0, &Corge::XYZZY)
                }
            }
        }
        pub mod corge {
            use super::{__file, __imports, _p};
            pub type Reader<'a, T = _p::rpc::Empty> = super::Corge<
                _p::StructReader<'a, T>,
            >;
            pub type Builder<'a, T = _p::rpc::Empty> = super::Corge<
                _p::StructBuilder<'a, T>,
            >;
        }
    }
    #[derive(Clone)]
    pub struct Group2<T = _p::Family>(T);
    impl _p::ty::SchemaType for Group2 {
        const ID: u64 = 14737364805121315049u64;
    }
    impl<T> _p::IntoFamily for Group2<T> {
        type Family = Group2;
    }
    impl<T: _p::Capable> _p::Capable for Group2<T> {
        type Table = T::Table;
        type Imbued = T::Imbued;
        type ImbuedWith<T2: _p::rpc::Table> = Group2<T::ImbuedWith<T2>>;
        #[inline]
        fn imbued(&self) -> &Self::Imbued {
            self.0.imbued()
        }
        #[inline]
        fn imbue_release<T2: _p::rpc::Table>(
            self,
            new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
        ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
            let (imbued, old) = self.0.imbue_release(new_table);
            (Group2(imbued), old)
        }
        #[inline]
        fn imbue_release_into<U>(
            &self,
            other: U,
        ) -> (U::ImbuedWith<Self::Table>, U::Imbued)
        where
            U: _p::Capable,
            U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
        {
            self.0.imbue_release_into(other)
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for group2::Reader<'a, T> {
        type Ptr = _p::StructReader<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
    for group2::Reader<'a, T> {
        #[inline]
        fn from(ptr: _p::StructReader<'a, T>) -> Self {
            Group2(ptr)
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<group2::Reader<'a, T>>
    for _p::StructReader<'a, T> {
        #[inline]
        fn from(reader: group2::Reader<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
    for group2::Reader<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructReader<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructReader for group2::Reader<'a, T> {}
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for group2::Builder<'a, T> {
        type Ptr = _p::StructBuilder<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<group2::Builder<'a, T>>
    for _p::StructBuilder<'a, T> {
        #[inline]
        fn from(reader: group2::Builder<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
    for group2::Builder<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
    for group2::Builder<'a, T> {
        #[inline]
        fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
            &mut self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for group2::Builder<'a, T> {
        unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
            Self(ptr)
        }
    }
    impl _p::StructView for Group2 {
        type Reader<'a, T: _p::rpc::Table> = group2::Reader<'a, T>;
        type Builder<'a, T: _p::rpc::Table> = group2::Builder<'a, T>;
    }
    impl _p::FieldGroup for Group2 {
        unsafe fn clear<'a, 'b, T: _p::rpc::Table>(s: &'a mut _p::StructBuilder<'b, T>) {
            <u32 as _p::field::FieldType>::clear(s, &Group2::FOO);
            <u64 as _p::field::FieldType>::clear(s, &Group2::BAR);
            <_p::Text as _p::field::FieldType>::clear(s, &Group2::WALDO);
            s.set_field_unchecked(15usize, 0);
            <u16 as _p::field::FieldType>::clear(s, &Group2::QUX.field);
        }
    }
    impl Group2 {
        const FOO: _p::Descriptor<u32> = _p::Descriptor::<u32> {
            slot: 1u32,
            default: 0u32,
        };
        const BAR: _p::Descriptor<u64> = _p::Descriptor::<u64> {
            slot: 2u32,
            default: 0u64,
        };
        const WALDO: _p::Descriptor<_p::Text> = _p::Descriptor::<_p::Text> {
            slot: 1u32,
            default: ::core::option::Option::None,
        };
        const QUX: _p::VariantDescriptor<u16> = _p::VariantDescriptor::<u16> {
            variant: _p::VariantInfo {
                slot: 15u32,
                case: 0u16,
            },
            field: _p::Descriptor::<u16> {
                slot: 13u32,
                default: 0u16,
            },
        };
        const CORGE: _p::VariantDescriptor<_p::Group<group2::Corge>> = _p::VariantDescriptor::<
            _p::Group<group2::Corge>,
        > {
            variant: _p::VariantInfo {
                slot: 15u32,
                case: 1u16,
            },
            field: (),
        };
        const FRED: _p::VariantDescriptor<_p::Text> = _p::VariantDescriptor::<_p::Text> {
            variant: _p::VariantInfo {
                slot: 15u32,
                case: 2u16,
            },
            field: _p::Descriptor::<_p::Text> {
                slot: 3u32,
                default: ::core::option::Option::None,
            },
        };
    }
    impl<'p, T: _p::rpc::Table + 'p> group2::Reader<'p, T> {
        #[inline]
        pub fn foo(&self) -> _p::Accessor<'_, 'p, T, u32> {
            unsafe { <u32 as _p::field::FieldType>::accessor(&self.0, &Group2::FOO) }
        }
        #[inline]
        pub fn bar(&self) -> _p::Accessor<'_, 'p, T, u64> {
            unsafe { <u64 as _p::field::FieldType>::accessor(&self.0, &Group2::BAR) }
        }
        #[inline]
        pub fn waldo(&self) -> _p::Accessor<'_, 'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::accessor(&self.0, &Group2::WALDO)
            }
        }
        #[inline]
        pub fn qux(&self) -> _p::Variant<'_, 'p, T, u16> {
            unsafe { <u16 as _p::field::FieldType>::variant(&self.0, &Group2::QUX) }
        }
        #[inline]
        pub fn corge(&self) -> _p::Variant<'_, 'p, T, _p::Group<group2::Corge>> {
            unsafe {
                <_p::Group<
                    group2::Corge,
                > as _p::field::FieldType>::variant(&self.0, &Group2::CORGE)
            }
        }
        #[inline]
        pub fn fred(&self) -> _p::Variant<'_, 'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::variant(&self.0, &Group2::FRED)
            }
        }
        #[inline]
        pub fn which(&self) -> Result<group2::Which<&Self>, _p::NotInSchema> {
            unsafe { <group2::Which<_> as _p::UnionViewer<_>>::get(self) }
        }
    }
    impl<'p, T: _p::rpc::Table + 'p> group2::Builder<'p, T> {
        #[inline]
        pub fn foo(&mut self) -> _p::AccessorMut<'_, 'p, T, u32> {
            unsafe { <u32 as _p::field::FieldType>::accessor(&mut self.0, &Group2::FOO) }
        }
        #[inline]
        pub fn bar(&mut self) -> _p::AccessorMut<'_, 'p, T, u64> {
            unsafe { <u64 as _p::field::FieldType>::accessor(&mut self.0, &Group2::BAR) }
        }
        #[inline]
        pub fn waldo(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::accessor(&mut self.0, &Group2::WALDO)
            }
        }
        #[inline]
        pub fn qux(&mut self) -> _p::VariantMut<'_, 'p, T, u16> {
            unsafe { <u16 as _p::field::FieldType>::variant(&mut self.0, &Group2::QUX) }
        }
        #[inline]
        pub fn corge(&mut self) -> _p::VariantMut<'_, 'p, T, _p::Group<group2::Corge>> {
            unsafe {
                <_p::Group<
                    group2::Corge,
                > as _p::field::FieldType>::variant(&mut self.0, &Group2::CORGE)
            }
        }
        #[inline]
        pub fn fred(&mut self) -> _p::VariantMut<'_, 'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::variant(&mut self.0, &Group2::FRED)
            }
        }
        #[inline]
        pub fn into_waldo(self) -> _p::AccessorOwned<'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::accessor(self.0, &Group2::WALDO)
            }
        }
        #[inline]
        pub fn into_corge(self) -> _p::VariantOwned<'p, T, _p::Group<group2::Corge>> {
            unsafe {
                <_p::Group<
                    group2::Corge,
                > as _p::field::FieldType>::variant(self.0, &Group2::CORGE)
            }
        }
        #[inline]
        pub fn into_fred(self) -> _p::VariantOwned<'p, T, _p::Text> {
            unsafe { <_p::Text as _p::field::FieldType>::variant(self.0, &Group2::FRED) }
        }
        #[inline]
        pub fn which(&mut self) -> Result<group2::Which<&mut Self>, _p::NotInSchema> {
            unsafe { <group2::Which<_> as _p::UnionViewer<_>>::get(self) }
        }
    }
    pub mod group2 {
        use super::{__file, __imports, _p};
        pub type Reader<'a, T = _p::rpc::Empty> = super::Group2<_p::StructReader<'a, T>>;
        pub type Builder<'a, T = _p::rpc::Empty> = super::Group2<
            _p::StructBuilder<'a, T>,
        >;
        pub enum Which<T: _p::Viewable = _p::Family> {
            Qux(_p::ViewOf<T, u16>),
            Corge(_p::ViewOf<T, _p::Group<Corge>>),
            Fred(_p::ViewOf<T, _p::Text>),
        }
        impl<'b, 'p: 'b, T: _p::Table + 'p> _p::UnionViewer<&'b Reader<'p, T>>
        for Which {
            type View = Which<&'b Reader<'p, T>>;
            unsafe fn get(
                repr: &'b Reader<'p, T>,
            ) -> Result<Self::View, _p::NotInSchema> {
                let tag = repr.0.data_field::<u16>(15usize);
                match tag {
                    0u16 => {
                        Ok(
                            Which::Qux(
                                <u16 as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Group2::QUX.field,
                                ),
                            ),
                        )
                    }
                    1u16 => {
                        Ok(
                            Which::Corge(
                                <_p::Group<
                                    Corge,
                                > as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Group2::CORGE.field,
                                ),
                            ),
                        )
                    }
                    2u16 => {
                        Ok(
                            Which::Fred(
                                <_p::Text as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Group2::FRED.field,
                                ),
                            ),
                        )
                    }
                    unknown => Err(_p::NotInSchema(unknown)),
                }
            }
        }
        impl<'b, 'p: 'b, T: _p::Table + 'p> _p::UnionViewer<&'b mut Builder<'p, T>>
        for Which {
            type View = Which<&'b mut Builder<'p, T>>;
            unsafe fn get(
                repr: &'b mut Builder<'p, T>,
            ) -> Result<Self::View, _p::NotInSchema> {
                let tag = repr.0.data_field::<u16>(15usize);
                match tag {
                    0u16 => {
                        Ok(
                            Which::Qux(
                                <u16 as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Group2::QUX.field,
                                ),
                            ),
                        )
                    }
                    1u16 => {
                        Ok(
                            Which::Corge(
                                <_p::Group<
                                    Corge,
                                > as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Group2::CORGE.field,
                                ),
                            ),
                        )
                    }
                    2u16 => {
                        Ok(
                            Which::Fred(
                                <_p::Text as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Group2::FRED.field,
                                ),
                            ),
                        )
                    }
                    unknown => Err(_p::NotInSchema(unknown)),
                }
            }
        }
        #[derive(Clone)]
        pub struct Corge<T = _p::Family>(T);
        impl _p::ty::SchemaType for Corge {
            const ID: u64 = 11535953086999162423u64;
        }
        impl<T> _p::IntoFamily for Corge<T> {
            type Family = Corge;
        }
        impl<T: _p::Capable> _p::Capable for Corge<T> {
            type Table = T::Table;
            type Imbued = T::Imbued;
            type ImbuedWith<T2: _p::rpc::Table> = Corge<T::ImbuedWith<T2>>;
            #[inline]
            fn imbued(&self) -> &Self::Imbued {
                self.0.imbued()
            }
            #[inline]
            fn imbue_release<T2: _p::rpc::Table>(
                self,
                new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
            ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
                let (imbued, old) = self.0.imbue_release(new_table);
                (Corge(imbued), old)
            }
            #[inline]
            fn imbue_release_into<U>(
                &self,
                other: U,
            ) -> (U::ImbuedWith<Self::Table>, U::Imbued)
            where
                U: _p::Capable,
                U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
            {
                self.0.imbue_release_into(other)
            }
        }
        impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for corge::Reader<'a, T> {
            type Ptr = _p::StructReader<'a, T>;
        }
        impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
        for corge::Reader<'a, T> {
            #[inline]
            fn from(ptr: _p::StructReader<'a, T>) -> Self {
                Corge(ptr)
            }
        }
        impl<'a, T: _p::rpc::Table> core::convert::From<corge::Reader<'a, T>>
        for _p::StructReader<'a, T> {
            #[inline]
            fn from(reader: corge::Reader<'a, T>) -> Self {
                reader.0
            }
        }
        impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
        for corge::Reader<'a, T> {
            #[inline]
            fn as_ref(&self) -> &_p::StructReader<'a, T> {
                &self.0
            }
        }
        impl<'a, T: _p::rpc::Table> _p::ty::StructReader for corge::Reader<'a, T> {}
        impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for corge::Builder<'a, T> {
            type Ptr = _p::StructBuilder<'a, T>;
        }
        impl<'a, T: _p::rpc::Table> core::convert::From<corge::Builder<'a, T>>
        for _p::StructBuilder<'a, T> {
            #[inline]
            fn from(reader: corge::Builder<'a, T>) -> Self {
                reader.0
            }
        }
        impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
        for corge::Builder<'a, T> {
            #[inline]
            fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
                &self.0
            }
        }
        impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
        for corge::Builder<'a, T> {
            #[inline]
            fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
                &mut self.0
            }
        }
        impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for corge::Builder<'a, T> {
            unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
                Self(ptr)
            }
        }
        impl _p::StructView for Corge {
            type Reader<'a, T: _p::rpc::Table> = corge::Reader<'a, T>;
            type Builder<'a, T: _p::rpc::Table> = corge::Builder<'a, T>;
        }
        impl _p::FieldGroup for Corge {
            unsafe fn clear<'a, 'b, T: _p::rpc::Table>(
                s: &'a mut _p::StructBuilder<'b, T>,
            ) {
                <u64 as _p::field::FieldType>::clear(s, &Corge::GRAULT);
                <u16 as _p::field::FieldType>::clear(s, &Corge::GARPLY);
                <_p::Text as _p::field::FieldType>::clear(s, &Corge::PLUGH);
                <_p::Text as _p::field::FieldType>::clear(s, &Corge::XYZZY);
            }
        }
        impl Corge {
            const GRAULT: _p::Descriptor<u64> = _p::Descriptor::<u64> {
                slot: 5u32,
                default: 0u64,
            };
            const GARPLY: _p::Descriptor<u16> = _p::Descriptor::<u16> {
                slot: 13u32,
                default: 0u16,
            };
            const PLUGH: _p::Descriptor<_p::Text> = _p::Descriptor::<_p::Text> {
                slot: 3u32,
                default: ::core::option::Option::None,
            };
            const XYZZY: _p::Descriptor<_p::Text> = _p::Descriptor::<_p::Text> {
                slot: 5u32,
                default: ::core::option::Option::None,
            };
        }
        impl<'p, T: _p::rpc::Table + 'p> corge::Reader<'p, T> {
            #[inline]
            pub fn grault(&self) -> _p::Accessor<'_, 'p, T, u64> {
                unsafe {
                    <u64 as _p::field::FieldType>::accessor(&self.0, &Corge::GRAULT)
                }
            }
            #[inline]
            pub fn garply(&self) -> _p::Accessor<'_, 'p, T, u16> {
                unsafe {
                    <u16 as _p::field::FieldType>::accessor(&self.0, &Corge::GARPLY)
                }
            }
            #[inline]
            pub fn plugh(&self) -> _p::Accessor<'_, 'p, T, _p::Text> {
                unsafe {
                    <_p::Text as _p::field::FieldType>::accessor(&self.0, &Corge::PLUGH)
                }
            }
            #[inline]
            pub fn xyzzy(&self) -> _p::Accessor<'_, 'p, T, _p::Text> {
                unsafe {
                    <_p::Text as _p::field::FieldType>::accessor(&self.0, &Corge::XYZZY)
                }
            }
        }
        impl<'p, T: _p::rpc::Table + 'p> corge::Builder<'p, T> {
            #[inline]
            pub fn grault(&mut self) -> _p::AccessorMut<'_, 'p, T, u64> {
                unsafe {
                    <u64 as _p::field::FieldType>::accessor(&mut self.0, &Corge::GRAULT)
                }
            }
            #[inline]
            pub fn garply(&mut self) -> _p::AccessorMut<'_, 'p, T, u16> {
                unsafe {
                    <u16 as _p::field::FieldType>::accessor(&mut self.0, &Corge::GARPLY)
                }
            }
            #[inline]
            pub fn plugh(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Text> {
                unsafe {
                    <_p::Text as _p::field::FieldType>::accessor(
                        &mut self.0,
                        &Corge::PLUGH,
                    )
                }
            }
            #[inline]
            pub fn xyzzy(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Text> {
                unsafe {
                    <_p::Text as _p::field::FieldType>::accessor(
                        &mut self.0,
                        &Corge::XYZZY,
                    )
                }
            }
            #[inline]
            pub fn into_plugh(self) -> _p::AccessorOwned<'p, T, _p::Text> {
                unsafe {
                    <_p::Text as _p::field::FieldType>::accessor(self.0, &Corge::PLUGH)
                }
            }
            #[inline]
            pub fn into_xyzzy(self) -> _p::AccessorOwned<'p, T, _p::Text> {
                unsafe {
                    <_p::Text as _p::field::FieldType>::accessor(self.0, &Corge::XYZZY)
                }
            }
        }
        pub mod corge {
            use super::{__file, __imports, _p};
            pub type Reader<'a, T = _p::rpc::Empty> = super::Corge<
                _p::StructReader<'a, T>,
            >;
            pub type Builder<'a, T = _p::rpc::Empty> = super::Corge<
                _p::StructBuilder<'a, T>,
            >;
        }
    }
}
#[derive(Clone)]
pub struct TestUnionDefaults<T = _p::Family>(T);
impl _p::ty::SchemaType for TestUnionDefaults {
    const ID: u64 = 10734295287736874776u64;
}
impl<T> _p::IntoFamily for TestUnionDefaults<T> {
    type Family = TestUnionDefaults;
}
impl<T: _p::Capable> _p::Capable for TestUnionDefaults<T> {
    type Table = T::Table;
    type Imbued = T::Imbued;
    type ImbuedWith<T2: _p::rpc::Table> = TestUnionDefaults<T::ImbuedWith<T2>>;
    #[inline]
    fn imbued(&self) -> &Self::Imbued {
        self.0.imbued()
    }
    #[inline]
    fn imbue_release<T2: _p::rpc::Table>(
        self,
        new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
    ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
        let (imbued, old) = self.0.imbue_release(new_table);
        (TestUnionDefaults(imbued), old)
    }
    #[inline]
    fn imbue_release_into<U>(&self, other: U) -> (U::ImbuedWith<Self::Table>, U::Imbued)
    where
        U: _p::Capable,
        U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
    {
        self.0.imbue_release_into(other)
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_union_defaults::Reader<'a, T> {
    type Ptr = _p::StructReader<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
for test_union_defaults::Reader<'a, T> {
    #[inline]
    fn from(ptr: _p::StructReader<'a, T>) -> Self {
        TestUnionDefaults(ptr)
    }
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_union_defaults::Reader<'a, T>>
for _p::StructReader<'a, T> {
    #[inline]
    fn from(reader: test_union_defaults::Reader<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
for test_union_defaults::Reader<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructReader<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructReader for test_union_defaults::Reader<'a, T> {}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_union_defaults::Builder<'a, T> {
    type Ptr = _p::StructBuilder<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_union_defaults::Builder<'a, T>>
for _p::StructBuilder<'a, T> {
    #[inline]
    fn from(reader: test_union_defaults::Builder<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
for test_union_defaults::Builder<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
for test_union_defaults::Builder<'a, T> {
    #[inline]
    fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
        &mut self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder
for test_union_defaults::Builder<'a, T> {
    unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
        Self(ptr)
    }
}
impl _p::StructView for TestUnionDefaults {
    type Reader<'a, T: _p::rpc::Table> = test_union_defaults::Reader<'a, T>;
    type Builder<'a, T: _p::rpc::Table> = test_union_defaults::Builder<'a, T>;
}
impl _p::ty::Struct for TestUnionDefaults {
    const SIZE: _p::StructSize = _p::StructSize {
        data: 0u16,
        ptrs: 4u16,
    };
}
impl TestUnionDefaults {
    const S16S8S64S8_SET: _p::Descriptor<_p::Struct<TestUnion>> = _p::Descriptor::<
        _p::Struct<TestUnion>,
    > {
        slot: 0u32,
        default: ::core::option::Option::Some(unsafe {
            _p::StructReader::slice_unchecked(
                &[
                    _p::Word([3u8, 0u8, 3u8, 0u8, 4u8, 0u8, 1u8, 0u8]),
                    _p::Word([65u8, 1u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 123u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 55u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([135u8, 75u8, 107u8, 93u8, 84u8, 220u8, 43u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                ],
                _p::StructSize {
                    data: 8u16,
                    ptrs: 2u16,
                },
            )
        }),
    };
    const S0SPS1S32_SET: _p::Descriptor<_p::Struct<TestUnion>> = _p::Descriptor::<
        _p::Struct<TestUnion>,
    > {
        slot: 1u32,
        default: ::core::option::Option::Some(unsafe {
            _p::StructReader::slice_unchecked(
                &[
                    _p::Word([7u8, 0u8, 11u8, 0u8, 0u8, 0u8, 3u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([1u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 78u8, 97u8, 188u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([1u8, 0u8, 0u8, 0u8, 34u8, 0u8, 0u8, 0u8]),
                    _p::Word([102u8, 111u8, 111u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                ],
                _p::StructSize {
                    data: 8u16,
                    ptrs: 2u16,
                },
            )
        }),
    };
    const UNNAMED1: _p::Descriptor<_p::Struct<TestUnnamedUnion>> = _p::Descriptor::<
        _p::Struct<TestUnnamedUnion>,
    > {
        slot: 2u32,
        default: ::core::option::Option::Some(unsafe {
            _p::StructReader::slice_unchecked(
                &[
                    _p::Word([123u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                ],
                _p::StructSize {
                    data: 2u16,
                    ptrs: 2u16,
                },
            )
        }),
    };
    const UNNAMED2: _p::Descriptor<_p::Struct<TestUnnamedUnion>> = _p::Descriptor::<
        _p::Struct<TestUnnamedUnion>,
    > {
        slot: 3u32,
        default: ::core::option::Option::Some(unsafe {
            _p::StructReader::slice_unchecked(
                &[
                    _p::Word([0u8, 0u8, 0u8, 0u8, 1u8, 0u8, 0u8, 0u8]),
                    _p::Word([65u8, 1u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([5u8, 0u8, 0u8, 0u8, 34u8, 0u8, 0u8, 0u8]),
                    _p::Word([5u8, 0u8, 0u8, 0u8, 34u8, 0u8, 0u8, 0u8]),
                    _p::Word([102u8, 111u8, 111u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([98u8, 97u8, 114u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                ],
                _p::StructSize {
                    data: 2u16,
                    ptrs: 2u16,
                },
            )
        }),
    };
}
impl<'p, T: _p::rpc::Table + 'p> test_union_defaults::Reader<'p, T> {
    #[inline]
    pub fn s16s8s64s8_set(&self) -> _p::Accessor<'_, 'p, T, _p::Struct<TestUnion>> {
        unsafe {
            <_p::Struct<
                TestUnion,
            > as _p::field::FieldType>::accessor(
                &self.0,
                &TestUnionDefaults::S16S8S64S8_SET,
            )
        }
    }
    #[inline]
    pub fn s0sps1s32_set(&self) -> _p::Accessor<'_, 'p, T, _p::Struct<TestUnion>> {
        unsafe {
            <_p::Struct<
                TestUnion,
            > as _p::field::FieldType>::accessor(
                &self.0,
                &TestUnionDefaults::S0SPS1S32_SET,
            )
        }
    }
    #[inline]
    pub fn unnamed1(&self) -> _p::Accessor<'_, 'p, T, _p::Struct<TestUnnamedUnion>> {
        unsafe {
            <_p::Struct<
                TestUnnamedUnion,
            > as _p::field::FieldType>::accessor(&self.0, &TestUnionDefaults::UNNAMED1)
        }
    }
    #[inline]
    pub fn unnamed2(&self) -> _p::Accessor<'_, 'p, T, _p::Struct<TestUnnamedUnion>> {
        unsafe {
            <_p::Struct<
                TestUnnamedUnion,
            > as _p::field::FieldType>::accessor(&self.0, &TestUnionDefaults::UNNAMED2)
        }
    }
}
impl<'p, T: _p::rpc::Table + 'p> test_union_defaults::Builder<'p, T> {
    #[inline]
    pub fn s16s8s64s8_set(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::Struct<TestUnion>> {
        unsafe {
            <_p::Struct<
                TestUnion,
            > as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestUnionDefaults::S16S8S64S8_SET,
            )
        }
    }
    #[inline]
    pub fn s0sps1s32_set(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::Struct<TestUnion>> {
        unsafe {
            <_p::Struct<
                TestUnion,
            > as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestUnionDefaults::S0SPS1S32_SET,
            )
        }
    }
    #[inline]
    pub fn unnamed1(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::Struct<TestUnnamedUnion>> {
        unsafe {
            <_p::Struct<
                TestUnnamedUnion,
            > as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestUnionDefaults::UNNAMED1,
            )
        }
    }
    #[inline]
    pub fn unnamed2(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::Struct<TestUnnamedUnion>> {
        unsafe {
            <_p::Struct<
                TestUnnamedUnion,
            > as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestUnionDefaults::UNNAMED2,
            )
        }
    }
    #[inline]
    pub fn into_s16s8s64s8_set(self) -> _p::AccessorOwned<'p, T, _p::Struct<TestUnion>> {
        unsafe {
            <_p::Struct<
                TestUnion,
            > as _p::field::FieldType>::accessor(
                self.0,
                &TestUnionDefaults::S16S8S64S8_SET,
            )
        }
    }
    #[inline]
    pub fn into_s0sps1s32_set(self) -> _p::AccessorOwned<'p, T, _p::Struct<TestUnion>> {
        unsafe {
            <_p::Struct<
                TestUnion,
            > as _p::field::FieldType>::accessor(
                self.0,
                &TestUnionDefaults::S0SPS1S32_SET,
            )
        }
    }
    #[inline]
    pub fn into_unnamed1(
        self,
    ) -> _p::AccessorOwned<'p, T, _p::Struct<TestUnnamedUnion>> {
        unsafe {
            <_p::Struct<
                TestUnnamedUnion,
            > as _p::field::FieldType>::accessor(self.0, &TestUnionDefaults::UNNAMED1)
        }
    }
    #[inline]
    pub fn into_unnamed2(
        self,
    ) -> _p::AccessorOwned<'p, T, _p::Struct<TestUnnamedUnion>> {
        unsafe {
            <_p::Struct<
                TestUnnamedUnion,
            > as _p::field::FieldType>::accessor(self.0, &TestUnionDefaults::UNNAMED2)
        }
    }
}
pub mod test_union_defaults {
    use super::{__file, __imports, _p};
    pub type Reader<'a, T = _p::rpc::Empty> = super::TestUnionDefaults<
        _p::StructReader<'a, T>,
    >;
    pub type Builder<'a, T = _p::rpc::Empty> = super::TestUnionDefaults<
        _p::StructBuilder<'a, T>,
    >;
}
#[derive(Clone)]
pub struct TestNestedTypes<T = _p::Family>(T);
impl _p::ty::SchemaType for TestNestedTypes {
    const ID: u64 = 15704814498293758925u64;
}
impl<T> _p::IntoFamily for TestNestedTypes<T> {
    type Family = TestNestedTypes;
}
impl<T: _p::Capable> _p::Capable for TestNestedTypes<T> {
    type Table = T::Table;
    type Imbued = T::Imbued;
    type ImbuedWith<T2: _p::rpc::Table> = TestNestedTypes<T::ImbuedWith<T2>>;
    #[inline]
    fn imbued(&self) -> &Self::Imbued {
        self.0.imbued()
    }
    #[inline]
    fn imbue_release<T2: _p::rpc::Table>(
        self,
        new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
    ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
        let (imbued, old) = self.0.imbue_release(new_table);
        (TestNestedTypes(imbued), old)
    }
    #[inline]
    fn imbue_release_into<U>(&self, other: U) -> (U::ImbuedWith<Self::Table>, U::Imbued)
    where
        U: _p::Capable,
        U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
    {
        self.0.imbue_release_into(other)
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_nested_types::Reader<'a, T> {
    type Ptr = _p::StructReader<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
for test_nested_types::Reader<'a, T> {
    #[inline]
    fn from(ptr: _p::StructReader<'a, T>) -> Self {
        TestNestedTypes(ptr)
    }
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_nested_types::Reader<'a, T>>
for _p::StructReader<'a, T> {
    #[inline]
    fn from(reader: test_nested_types::Reader<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
for test_nested_types::Reader<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructReader<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructReader for test_nested_types::Reader<'a, T> {}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_nested_types::Builder<'a, T> {
    type Ptr = _p::StructBuilder<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_nested_types::Builder<'a, T>>
for _p::StructBuilder<'a, T> {
    #[inline]
    fn from(reader: test_nested_types::Builder<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
for test_nested_types::Builder<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
for test_nested_types::Builder<'a, T> {
    #[inline]
    fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
        &mut self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for test_nested_types::Builder<'a, T> {
    unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
        Self(ptr)
    }
}
impl _p::StructView for TestNestedTypes {
    type Reader<'a, T: _p::rpc::Table> = test_nested_types::Reader<'a, T>;
    type Builder<'a, T: _p::rpc::Table> = test_nested_types::Builder<'a, T>;
}
impl _p::ty::Struct for TestNestedTypes {
    const SIZE: _p::StructSize = _p::StructSize {
        data: 1u16,
        ptrs: 1u16,
    };
}
impl TestNestedTypes {
    const NESTED_STRUCT: _p::Descriptor<_p::Struct<test_nested_types::NestedStruct>> = _p::Descriptor::<
        _p::Struct<test_nested_types::NestedStruct>,
    > {
        slot: 0u32,
        default: ::core::option::Option::None,
    };
    const OUTER_NESTED_ENUM: _p::Descriptor<_p::Enum<test_nested_types::NestedEnum>> = _p::Descriptor::<
        _p::Enum<test_nested_types::NestedEnum>,
    > {
        slot: 0u32,
        default: test_nested_types::NestedEnum::Bar,
    };
    const INNER_NESTED_ENUM: _p::Descriptor<
        _p::Enum<test_nested_types::nested_struct::NestedEnum>,
    > = _p::Descriptor::<_p::Enum<test_nested_types::nested_struct::NestedEnum>> {
        slot: 1u32,
        default: test_nested_types::nested_struct::NestedEnum::Quux,
    };
}
impl<'p, T: _p::rpc::Table + 'p> test_nested_types::Reader<'p, T> {
    #[inline]
    pub fn nested_struct(
        &self,
    ) -> _p::Accessor<'_, 'p, T, _p::Struct<test_nested_types::NestedStruct>> {
        unsafe {
            <_p::Struct<
                test_nested_types::NestedStruct,
            > as _p::field::FieldType>::accessor(
                &self.0,
                &TestNestedTypes::NESTED_STRUCT,
            )
        }
    }
    #[inline]
    pub fn outer_nested_enum(
        &self,
    ) -> _p::Accessor<'_, 'p, T, _p::Enum<test_nested_types::NestedEnum>> {
        unsafe {
            <_p::Enum<
                test_nested_types::NestedEnum,
            > as _p::field::FieldType>::accessor(
                &self.0,
                &TestNestedTypes::OUTER_NESTED_ENUM,
            )
        }
    }
    #[inline]
    pub fn inner_nested_enum(
        &self,
    ) -> _p::Accessor<
        '_,
        'p,
        T,
        _p::Enum<test_nested_types::nested_struct::NestedEnum>,
    > {
        unsafe {
            <_p::Enum<
                test_nested_types::nested_struct::NestedEnum,
            > as _p::field::FieldType>::accessor(
                &self.0,
                &TestNestedTypes::INNER_NESTED_ENUM,
            )
        }
    }
}
impl<'p, T: _p::rpc::Table + 'p> test_nested_types::Builder<'p, T> {
    #[inline]
    pub fn nested_struct(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::Struct<test_nested_types::NestedStruct>> {
        unsafe {
            <_p::Struct<
                test_nested_types::NestedStruct,
            > as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestNestedTypes::NESTED_STRUCT,
            )
        }
    }
    #[inline]
    pub fn outer_nested_enum(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::Enum<test_nested_types::NestedEnum>> {
        unsafe {
            <_p::Enum<
                test_nested_types::NestedEnum,
            > as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestNestedTypes::OUTER_NESTED_ENUM,
            )
        }
    }
    #[inline]
    pub fn inner_nested_enum(
        &mut self,
    ) -> _p::AccessorMut<
        '_,
        'p,
        T,
        _p::Enum<test_nested_types::nested_struct::NestedEnum>,
    > {
        unsafe {
            <_p::Enum<
                test_nested_types::nested_struct::NestedEnum,
            > as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestNestedTypes::INNER_NESTED_ENUM,
            )
        }
    }
    #[inline]
    pub fn into_nested_struct(
        self,
    ) -> _p::AccessorOwned<'p, T, _p::Struct<test_nested_types::NestedStruct>> {
        unsafe {
            <_p::Struct<
                test_nested_types::NestedStruct,
            > as _p::field::FieldType>::accessor(self.0, &TestNestedTypes::NESTED_STRUCT)
        }
    }
}
pub mod test_nested_types {
    use super::{__file, __imports, _p};
    pub type Reader<'a, T = _p::rpc::Empty> = super::TestNestedTypes<
        _p::StructReader<'a, T>,
    >;
    pub type Builder<'a, T = _p::rpc::Empty> = super::TestNestedTypes<
        _p::StructBuilder<'a, T>,
    >;
    #[repr(u16)]
    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Default)]
    pub enum NestedEnum {
        #[default]
        Foo,
        Bar,
    }
    impl _p::ty::SchemaType for NestedEnum {
        const ID: u64 = 13137513566248654548u64;
    }
    impl core::convert::TryFrom<u16> for NestedEnum {
        type Error = _p::NotInSchema;
        #[inline]
        fn try_from(value: u16) -> Result<Self, _p::NotInSchema> {
            match value {
                0u16 => Ok(Self::Foo),
                1u16 => Ok(Self::Bar),
                value => Err(_p::NotInSchema(value)),
            }
        }
    }
    impl core::convert::From<NestedEnum> for u16 {
        #[inline]
        fn from(value: NestedEnum) -> Self {
            value as u16
        }
    }
    impl _p::ty::Enum for NestedEnum {}
    #[derive(Clone)]
    pub struct NestedStruct<T = _p::Family>(T);
    impl _p::ty::SchemaType for NestedStruct {
        const ID: u64 = 9425193603353401195u64;
    }
    impl<T> _p::IntoFamily for NestedStruct<T> {
        type Family = NestedStruct;
    }
    impl<T: _p::Capable> _p::Capable for NestedStruct<T> {
        type Table = T::Table;
        type Imbued = T::Imbued;
        type ImbuedWith<T2: _p::rpc::Table> = NestedStruct<T::ImbuedWith<T2>>;
        #[inline]
        fn imbued(&self) -> &Self::Imbued {
            self.0.imbued()
        }
        #[inline]
        fn imbue_release<T2: _p::rpc::Table>(
            self,
            new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
        ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
            let (imbued, old) = self.0.imbue_release(new_table);
            (NestedStruct(imbued), old)
        }
        #[inline]
        fn imbue_release_into<U>(
            &self,
            other: U,
        ) -> (U::ImbuedWith<Self::Table>, U::Imbued)
        where
            U: _p::Capable,
            U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
        {
            self.0.imbue_release_into(other)
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for nested_struct::Reader<'a, T> {
        type Ptr = _p::StructReader<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
    for nested_struct::Reader<'a, T> {
        #[inline]
        fn from(ptr: _p::StructReader<'a, T>) -> Self {
            NestedStruct(ptr)
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<nested_struct::Reader<'a, T>>
    for _p::StructReader<'a, T> {
        #[inline]
        fn from(reader: nested_struct::Reader<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
    for nested_struct::Reader<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructReader<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructReader for nested_struct::Reader<'a, T> {}
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for nested_struct::Builder<'a, T> {
        type Ptr = _p::StructBuilder<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<nested_struct::Builder<'a, T>>
    for _p::StructBuilder<'a, T> {
        #[inline]
        fn from(reader: nested_struct::Builder<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
    for nested_struct::Builder<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
    for nested_struct::Builder<'a, T> {
        #[inline]
        fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
            &mut self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for nested_struct::Builder<'a, T> {
        unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
            Self(ptr)
        }
    }
    impl _p::StructView for NestedStruct {
        type Reader<'a, T: _p::rpc::Table> = nested_struct::Reader<'a, T>;
        type Builder<'a, T: _p::rpc::Table> = nested_struct::Builder<'a, T>;
    }
    impl _p::ty::Struct for NestedStruct {
        const SIZE: _p::StructSize = _p::StructSize {
            data: 1u16,
            ptrs: 0u16,
        };
    }
    impl NestedStruct {
        const OUTER_NESTED_ENUM: _p::Descriptor<_p::Enum<NestedEnum>> = _p::Descriptor::<
            _p::Enum<NestedEnum>,
        > {
            slot: 0u32,
            default: NestedEnum::Bar,
        };
        const INNER_NESTED_ENUM: _p::Descriptor<_p::Enum<nested_struct::NestedEnum>> = _p::Descriptor::<
            _p::Enum<nested_struct::NestedEnum>,
        > {
            slot: 1u32,
            default: nested_struct::NestedEnum::Quux,
        };
    }
    impl<'p, T: _p::rpc::Table + 'p> nested_struct::Reader<'p, T> {
        #[inline]
        pub fn outer_nested_enum(
            &self,
        ) -> _p::Accessor<'_, 'p, T, _p::Enum<NestedEnum>> {
            unsafe {
                <_p::Enum<
                    NestedEnum,
                > as _p::field::FieldType>::accessor(
                    &self.0,
                    &NestedStruct::OUTER_NESTED_ENUM,
                )
            }
        }
        #[inline]
        pub fn inner_nested_enum(
            &self,
        ) -> _p::Accessor<'_, 'p, T, _p::Enum<nested_struct::NestedEnum>> {
            unsafe {
                <_p::Enum<
                    nested_struct::NestedEnum,
                > as _p::field::FieldType>::accessor(
                    &self.0,
                    &NestedStruct::INNER_NESTED_ENUM,
                )
            }
        }
    }
    impl<'p, T: _p::rpc::Table + 'p> nested_struct::Builder<'p, T> {
        #[inline]
        pub fn outer_nested_enum(
            &mut self,
        ) -> _p::AccessorMut<'_, 'p, T, _p::Enum<NestedEnum>> {
            unsafe {
                <_p::Enum<
                    NestedEnum,
                > as _p::field::FieldType>::accessor(
                    &mut self.0,
                    &NestedStruct::OUTER_NESTED_ENUM,
                )
            }
        }
        #[inline]
        pub fn inner_nested_enum(
            &mut self,
        ) -> _p::AccessorMut<'_, 'p, T, _p::Enum<nested_struct::NestedEnum>> {
            unsafe {
                <_p::Enum<
                    nested_struct::NestedEnum,
                > as _p::field::FieldType>::accessor(
                    &mut self.0,
                    &NestedStruct::INNER_NESTED_ENUM,
                )
            }
        }
    }
    pub mod nested_struct {
        use super::{__file, __imports, _p};
        pub type Reader<'a, T = _p::rpc::Empty> = super::NestedStruct<
            _p::StructReader<'a, T>,
        >;
        pub type Builder<'a, T = _p::rpc::Empty> = super::NestedStruct<
            _p::StructBuilder<'a, T>,
        >;
        #[repr(u16)]
        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Default)]
        pub enum NestedEnum {
            #[default]
            Baz,
            Qux,
            Quux,
        }
        impl _p::ty::SchemaType for NestedEnum {
            const ID: u64 = 14961192461319945715u64;
        }
        impl core::convert::TryFrom<u16> for NestedEnum {
            type Error = _p::NotInSchema;
            #[inline]
            fn try_from(value: u16) -> Result<Self, _p::NotInSchema> {
                match value {
                    0u16 => Ok(Self::Baz),
                    1u16 => Ok(Self::Qux),
                    2u16 => Ok(Self::Quux),
                    value => Err(_p::NotInSchema(value)),
                }
            }
        }
        impl core::convert::From<NestedEnum> for u16 {
            #[inline]
            fn from(value: NestedEnum) -> Self {
                value as u16
            }
        }
        impl _p::ty::Enum for NestedEnum {}
    }
}
#[derive(Clone)]
pub struct TestUsing<T = _p::Family>(T);
impl _p::ty::SchemaType for TestUsing {
    const ID: u64 = 16684337128724213861u64;
}
impl<T> _p::IntoFamily for TestUsing<T> {
    type Family = TestUsing;
}
impl<T: _p::Capable> _p::Capable for TestUsing<T> {
    type Table = T::Table;
    type Imbued = T::Imbued;
    type ImbuedWith<T2: _p::rpc::Table> = TestUsing<T::ImbuedWith<T2>>;
    #[inline]
    fn imbued(&self) -> &Self::Imbued {
        self.0.imbued()
    }
    #[inline]
    fn imbue_release<T2: _p::rpc::Table>(
        self,
        new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
    ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
        let (imbued, old) = self.0.imbue_release(new_table);
        (TestUsing(imbued), old)
    }
    #[inline]
    fn imbue_release_into<U>(&self, other: U) -> (U::ImbuedWith<Self::Table>, U::Imbued)
    where
        U: _p::Capable,
        U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
    {
        self.0.imbue_release_into(other)
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_using::Reader<'a, T> {
    type Ptr = _p::StructReader<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
for test_using::Reader<'a, T> {
    #[inline]
    fn from(ptr: _p::StructReader<'a, T>) -> Self {
        TestUsing(ptr)
    }
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_using::Reader<'a, T>>
for _p::StructReader<'a, T> {
    #[inline]
    fn from(reader: test_using::Reader<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
for test_using::Reader<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructReader<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructReader for test_using::Reader<'a, T> {}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_using::Builder<'a, T> {
    type Ptr = _p::StructBuilder<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_using::Builder<'a, T>>
for _p::StructBuilder<'a, T> {
    #[inline]
    fn from(reader: test_using::Builder<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
for test_using::Builder<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
for test_using::Builder<'a, T> {
    #[inline]
    fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
        &mut self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for test_using::Builder<'a, T> {
    unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
        Self(ptr)
    }
}
impl _p::StructView for TestUsing {
    type Reader<'a, T: _p::rpc::Table> = test_using::Reader<'a, T>;
    type Builder<'a, T: _p::rpc::Table> = test_using::Builder<'a, T>;
}
impl _p::ty::Struct for TestUsing {
    const SIZE: _p::StructSize = _p::StructSize {
        data: 1u16,
        ptrs: 0u16,
    };
}
impl TestUsing {
    const INNER_NESTED_ENUM: _p::Descriptor<
        _p::Enum<test_nested_types::nested_struct::NestedEnum>,
    > = _p::Descriptor::<_p::Enum<test_nested_types::nested_struct::NestedEnum>> {
        slot: 0u32,
        default: test_nested_types::nested_struct::NestedEnum::Quux,
    };
    const OUTER_NESTED_ENUM: _p::Descriptor<_p::Enum<test_nested_types::NestedEnum>> = _p::Descriptor::<
        _p::Enum<test_nested_types::NestedEnum>,
    > {
        slot: 1u32,
        default: test_nested_types::NestedEnum::Bar,
    };
}
impl<'p, T: _p::rpc::Table + 'p> test_using::Reader<'p, T> {
    #[inline]
    pub fn inner_nested_enum(
        &self,
    ) -> _p::Accessor<
        '_,
        'p,
        T,
        _p::Enum<test_nested_types::nested_struct::NestedEnum>,
    > {
        unsafe {
            <_p::Enum<
                test_nested_types::nested_struct::NestedEnum,
            > as _p::field::FieldType>::accessor(&self.0, &TestUsing::INNER_NESTED_ENUM)
        }
    }
    #[inline]
    pub fn outer_nested_enum(
        &self,
    ) -> _p::Accessor<'_, 'p, T, _p::Enum<test_nested_types::NestedEnum>> {
        unsafe {
            <_p::Enum<
                test_nested_types::NestedEnum,
            > as _p::field::FieldType>::accessor(&self.0, &TestUsing::OUTER_NESTED_ENUM)
        }
    }
}
impl<'p, T: _p::rpc::Table + 'p> test_using::Builder<'p, T> {
    #[inline]
    pub fn inner_nested_enum(
        &mut self,
    ) -> _p::AccessorMut<
        '_,
        'p,
        T,
        _p::Enum<test_nested_types::nested_struct::NestedEnum>,
    > {
        unsafe {
            <_p::Enum<
                test_nested_types::nested_struct::NestedEnum,
            > as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestUsing::INNER_NESTED_ENUM,
            )
        }
    }
    #[inline]
    pub fn outer_nested_enum(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::Enum<test_nested_types::NestedEnum>> {
        unsafe {
            <_p::Enum<
                test_nested_types::NestedEnum,
            > as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestUsing::OUTER_NESTED_ENUM,
            )
        }
    }
}
pub mod test_using {
    use super::{__file, __imports, _p};
    pub type Reader<'a, T = _p::rpc::Empty> = super::TestUsing<_p::StructReader<'a, T>>;
    pub type Builder<'a, T = _p::rpc::Empty> = super::TestUsing<
        _p::StructBuilder<'a, T>,
    >;
}
#[derive(Clone)]
pub struct TestLists<T = _p::Family>(T);
impl _p::ty::SchemaType for TestLists {
    const ID: u64 = 16436033939557263230u64;
}
impl<T> _p::IntoFamily for TestLists<T> {
    type Family = TestLists;
}
impl<T: _p::Capable> _p::Capable for TestLists<T> {
    type Table = T::Table;
    type Imbued = T::Imbued;
    type ImbuedWith<T2: _p::rpc::Table> = TestLists<T::ImbuedWith<T2>>;
    #[inline]
    fn imbued(&self) -> &Self::Imbued {
        self.0.imbued()
    }
    #[inline]
    fn imbue_release<T2: _p::rpc::Table>(
        self,
        new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
    ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
        let (imbued, old) = self.0.imbue_release(new_table);
        (TestLists(imbued), old)
    }
    #[inline]
    fn imbue_release_into<U>(&self, other: U) -> (U::ImbuedWith<Self::Table>, U::Imbued)
    where
        U: _p::Capable,
        U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
    {
        self.0.imbue_release_into(other)
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_lists::Reader<'a, T> {
    type Ptr = _p::StructReader<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
for test_lists::Reader<'a, T> {
    #[inline]
    fn from(ptr: _p::StructReader<'a, T>) -> Self {
        TestLists(ptr)
    }
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_lists::Reader<'a, T>>
for _p::StructReader<'a, T> {
    #[inline]
    fn from(reader: test_lists::Reader<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
for test_lists::Reader<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructReader<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructReader for test_lists::Reader<'a, T> {}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_lists::Builder<'a, T> {
    type Ptr = _p::StructBuilder<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_lists::Builder<'a, T>>
for _p::StructBuilder<'a, T> {
    #[inline]
    fn from(reader: test_lists::Builder<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
for test_lists::Builder<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
for test_lists::Builder<'a, T> {
    #[inline]
    fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
        &mut self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for test_lists::Builder<'a, T> {
    unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
        Self(ptr)
    }
}
impl _p::StructView for TestLists {
    type Reader<'a, T: _p::rpc::Table> = test_lists::Reader<'a, T>;
    type Builder<'a, T: _p::rpc::Table> = test_lists::Builder<'a, T>;
}
impl _p::ty::Struct for TestLists {
    const SIZE: _p::StructSize = _p::StructSize {
        data: 0u16,
        ptrs: 10u16,
    };
}
impl TestLists {
    const LIST0: _p::Descriptor<_p::List<_p::Struct<test_lists::Struct0>>> = _p::Descriptor::<
        _p::List<_p::Struct<test_lists::Struct0>>,
    > {
        slot: 0u32,
        default: ::core::option::Option::None,
    };
    const LIST1: _p::Descriptor<_p::List<_p::Struct<test_lists::Struct1>>> = _p::Descriptor::<
        _p::List<_p::Struct<test_lists::Struct1>>,
    > {
        slot: 1u32,
        default: ::core::option::Option::None,
    };
    const LIST8: _p::Descriptor<_p::List<_p::Struct<test_lists::Struct8>>> = _p::Descriptor::<
        _p::List<_p::Struct<test_lists::Struct8>>,
    > {
        slot: 2u32,
        default: ::core::option::Option::None,
    };
    const LIST16: _p::Descriptor<_p::List<_p::Struct<test_lists::Struct16>>> = _p::Descriptor::<
        _p::List<_p::Struct<test_lists::Struct16>>,
    > {
        slot: 3u32,
        default: ::core::option::Option::None,
    };
    const LIST32: _p::Descriptor<_p::List<_p::Struct<test_lists::Struct32>>> = _p::Descriptor::<
        _p::List<_p::Struct<test_lists::Struct32>>,
    > {
        slot: 4u32,
        default: ::core::option::Option::None,
    };
    const LIST64: _p::Descriptor<_p::List<_p::Struct<test_lists::Struct64>>> = _p::Descriptor::<
        _p::List<_p::Struct<test_lists::Struct64>>,
    > {
        slot: 5u32,
        default: ::core::option::Option::None,
    };
    const LIST_P: _p::Descriptor<_p::List<_p::Struct<test_lists::StructP>>> = _p::Descriptor::<
        _p::List<_p::Struct<test_lists::StructP>>,
    > {
        slot: 6u32,
        default: ::core::option::Option::None,
    };
    const INT32_LIST_LIST: _p::Descriptor<_p::List<_p::List<i32>>> = _p::Descriptor::<
        _p::List<_p::List<i32>>,
    > {
        slot: 7u32,
        default: ::core::option::Option::None,
    };
    const TEXT_LIST_LIST: _p::Descriptor<_p::List<_p::List<_p::Text>>> = _p::Descriptor::<
        _p::List<_p::List<_p::Text>>,
    > {
        slot: 8u32,
        default: ::core::option::Option::None,
    };
    const STRUCT_LIST_LIST: _p::Descriptor<
        _p::List<_p::List<_p::Struct<TestAllTypes>>>,
    > = _p::Descriptor::<_p::List<_p::List<_p::Struct<TestAllTypes>>>> {
        slot: 9u32,
        default: ::core::option::Option::None,
    };
}
impl<'p, T: _p::rpc::Table + 'p> test_lists::Reader<'p, T> {
    #[inline]
    pub fn list0(
        &self,
    ) -> _p::Accessor<'_, 'p, T, _p::List<_p::Struct<test_lists::Struct0>>> {
        unsafe {
            <_p::List<
                _p::Struct<test_lists::Struct0>,
            > as _p::field::FieldType>::accessor(&self.0, &TestLists::LIST0)
        }
    }
    #[inline]
    pub fn list1(
        &self,
    ) -> _p::Accessor<'_, 'p, T, _p::List<_p::Struct<test_lists::Struct1>>> {
        unsafe {
            <_p::List<
                _p::Struct<test_lists::Struct1>,
            > as _p::field::FieldType>::accessor(&self.0, &TestLists::LIST1)
        }
    }
    #[inline]
    pub fn list8(
        &self,
    ) -> _p::Accessor<'_, 'p, T, _p::List<_p::Struct<test_lists::Struct8>>> {
        unsafe {
            <_p::List<
                _p::Struct<test_lists::Struct8>,
            > as _p::field::FieldType>::accessor(&self.0, &TestLists::LIST8)
        }
    }
    #[inline]
    pub fn list16(
        &self,
    ) -> _p::Accessor<'_, 'p, T, _p::List<_p::Struct<test_lists::Struct16>>> {
        unsafe {
            <_p::List<
                _p::Struct<test_lists::Struct16>,
            > as _p::field::FieldType>::accessor(&self.0, &TestLists::LIST16)
        }
    }
    #[inline]
    pub fn list32(
        &self,
    ) -> _p::Accessor<'_, 'p, T, _p::List<_p::Struct<test_lists::Struct32>>> {
        unsafe {
            <_p::List<
                _p::Struct<test_lists::Struct32>,
            > as _p::field::FieldType>::accessor(&self.0, &TestLists::LIST32)
        }
    }
    #[inline]
    pub fn list64(
        &self,
    ) -> _p::Accessor<'_, 'p, T, _p::List<_p::Struct<test_lists::Struct64>>> {
        unsafe {
            <_p::List<
                _p::Struct<test_lists::Struct64>,
            > as _p::field::FieldType>::accessor(&self.0, &TestLists::LIST64)
        }
    }
    #[inline]
    pub fn list_p(
        &self,
    ) -> _p::Accessor<'_, 'p, T, _p::List<_p::Struct<test_lists::StructP>>> {
        unsafe {
            <_p::List<
                _p::Struct<test_lists::StructP>,
            > as _p::field::FieldType>::accessor(&self.0, &TestLists::LIST_P)
        }
    }
    #[inline]
    pub fn int32_list_list(&self) -> _p::Accessor<'_, 'p, T, _p::List<_p::List<i32>>> {
        unsafe {
            <_p::List<
                _p::List<i32>,
            > as _p::field::FieldType>::accessor(&self.0, &TestLists::INT32_LIST_LIST)
        }
    }
    #[inline]
    pub fn text_list_list(
        &self,
    ) -> _p::Accessor<'_, 'p, T, _p::List<_p::List<_p::Text>>> {
        unsafe {
            <_p::List<
                _p::List<_p::Text>,
            > as _p::field::FieldType>::accessor(&self.0, &TestLists::TEXT_LIST_LIST)
        }
    }
    #[inline]
    pub fn struct_list_list(
        &self,
    ) -> _p::Accessor<'_, 'p, T, _p::List<_p::List<_p::Struct<TestAllTypes>>>> {
        unsafe {
            <_p::List<
                _p::List<_p::Struct<TestAllTypes>>,
            > as _p::field::FieldType>::accessor(&self.0, &TestLists::STRUCT_LIST_LIST)
        }
    }
}
impl<'p, T: _p::rpc::Table + 'p> test_lists::Builder<'p, T> {
    #[inline]
    pub fn list0(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::List<_p::Struct<test_lists::Struct0>>> {
        unsafe {
            <_p::List<
                _p::Struct<test_lists::Struct0>,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestLists::LIST0)
        }
    }
    #[inline]
    pub fn list1(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::List<_p::Struct<test_lists::Struct1>>> {
        unsafe {
            <_p::List<
                _p::Struct<test_lists::Struct1>,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestLists::LIST1)
        }
    }
    #[inline]
    pub fn list8(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::List<_p::Struct<test_lists::Struct8>>> {
        unsafe {
            <_p::List<
                _p::Struct<test_lists::Struct8>,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestLists::LIST8)
        }
    }
    #[inline]
    pub fn list16(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::List<_p::Struct<test_lists::Struct16>>> {
        unsafe {
            <_p::List<
                _p::Struct<test_lists::Struct16>,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestLists::LIST16)
        }
    }
    #[inline]
    pub fn list32(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::List<_p::Struct<test_lists::Struct32>>> {
        unsafe {
            <_p::List<
                _p::Struct<test_lists::Struct32>,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestLists::LIST32)
        }
    }
    #[inline]
    pub fn list64(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::List<_p::Struct<test_lists::Struct64>>> {
        unsafe {
            <_p::List<
                _p::Struct<test_lists::Struct64>,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestLists::LIST64)
        }
    }
    #[inline]
    pub fn list_p(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::List<_p::Struct<test_lists::StructP>>> {
        unsafe {
            <_p::List<
                _p::Struct<test_lists::StructP>,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestLists::LIST_P)
        }
    }
    #[inline]
    pub fn int32_list_list(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::List<_p::List<i32>>> {
        unsafe {
            <_p::List<
                _p::List<i32>,
            > as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestLists::INT32_LIST_LIST,
            )
        }
    }
    #[inline]
    pub fn text_list_list(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::List<_p::List<_p::Text>>> {
        unsafe {
            <_p::List<
                _p::List<_p::Text>,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestLists::TEXT_LIST_LIST)
        }
    }
    #[inline]
    pub fn struct_list_list(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::List<_p::List<_p::Struct<TestAllTypes>>>> {
        unsafe {
            <_p::List<
                _p::List<_p::Struct<TestAllTypes>>,
            > as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestLists::STRUCT_LIST_LIST,
            )
        }
    }
    #[inline]
    pub fn into_list0(
        self,
    ) -> _p::AccessorOwned<'p, T, _p::List<_p::Struct<test_lists::Struct0>>> {
        unsafe {
            <_p::List<
                _p::Struct<test_lists::Struct0>,
            > as _p::field::FieldType>::accessor(self.0, &TestLists::LIST0)
        }
    }
    #[inline]
    pub fn into_list1(
        self,
    ) -> _p::AccessorOwned<'p, T, _p::List<_p::Struct<test_lists::Struct1>>> {
        unsafe {
            <_p::List<
                _p::Struct<test_lists::Struct1>,
            > as _p::field::FieldType>::accessor(self.0, &TestLists::LIST1)
        }
    }
    #[inline]
    pub fn into_list8(
        self,
    ) -> _p::AccessorOwned<'p, T, _p::List<_p::Struct<test_lists::Struct8>>> {
        unsafe {
            <_p::List<
                _p::Struct<test_lists::Struct8>,
            > as _p::field::FieldType>::accessor(self.0, &TestLists::LIST8)
        }
    }
    #[inline]
    pub fn into_list16(
        self,
    ) -> _p::AccessorOwned<'p, T, _p::List<_p::Struct<test_lists::Struct16>>> {
        unsafe {
            <_p::List<
                _p::Struct<test_lists::Struct16>,
            > as _p::field::FieldType>::accessor(self.0, &TestLists::LIST16)
        }
    }
    #[inline]
    pub fn into_list32(
        self,
    ) -> _p::AccessorOwned<'p, T, _p::List<_p::Struct<test_lists::Struct32>>> {
        unsafe {
            <_p::List<
                _p::Struct<test_lists::Struct32>,
            > as _p::field::FieldType>::accessor(self.0, &TestLists::LIST32)
        }
    }
    #[inline]
    pub fn into_list64(
        self,
    ) -> _p::AccessorOwned<'p, T, _p::List<_p::Struct<test_lists::Struct64>>> {
        unsafe {
            <_p::List<
                _p::Struct<test_lists::Struct64>,
            > as _p::field::FieldType>::accessor(self.0, &TestLists::LIST64)
        }
    }
    #[inline]
    pub fn into_list_p(
        self,
    ) -> _p::AccessorOwned<'p, T, _p::List<_p::Struct<test_lists::StructP>>> {
        unsafe {
            <_p::List<
                _p::Struct<test_lists::StructP>,
            > as _p::field::FieldType>::accessor(self.0, &TestLists::LIST_P)
        }
    }
    #[inline]
    pub fn into_int32_list_list(
        self,
    ) -> _p::AccessorOwned<'p, T, _p::List<_p::List<i32>>> {
        unsafe {
            <_p::List<
                _p::List<i32>,
            > as _p::field::FieldType>::accessor(self.0, &TestLists::INT32_LIST_LIST)
        }
    }
    #[inline]
    pub fn into_text_list_list(
        self,
    ) -> _p::AccessorOwned<'p, T, _p::List<_p::List<_p::Text>>> {
        unsafe {
            <_p::List<
                _p::List<_p::Text>,
            > as _p::field::FieldType>::accessor(self.0, &TestLists::TEXT_LIST_LIST)
        }
    }
    #[inline]
    pub fn into_struct_list_list(
        self,
    ) -> _p::AccessorOwned<'p, T, _p::List<_p::List<_p::Struct<TestAllTypes>>>> {
        unsafe {
            <_p::List<
                _p::List<_p::Struct<TestAllTypes>>,
            > as _p::field::FieldType>::accessor(self.0, &TestLists::STRUCT_LIST_LIST)
        }
    }
}
pub mod test_lists {
    use super::{__file, __imports, _p};
    pub type Reader<'a, T = _p::rpc::Empty> = super::TestLists<_p::StructReader<'a, T>>;
    pub type Builder<'a, T = _p::rpc::Empty> = super::TestLists<
        _p::StructBuilder<'a, T>,
    >;
    #[derive(Clone)]
    pub struct Struct0<T = _p::Family>(T);
    impl _p::ty::SchemaType for Struct0 {
        const ID: u64 = 9516880324197535726u64;
    }
    impl<T> _p::IntoFamily for Struct0<T> {
        type Family = Struct0;
    }
    impl<T: _p::Capable> _p::Capable for Struct0<T> {
        type Table = T::Table;
        type Imbued = T::Imbued;
        type ImbuedWith<T2: _p::rpc::Table> = Struct0<T::ImbuedWith<T2>>;
        #[inline]
        fn imbued(&self) -> &Self::Imbued {
            self.0.imbued()
        }
        #[inline]
        fn imbue_release<T2: _p::rpc::Table>(
            self,
            new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
        ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
            let (imbued, old) = self.0.imbue_release(new_table);
            (Struct0(imbued), old)
        }
        #[inline]
        fn imbue_release_into<U>(
            &self,
            other: U,
        ) -> (U::ImbuedWith<Self::Table>, U::Imbued)
        where
            U: _p::Capable,
            U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
        {
            self.0.imbue_release_into(other)
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for struct0::Reader<'a, T> {
        type Ptr = _p::StructReader<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
    for struct0::Reader<'a, T> {
        #[inline]
        fn from(ptr: _p::StructReader<'a, T>) -> Self {
            Struct0(ptr)
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<struct0::Reader<'a, T>>
    for _p::StructReader<'a, T> {
        #[inline]
        fn from(reader: struct0::Reader<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
    for struct0::Reader<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructReader<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructReader for struct0::Reader<'a, T> {}
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for struct0::Builder<'a, T> {
        type Ptr = _p::StructBuilder<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<struct0::Builder<'a, T>>
    for _p::StructBuilder<'a, T> {
        #[inline]
        fn from(reader: struct0::Builder<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
    for struct0::Builder<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
    for struct0::Builder<'a, T> {
        #[inline]
        fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
            &mut self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for struct0::Builder<'a, T> {
        unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
            Self(ptr)
        }
    }
    impl _p::StructView for Struct0 {
        type Reader<'a, T: _p::rpc::Table> = struct0::Reader<'a, T>;
        type Builder<'a, T: _p::rpc::Table> = struct0::Builder<'a, T>;
    }
    impl _p::ty::Struct for Struct0 {
        const SIZE: _p::StructSize = _p::StructSize {
            data: 0u16,
            ptrs: 0u16,
        };
    }
    impl Struct0 {
        const F: _p::Descriptor<()> = ();
    }
    impl<'p, T: _p::rpc::Table + 'p> struct0::Reader<'p, T> {
        #[inline]
        pub fn f(&self) -> _p::Accessor<'_, 'p, T, ()> {
            unsafe { <() as _p::field::FieldType>::accessor(&self.0, &Struct0::F) }
        }
    }
    impl<'p, T: _p::rpc::Table + 'p> struct0::Builder<'p, T> {
        #[inline]
        pub fn f(&mut self) -> _p::AccessorMut<'_, 'p, T, ()> {
            unsafe { <() as _p::field::FieldType>::accessor(&mut self.0, &Struct0::F) }
        }
    }
    pub mod struct0 {
        use super::{__file, __imports, _p};
        pub type Reader<'a, T = _p::rpc::Empty> = super::Struct0<
            _p::StructReader<'a, T>,
        >;
        pub type Builder<'a, T = _p::rpc::Empty> = super::Struct0<
            _p::StructBuilder<'a, T>,
        >;
    }
    #[derive(Clone)]
    pub struct Struct1<T = _p::Family>(T);
    impl _p::ty::SchemaType for Struct1 {
        const ID: u64 = 16212492949613817193u64;
    }
    impl<T> _p::IntoFamily for Struct1<T> {
        type Family = Struct1;
    }
    impl<T: _p::Capable> _p::Capable for Struct1<T> {
        type Table = T::Table;
        type Imbued = T::Imbued;
        type ImbuedWith<T2: _p::rpc::Table> = Struct1<T::ImbuedWith<T2>>;
        #[inline]
        fn imbued(&self) -> &Self::Imbued {
            self.0.imbued()
        }
        #[inline]
        fn imbue_release<T2: _p::rpc::Table>(
            self,
            new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
        ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
            let (imbued, old) = self.0.imbue_release(new_table);
            (Struct1(imbued), old)
        }
        #[inline]
        fn imbue_release_into<U>(
            &self,
            other: U,
        ) -> (U::ImbuedWith<Self::Table>, U::Imbued)
        where
            U: _p::Capable,
            U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
        {
            self.0.imbue_release_into(other)
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for struct1::Reader<'a, T> {
        type Ptr = _p::StructReader<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
    for struct1::Reader<'a, T> {
        #[inline]
        fn from(ptr: _p::StructReader<'a, T>) -> Self {
            Struct1(ptr)
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<struct1::Reader<'a, T>>
    for _p::StructReader<'a, T> {
        #[inline]
        fn from(reader: struct1::Reader<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
    for struct1::Reader<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructReader<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructReader for struct1::Reader<'a, T> {}
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for struct1::Builder<'a, T> {
        type Ptr = _p::StructBuilder<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<struct1::Builder<'a, T>>
    for _p::StructBuilder<'a, T> {
        #[inline]
        fn from(reader: struct1::Builder<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
    for struct1::Builder<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
    for struct1::Builder<'a, T> {
        #[inline]
        fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
            &mut self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for struct1::Builder<'a, T> {
        unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
            Self(ptr)
        }
    }
    impl _p::StructView for Struct1 {
        type Reader<'a, T: _p::rpc::Table> = struct1::Reader<'a, T>;
        type Builder<'a, T: _p::rpc::Table> = struct1::Builder<'a, T>;
    }
    impl _p::ty::Struct for Struct1 {
        const SIZE: _p::StructSize = _p::StructSize {
            data: 1u16,
            ptrs: 0u16,
        };
    }
    impl Struct1 {
        const F: _p::Descriptor<bool> = _p::Descriptor::<bool> {
            slot: 0u32,
            default: false,
        };
    }
    impl<'p, T: _p::rpc::Table + 'p> struct1::Reader<'p, T> {
        #[inline]
        pub fn f(&self) -> _p::Accessor<'_, 'p, T, bool> {
            unsafe { <bool as _p::field::FieldType>::accessor(&self.0, &Struct1::F) }
        }
    }
    impl<'p, T: _p::rpc::Table + 'p> struct1::Builder<'p, T> {
        #[inline]
        pub fn f(&mut self) -> _p::AccessorMut<'_, 'p, T, bool> {
            unsafe { <bool as _p::field::FieldType>::accessor(&mut self.0, &Struct1::F) }
        }
    }
    pub mod struct1 {
        use super::{__file, __imports, _p};
        pub type Reader<'a, T = _p::rpc::Empty> = super::Struct1<
            _p::StructReader<'a, T>,
        >;
        pub type Builder<'a, T = _p::rpc::Empty> = super::Struct1<
            _p::StructBuilder<'a, T>,
        >;
    }
    #[derive(Clone)]
    pub struct Struct8<T = _p::Family>(T);
    impl _p::ty::SchemaType for Struct8 {
        const ID: u64 = 11979885299532567643u64;
    }
    impl<T> _p::IntoFamily for Struct8<T> {
        type Family = Struct8;
    }
    impl<T: _p::Capable> _p::Capable for Struct8<T> {
        type Table = T::Table;
        type Imbued = T::Imbued;
        type ImbuedWith<T2: _p::rpc::Table> = Struct8<T::ImbuedWith<T2>>;
        #[inline]
        fn imbued(&self) -> &Self::Imbued {
            self.0.imbued()
        }
        #[inline]
        fn imbue_release<T2: _p::rpc::Table>(
            self,
            new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
        ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
            let (imbued, old) = self.0.imbue_release(new_table);
            (Struct8(imbued), old)
        }
        #[inline]
        fn imbue_release_into<U>(
            &self,
            other: U,
        ) -> (U::ImbuedWith<Self::Table>, U::Imbued)
        where
            U: _p::Capable,
            U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
        {
            self.0.imbue_release_into(other)
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for struct8::Reader<'a, T> {
        type Ptr = _p::StructReader<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
    for struct8::Reader<'a, T> {
        #[inline]
        fn from(ptr: _p::StructReader<'a, T>) -> Self {
            Struct8(ptr)
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<struct8::Reader<'a, T>>
    for _p::StructReader<'a, T> {
        #[inline]
        fn from(reader: struct8::Reader<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
    for struct8::Reader<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructReader<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructReader for struct8::Reader<'a, T> {}
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for struct8::Builder<'a, T> {
        type Ptr = _p::StructBuilder<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<struct8::Builder<'a, T>>
    for _p::StructBuilder<'a, T> {
        #[inline]
        fn from(reader: struct8::Builder<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
    for struct8::Builder<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
    for struct8::Builder<'a, T> {
        #[inline]
        fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
            &mut self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for struct8::Builder<'a, T> {
        unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
            Self(ptr)
        }
    }
    impl _p::StructView for Struct8 {
        type Reader<'a, T: _p::rpc::Table> = struct8::Reader<'a, T>;
        type Builder<'a, T: _p::rpc::Table> = struct8::Builder<'a, T>;
    }
    impl _p::ty::Struct for Struct8 {
        const SIZE: _p::StructSize = _p::StructSize {
            data: 1u16,
            ptrs: 0u16,
        };
    }
    impl Struct8 {
        const F: _p::Descriptor<u8> = _p::Descriptor::<u8> {
            slot: 0u32,
            default: 0u8,
        };
    }
    impl<'p, T: _p::rpc::Table + 'p> struct8::Reader<'p, T> {
        #[inline]
        pub fn f(&self) -> _p::Accessor<'_, 'p, T, u8> {
            unsafe { <u8 as _p::field::FieldType>::accessor(&self.0, &Struct8::F) }
        }
    }
    impl<'p, T: _p::rpc::Table + 'p> struct8::Builder<'p, T> {
        #[inline]
        pub fn f(&mut self) -> _p::AccessorMut<'_, 'p, T, u8> {
            unsafe { <u8 as _p::field::FieldType>::accessor(&mut self.0, &Struct8::F) }
        }
    }
    pub mod struct8 {
        use super::{__file, __imports, _p};
        pub type Reader<'a, T = _p::rpc::Empty> = super::Struct8<
            _p::StructReader<'a, T>,
        >;
        pub type Builder<'a, T = _p::rpc::Empty> = super::Struct8<
            _p::StructBuilder<'a, T>,
        >;
    }
    #[derive(Clone)]
    pub struct Struct16<T = _p::Family>(T);
    impl _p::ty::SchemaType for Struct16 {
        const ID: u64 = 12154080321006508140u64;
    }
    impl<T> _p::IntoFamily for Struct16<T> {
        type Family = Struct16;
    }
    impl<T: _p::Capable> _p::Capable for Struct16<T> {
        type Table = T::Table;
        type Imbued = T::Imbued;
        type ImbuedWith<T2: _p::rpc::Table> = Struct16<T::ImbuedWith<T2>>;
        #[inline]
        fn imbued(&self) -> &Self::Imbued {
            self.0.imbued()
        }
        #[inline]
        fn imbue_release<T2: _p::rpc::Table>(
            self,
            new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
        ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
            let (imbued, old) = self.0.imbue_release(new_table);
            (Struct16(imbued), old)
        }
        #[inline]
        fn imbue_release_into<U>(
            &self,
            other: U,
        ) -> (U::ImbuedWith<Self::Table>, U::Imbued)
        where
            U: _p::Capable,
            U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
        {
            self.0.imbue_release_into(other)
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for struct16::Reader<'a, T> {
        type Ptr = _p::StructReader<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
    for struct16::Reader<'a, T> {
        #[inline]
        fn from(ptr: _p::StructReader<'a, T>) -> Self {
            Struct16(ptr)
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<struct16::Reader<'a, T>>
    for _p::StructReader<'a, T> {
        #[inline]
        fn from(reader: struct16::Reader<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
    for struct16::Reader<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructReader<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructReader for struct16::Reader<'a, T> {}
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for struct16::Builder<'a, T> {
        type Ptr = _p::StructBuilder<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<struct16::Builder<'a, T>>
    for _p::StructBuilder<'a, T> {
        #[inline]
        fn from(reader: struct16::Builder<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
    for struct16::Builder<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
    for struct16::Builder<'a, T> {
        #[inline]
        fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
            &mut self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for struct16::Builder<'a, T> {
        unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
            Self(ptr)
        }
    }
    impl _p::StructView for Struct16 {
        type Reader<'a, T: _p::rpc::Table> = struct16::Reader<'a, T>;
        type Builder<'a, T: _p::rpc::Table> = struct16::Builder<'a, T>;
    }
    impl _p::ty::Struct for Struct16 {
        const SIZE: _p::StructSize = _p::StructSize {
            data: 1u16,
            ptrs: 0u16,
        };
    }
    impl Struct16 {
        const F: _p::Descriptor<u16> = _p::Descriptor::<u16> {
            slot: 0u32,
            default: 0u16,
        };
    }
    impl<'p, T: _p::rpc::Table + 'p> struct16::Reader<'p, T> {
        #[inline]
        pub fn f(&self) -> _p::Accessor<'_, 'p, T, u16> {
            unsafe { <u16 as _p::field::FieldType>::accessor(&self.0, &Struct16::F) }
        }
    }
    impl<'p, T: _p::rpc::Table + 'p> struct16::Builder<'p, T> {
        #[inline]
        pub fn f(&mut self) -> _p::AccessorMut<'_, 'p, T, u16> {
            unsafe { <u16 as _p::field::FieldType>::accessor(&mut self.0, &Struct16::F) }
        }
    }
    pub mod struct16 {
        use super::{__file, __imports, _p};
        pub type Reader<'a, T = _p::rpc::Empty> = super::Struct16<
            _p::StructReader<'a, T>,
        >;
        pub type Builder<'a, T = _p::rpc::Empty> = super::Struct16<
            _p::StructBuilder<'a, T>,
        >;
    }
    #[derive(Clone)]
    pub struct Struct32<T = _p::Family>(T);
    impl _p::ty::SchemaType for Struct32 {
        const ID: u64 = 12500847820679612226u64;
    }
    impl<T> _p::IntoFamily for Struct32<T> {
        type Family = Struct32;
    }
    impl<T: _p::Capable> _p::Capable for Struct32<T> {
        type Table = T::Table;
        type Imbued = T::Imbued;
        type ImbuedWith<T2: _p::rpc::Table> = Struct32<T::ImbuedWith<T2>>;
        #[inline]
        fn imbued(&self) -> &Self::Imbued {
            self.0.imbued()
        }
        #[inline]
        fn imbue_release<T2: _p::rpc::Table>(
            self,
            new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
        ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
            let (imbued, old) = self.0.imbue_release(new_table);
            (Struct32(imbued), old)
        }
        #[inline]
        fn imbue_release_into<U>(
            &self,
            other: U,
        ) -> (U::ImbuedWith<Self::Table>, U::Imbued)
        where
            U: _p::Capable,
            U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
        {
            self.0.imbue_release_into(other)
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for struct32::Reader<'a, T> {
        type Ptr = _p::StructReader<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
    for struct32::Reader<'a, T> {
        #[inline]
        fn from(ptr: _p::StructReader<'a, T>) -> Self {
            Struct32(ptr)
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<struct32::Reader<'a, T>>
    for _p::StructReader<'a, T> {
        #[inline]
        fn from(reader: struct32::Reader<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
    for struct32::Reader<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructReader<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructReader for struct32::Reader<'a, T> {}
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for struct32::Builder<'a, T> {
        type Ptr = _p::StructBuilder<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<struct32::Builder<'a, T>>
    for _p::StructBuilder<'a, T> {
        #[inline]
        fn from(reader: struct32::Builder<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
    for struct32::Builder<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
    for struct32::Builder<'a, T> {
        #[inline]
        fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
            &mut self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for struct32::Builder<'a, T> {
        unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
            Self(ptr)
        }
    }
    impl _p::StructView for Struct32 {
        type Reader<'a, T: _p::rpc::Table> = struct32::Reader<'a, T>;
        type Builder<'a, T: _p::rpc::Table> = struct32::Builder<'a, T>;
    }
    impl _p::ty::Struct for Struct32 {
        const SIZE: _p::StructSize = _p::StructSize {
            data: 1u16,
            ptrs: 0u16,
        };
    }
    impl Struct32 {
        const F: _p::Descriptor<u32> = _p::Descriptor::<u32> {
            slot: 0u32,
            default: 0u32,
        };
    }
    impl<'p, T: _p::rpc::Table + 'p> struct32::Reader<'p, T> {
        #[inline]
        pub fn f(&self) -> _p::Accessor<'_, 'p, T, u32> {
            unsafe { <u32 as _p::field::FieldType>::accessor(&self.0, &Struct32::F) }
        }
    }
    impl<'p, T: _p::rpc::Table + 'p> struct32::Builder<'p, T> {
        #[inline]
        pub fn f(&mut self) -> _p::AccessorMut<'_, 'p, T, u32> {
            unsafe { <u32 as _p::field::FieldType>::accessor(&mut self.0, &Struct32::F) }
        }
    }
    pub mod struct32 {
        use super::{__file, __imports, _p};
        pub type Reader<'a, T = _p::rpc::Empty> = super::Struct32<
            _p::StructReader<'a, T>,
        >;
        pub type Builder<'a, T = _p::rpc::Empty> = super::Struct32<
            _p::StructBuilder<'a, T>,
        >;
    }
    #[derive(Clone)]
    pub struct Struct64<T = _p::Family>(T);
    impl _p::ty::SchemaType for Struct64 {
        const ID: u64 = 17265170339751315014u64;
    }
    impl<T> _p::IntoFamily for Struct64<T> {
        type Family = Struct64;
    }
    impl<T: _p::Capable> _p::Capable for Struct64<T> {
        type Table = T::Table;
        type Imbued = T::Imbued;
        type ImbuedWith<T2: _p::rpc::Table> = Struct64<T::ImbuedWith<T2>>;
        #[inline]
        fn imbued(&self) -> &Self::Imbued {
            self.0.imbued()
        }
        #[inline]
        fn imbue_release<T2: _p::rpc::Table>(
            self,
            new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
        ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
            let (imbued, old) = self.0.imbue_release(new_table);
            (Struct64(imbued), old)
        }
        #[inline]
        fn imbue_release_into<U>(
            &self,
            other: U,
        ) -> (U::ImbuedWith<Self::Table>, U::Imbued)
        where
            U: _p::Capable,
            U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
        {
            self.0.imbue_release_into(other)
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for struct64::Reader<'a, T> {
        type Ptr = _p::StructReader<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
    for struct64::Reader<'a, T> {
        #[inline]
        fn from(ptr: _p::StructReader<'a, T>) -> Self {
            Struct64(ptr)
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<struct64::Reader<'a, T>>
    for _p::StructReader<'a, T> {
        #[inline]
        fn from(reader: struct64::Reader<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
    for struct64::Reader<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructReader<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructReader for struct64::Reader<'a, T> {}
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for struct64::Builder<'a, T> {
        type Ptr = _p::StructBuilder<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<struct64::Builder<'a, T>>
    for _p::StructBuilder<'a, T> {
        #[inline]
        fn from(reader: struct64::Builder<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
    for struct64::Builder<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
    for struct64::Builder<'a, T> {
        #[inline]
        fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
            &mut self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for struct64::Builder<'a, T> {
        unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
            Self(ptr)
        }
    }
    impl _p::StructView for Struct64 {
        type Reader<'a, T: _p::rpc::Table> = struct64::Reader<'a, T>;
        type Builder<'a, T: _p::rpc::Table> = struct64::Builder<'a, T>;
    }
    impl _p::ty::Struct for Struct64 {
        const SIZE: _p::StructSize = _p::StructSize {
            data: 1u16,
            ptrs: 0u16,
        };
    }
    impl Struct64 {
        const F: _p::Descriptor<u64> = _p::Descriptor::<u64> {
            slot: 0u32,
            default: 0u64,
        };
    }
    impl<'p, T: _p::rpc::Table + 'p> struct64::Reader<'p, T> {
        #[inline]
        pub fn f(&self) -> _p::Accessor<'_, 'p, T, u64> {
            unsafe { <u64 as _p::field::FieldType>::accessor(&self.0, &Struct64::F) }
        }
    }
    impl<'p, T: _p::rpc::Table + 'p> struct64::Builder<'p, T> {
        #[inline]
        pub fn f(&mut self) -> _p::AccessorMut<'_, 'p, T, u64> {
            unsafe { <u64 as _p::field::FieldType>::accessor(&mut self.0, &Struct64::F) }
        }
    }
    pub mod struct64 {
        use super::{__file, __imports, _p};
        pub type Reader<'a, T = _p::rpc::Empty> = super::Struct64<
            _p::StructReader<'a, T>,
        >;
        pub type Builder<'a, T = _p::rpc::Empty> = super::Struct64<
            _p::StructBuilder<'a, T>,
        >;
    }
    #[derive(Clone)]
    pub struct StructP<T = _p::Family>(T);
    impl _p::ty::SchemaType for StructP {
        const ID: u64 = 14315801579593032231u64;
    }
    impl<T> _p::IntoFamily for StructP<T> {
        type Family = StructP;
    }
    impl<T: _p::Capable> _p::Capable for StructP<T> {
        type Table = T::Table;
        type Imbued = T::Imbued;
        type ImbuedWith<T2: _p::rpc::Table> = StructP<T::ImbuedWith<T2>>;
        #[inline]
        fn imbued(&self) -> &Self::Imbued {
            self.0.imbued()
        }
        #[inline]
        fn imbue_release<T2: _p::rpc::Table>(
            self,
            new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
        ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
            let (imbued, old) = self.0.imbue_release(new_table);
            (StructP(imbued), old)
        }
        #[inline]
        fn imbue_release_into<U>(
            &self,
            other: U,
        ) -> (U::ImbuedWith<Self::Table>, U::Imbued)
        where
            U: _p::Capable,
            U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
        {
            self.0.imbue_release_into(other)
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for struct_p::Reader<'a, T> {
        type Ptr = _p::StructReader<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
    for struct_p::Reader<'a, T> {
        #[inline]
        fn from(ptr: _p::StructReader<'a, T>) -> Self {
            StructP(ptr)
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<struct_p::Reader<'a, T>>
    for _p::StructReader<'a, T> {
        #[inline]
        fn from(reader: struct_p::Reader<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
    for struct_p::Reader<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructReader<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructReader for struct_p::Reader<'a, T> {}
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for struct_p::Builder<'a, T> {
        type Ptr = _p::StructBuilder<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<struct_p::Builder<'a, T>>
    for _p::StructBuilder<'a, T> {
        #[inline]
        fn from(reader: struct_p::Builder<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
    for struct_p::Builder<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
    for struct_p::Builder<'a, T> {
        #[inline]
        fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
            &mut self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for struct_p::Builder<'a, T> {
        unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
            Self(ptr)
        }
    }
    impl _p::StructView for StructP {
        type Reader<'a, T: _p::rpc::Table> = struct_p::Reader<'a, T>;
        type Builder<'a, T: _p::rpc::Table> = struct_p::Builder<'a, T>;
    }
    impl _p::ty::Struct for StructP {
        const SIZE: _p::StructSize = _p::StructSize {
            data: 0u16,
            ptrs: 1u16,
        };
    }
    impl StructP {
        const F: _p::Descriptor<_p::Text> = _p::Descriptor::<_p::Text> {
            slot: 0u32,
            default: ::core::option::Option::None,
        };
    }
    impl<'p, T: _p::rpc::Table + 'p> struct_p::Reader<'p, T> {
        #[inline]
        pub fn f(&self) -> _p::Accessor<'_, 'p, T, _p::Text> {
            unsafe { <_p::Text as _p::field::FieldType>::accessor(&self.0, &StructP::F) }
        }
    }
    impl<'p, T: _p::rpc::Table + 'p> struct_p::Builder<'p, T> {
        #[inline]
        pub fn f(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::accessor(&mut self.0, &StructP::F)
            }
        }
        #[inline]
        pub fn into_f(self) -> _p::AccessorOwned<'p, T, _p::Text> {
            unsafe { <_p::Text as _p::field::FieldType>::accessor(self.0, &StructP::F) }
        }
    }
    pub mod struct_p {
        use super::{__file, __imports, _p};
        pub type Reader<'a, T = _p::rpc::Empty> = super::StructP<
            _p::StructReader<'a, T>,
        >;
        pub type Builder<'a, T = _p::rpc::Empty> = super::StructP<
            _p::StructBuilder<'a, T>,
        >;
    }
    #[derive(Clone)]
    pub struct Struct0c<T = _p::Family>(T);
    impl _p::ty::SchemaType for Struct0c {
        const ID: u64 = 10680888278325309802u64;
    }
    impl<T> _p::IntoFamily for Struct0c<T> {
        type Family = Struct0c;
    }
    impl<T: _p::Capable> _p::Capable for Struct0c<T> {
        type Table = T::Table;
        type Imbued = T::Imbued;
        type ImbuedWith<T2: _p::rpc::Table> = Struct0c<T::ImbuedWith<T2>>;
        #[inline]
        fn imbued(&self) -> &Self::Imbued {
            self.0.imbued()
        }
        #[inline]
        fn imbue_release<T2: _p::rpc::Table>(
            self,
            new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
        ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
            let (imbued, old) = self.0.imbue_release(new_table);
            (Struct0c(imbued), old)
        }
        #[inline]
        fn imbue_release_into<U>(
            &self,
            other: U,
        ) -> (U::ImbuedWith<Self::Table>, U::Imbued)
        where
            U: _p::Capable,
            U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
        {
            self.0.imbue_release_into(other)
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for struct0c::Reader<'a, T> {
        type Ptr = _p::StructReader<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
    for struct0c::Reader<'a, T> {
        #[inline]
        fn from(ptr: _p::StructReader<'a, T>) -> Self {
            Struct0c(ptr)
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<struct0c::Reader<'a, T>>
    for _p::StructReader<'a, T> {
        #[inline]
        fn from(reader: struct0c::Reader<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
    for struct0c::Reader<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructReader<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructReader for struct0c::Reader<'a, T> {}
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for struct0c::Builder<'a, T> {
        type Ptr = _p::StructBuilder<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<struct0c::Builder<'a, T>>
    for _p::StructBuilder<'a, T> {
        #[inline]
        fn from(reader: struct0c::Builder<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
    for struct0c::Builder<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
    for struct0c::Builder<'a, T> {
        #[inline]
        fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
            &mut self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for struct0c::Builder<'a, T> {
        unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
            Self(ptr)
        }
    }
    impl _p::StructView for Struct0c {
        type Reader<'a, T: _p::rpc::Table> = struct0c::Reader<'a, T>;
        type Builder<'a, T: _p::rpc::Table> = struct0c::Builder<'a, T>;
    }
    impl _p::ty::Struct for Struct0c {
        const SIZE: _p::StructSize = _p::StructSize {
            data: 0u16,
            ptrs: 1u16,
        };
    }
    impl Struct0c {
        const F: _p::Descriptor<()> = ();
        const PAD: _p::Descriptor<_p::Text> = _p::Descriptor::<_p::Text> {
            slot: 0u32,
            default: ::core::option::Option::None,
        };
    }
    impl<'p, T: _p::rpc::Table + 'p> struct0c::Reader<'p, T> {
        #[inline]
        pub fn f(&self) -> _p::Accessor<'_, 'p, T, ()> {
            unsafe { <() as _p::field::FieldType>::accessor(&self.0, &Struct0c::F) }
        }
        #[inline]
        pub fn pad(&self) -> _p::Accessor<'_, 'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::accessor(&self.0, &Struct0c::PAD)
            }
        }
    }
    impl<'p, T: _p::rpc::Table + 'p> struct0c::Builder<'p, T> {
        #[inline]
        pub fn f(&mut self) -> _p::AccessorMut<'_, 'p, T, ()> {
            unsafe { <() as _p::field::FieldType>::accessor(&mut self.0, &Struct0c::F) }
        }
        #[inline]
        pub fn pad(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::accessor(&mut self.0, &Struct0c::PAD)
            }
        }
        #[inline]
        pub fn into_pad(self) -> _p::AccessorOwned<'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::accessor(self.0, &Struct0c::PAD)
            }
        }
    }
    pub mod struct0c {
        use super::{__file, __imports, _p};
        pub type Reader<'a, T = _p::rpc::Empty> = super::Struct0c<
            _p::StructReader<'a, T>,
        >;
        pub type Builder<'a, T = _p::rpc::Empty> = super::Struct0c<
            _p::StructBuilder<'a, T>,
        >;
    }
    #[derive(Clone)]
    pub struct Struct1c<T = _p::Family>(T);
    impl _p::ty::SchemaType for Struct1c {
        const ID: u64 = 9912911025091744973u64;
    }
    impl<T> _p::IntoFamily for Struct1c<T> {
        type Family = Struct1c;
    }
    impl<T: _p::Capable> _p::Capable for Struct1c<T> {
        type Table = T::Table;
        type Imbued = T::Imbued;
        type ImbuedWith<T2: _p::rpc::Table> = Struct1c<T::ImbuedWith<T2>>;
        #[inline]
        fn imbued(&self) -> &Self::Imbued {
            self.0.imbued()
        }
        #[inline]
        fn imbue_release<T2: _p::rpc::Table>(
            self,
            new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
        ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
            let (imbued, old) = self.0.imbue_release(new_table);
            (Struct1c(imbued), old)
        }
        #[inline]
        fn imbue_release_into<U>(
            &self,
            other: U,
        ) -> (U::ImbuedWith<Self::Table>, U::Imbued)
        where
            U: _p::Capable,
            U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
        {
            self.0.imbue_release_into(other)
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for struct1c::Reader<'a, T> {
        type Ptr = _p::StructReader<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
    for struct1c::Reader<'a, T> {
        #[inline]
        fn from(ptr: _p::StructReader<'a, T>) -> Self {
            Struct1c(ptr)
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<struct1c::Reader<'a, T>>
    for _p::StructReader<'a, T> {
        #[inline]
        fn from(reader: struct1c::Reader<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
    for struct1c::Reader<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructReader<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructReader for struct1c::Reader<'a, T> {}
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for struct1c::Builder<'a, T> {
        type Ptr = _p::StructBuilder<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<struct1c::Builder<'a, T>>
    for _p::StructBuilder<'a, T> {
        #[inline]
        fn from(reader: struct1c::Builder<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
    for struct1c::Builder<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
    for struct1c::Builder<'a, T> {
        #[inline]
        fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
            &mut self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for struct1c::Builder<'a, T> {
        unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
            Self(ptr)
        }
    }
    impl _p::StructView for Struct1c {
        type Reader<'a, T: _p::rpc::Table> = struct1c::Reader<'a, T>;
        type Builder<'a, T: _p::rpc::Table> = struct1c::Builder<'a, T>;
    }
    impl _p::ty::Struct for Struct1c {
        const SIZE: _p::StructSize = _p::StructSize {
            data: 1u16,
            ptrs: 1u16,
        };
    }
    impl Struct1c {
        const F: _p::Descriptor<bool> = _p::Descriptor::<bool> {
            slot: 0u32,
            default: false,
        };
        const PAD: _p::Descriptor<_p::Text> = _p::Descriptor::<_p::Text> {
            slot: 0u32,
            default: ::core::option::Option::None,
        };
    }
    impl<'p, T: _p::rpc::Table + 'p> struct1c::Reader<'p, T> {
        #[inline]
        pub fn f(&self) -> _p::Accessor<'_, 'p, T, bool> {
            unsafe { <bool as _p::field::FieldType>::accessor(&self.0, &Struct1c::F) }
        }
        #[inline]
        pub fn pad(&self) -> _p::Accessor<'_, 'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::accessor(&self.0, &Struct1c::PAD)
            }
        }
    }
    impl<'p, T: _p::rpc::Table + 'p> struct1c::Builder<'p, T> {
        #[inline]
        pub fn f(&mut self) -> _p::AccessorMut<'_, 'p, T, bool> {
            unsafe {
                <bool as _p::field::FieldType>::accessor(&mut self.0, &Struct1c::F)
            }
        }
        #[inline]
        pub fn pad(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::accessor(&mut self.0, &Struct1c::PAD)
            }
        }
        #[inline]
        pub fn into_pad(self) -> _p::AccessorOwned<'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::accessor(self.0, &Struct1c::PAD)
            }
        }
    }
    pub mod struct1c {
        use super::{__file, __imports, _p};
        pub type Reader<'a, T = _p::rpc::Empty> = super::Struct1c<
            _p::StructReader<'a, T>,
        >;
        pub type Builder<'a, T = _p::rpc::Empty> = super::Struct1c<
            _p::StructBuilder<'a, T>,
        >;
    }
    #[derive(Clone)]
    pub struct Struct8c<T = _p::Family>(T);
    impl _p::ty::SchemaType for Struct8c {
        const ID: u64 = 17088473475326966308u64;
    }
    impl<T> _p::IntoFamily for Struct8c<T> {
        type Family = Struct8c;
    }
    impl<T: _p::Capable> _p::Capable for Struct8c<T> {
        type Table = T::Table;
        type Imbued = T::Imbued;
        type ImbuedWith<T2: _p::rpc::Table> = Struct8c<T::ImbuedWith<T2>>;
        #[inline]
        fn imbued(&self) -> &Self::Imbued {
            self.0.imbued()
        }
        #[inline]
        fn imbue_release<T2: _p::rpc::Table>(
            self,
            new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
        ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
            let (imbued, old) = self.0.imbue_release(new_table);
            (Struct8c(imbued), old)
        }
        #[inline]
        fn imbue_release_into<U>(
            &self,
            other: U,
        ) -> (U::ImbuedWith<Self::Table>, U::Imbued)
        where
            U: _p::Capable,
            U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
        {
            self.0.imbue_release_into(other)
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for struct8c::Reader<'a, T> {
        type Ptr = _p::StructReader<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
    for struct8c::Reader<'a, T> {
        #[inline]
        fn from(ptr: _p::StructReader<'a, T>) -> Self {
            Struct8c(ptr)
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<struct8c::Reader<'a, T>>
    for _p::StructReader<'a, T> {
        #[inline]
        fn from(reader: struct8c::Reader<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
    for struct8c::Reader<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructReader<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructReader for struct8c::Reader<'a, T> {}
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for struct8c::Builder<'a, T> {
        type Ptr = _p::StructBuilder<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<struct8c::Builder<'a, T>>
    for _p::StructBuilder<'a, T> {
        #[inline]
        fn from(reader: struct8c::Builder<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
    for struct8c::Builder<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
    for struct8c::Builder<'a, T> {
        #[inline]
        fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
            &mut self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for struct8c::Builder<'a, T> {
        unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
            Self(ptr)
        }
    }
    impl _p::StructView for Struct8c {
        type Reader<'a, T: _p::rpc::Table> = struct8c::Reader<'a, T>;
        type Builder<'a, T: _p::rpc::Table> = struct8c::Builder<'a, T>;
    }
    impl _p::ty::Struct for Struct8c {
        const SIZE: _p::StructSize = _p::StructSize {
            data: 1u16,
            ptrs: 1u16,
        };
    }
    impl Struct8c {
        const F: _p::Descriptor<u8> = _p::Descriptor::<u8> {
            slot: 0u32,
            default: 0u8,
        };
        const PAD: _p::Descriptor<_p::Text> = _p::Descriptor::<_p::Text> {
            slot: 0u32,
            default: ::core::option::Option::None,
        };
    }
    impl<'p, T: _p::rpc::Table + 'p> struct8c::Reader<'p, T> {
        #[inline]
        pub fn f(&self) -> _p::Accessor<'_, 'p, T, u8> {
            unsafe { <u8 as _p::field::FieldType>::accessor(&self.0, &Struct8c::F) }
        }
        #[inline]
        pub fn pad(&self) -> _p::Accessor<'_, 'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::accessor(&self.0, &Struct8c::PAD)
            }
        }
    }
    impl<'p, T: _p::rpc::Table + 'p> struct8c::Builder<'p, T> {
        #[inline]
        pub fn f(&mut self) -> _p::AccessorMut<'_, 'p, T, u8> {
            unsafe { <u8 as _p::field::FieldType>::accessor(&mut self.0, &Struct8c::F) }
        }
        #[inline]
        pub fn pad(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::accessor(&mut self.0, &Struct8c::PAD)
            }
        }
        #[inline]
        pub fn into_pad(self) -> _p::AccessorOwned<'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::accessor(self.0, &Struct8c::PAD)
            }
        }
    }
    pub mod struct8c {
        use super::{__file, __imports, _p};
        pub type Reader<'a, T = _p::rpc::Empty> = super::Struct8c<
            _p::StructReader<'a, T>,
        >;
        pub type Builder<'a, T = _p::rpc::Empty> = super::Struct8c<
            _p::StructBuilder<'a, T>,
        >;
    }
    #[derive(Clone)]
    pub struct Struct16c<T = _p::Family>(T);
    impl _p::ty::SchemaType for Struct16c {
        const ID: u64 = 11058733449371015398u64;
    }
    impl<T> _p::IntoFamily for Struct16c<T> {
        type Family = Struct16c;
    }
    impl<T: _p::Capable> _p::Capable for Struct16c<T> {
        type Table = T::Table;
        type Imbued = T::Imbued;
        type ImbuedWith<T2: _p::rpc::Table> = Struct16c<T::ImbuedWith<T2>>;
        #[inline]
        fn imbued(&self) -> &Self::Imbued {
            self.0.imbued()
        }
        #[inline]
        fn imbue_release<T2: _p::rpc::Table>(
            self,
            new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
        ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
            let (imbued, old) = self.0.imbue_release(new_table);
            (Struct16c(imbued), old)
        }
        #[inline]
        fn imbue_release_into<U>(
            &self,
            other: U,
        ) -> (U::ImbuedWith<Self::Table>, U::Imbued)
        where
            U: _p::Capable,
            U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
        {
            self.0.imbue_release_into(other)
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for struct16c::Reader<'a, T> {
        type Ptr = _p::StructReader<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
    for struct16c::Reader<'a, T> {
        #[inline]
        fn from(ptr: _p::StructReader<'a, T>) -> Self {
            Struct16c(ptr)
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<struct16c::Reader<'a, T>>
    for _p::StructReader<'a, T> {
        #[inline]
        fn from(reader: struct16c::Reader<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
    for struct16c::Reader<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructReader<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructReader for struct16c::Reader<'a, T> {}
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for struct16c::Builder<'a, T> {
        type Ptr = _p::StructBuilder<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<struct16c::Builder<'a, T>>
    for _p::StructBuilder<'a, T> {
        #[inline]
        fn from(reader: struct16c::Builder<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
    for struct16c::Builder<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
    for struct16c::Builder<'a, T> {
        #[inline]
        fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
            &mut self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for struct16c::Builder<'a, T> {
        unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
            Self(ptr)
        }
    }
    impl _p::StructView for Struct16c {
        type Reader<'a, T: _p::rpc::Table> = struct16c::Reader<'a, T>;
        type Builder<'a, T: _p::rpc::Table> = struct16c::Builder<'a, T>;
    }
    impl _p::ty::Struct for Struct16c {
        const SIZE: _p::StructSize = _p::StructSize {
            data: 1u16,
            ptrs: 1u16,
        };
    }
    impl Struct16c {
        const F: _p::Descriptor<u16> = _p::Descriptor::<u16> {
            slot: 0u32,
            default: 0u16,
        };
        const PAD: _p::Descriptor<_p::Text> = _p::Descriptor::<_p::Text> {
            slot: 0u32,
            default: ::core::option::Option::None,
        };
    }
    impl<'p, T: _p::rpc::Table + 'p> struct16c::Reader<'p, T> {
        #[inline]
        pub fn f(&self) -> _p::Accessor<'_, 'p, T, u16> {
            unsafe { <u16 as _p::field::FieldType>::accessor(&self.0, &Struct16c::F) }
        }
        #[inline]
        pub fn pad(&self) -> _p::Accessor<'_, 'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::accessor(&self.0, &Struct16c::PAD)
            }
        }
    }
    impl<'p, T: _p::rpc::Table + 'p> struct16c::Builder<'p, T> {
        #[inline]
        pub fn f(&mut self) -> _p::AccessorMut<'_, 'p, T, u16> {
            unsafe {
                <u16 as _p::field::FieldType>::accessor(&mut self.0, &Struct16c::F)
            }
        }
        #[inline]
        pub fn pad(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::accessor(
                    &mut self.0,
                    &Struct16c::PAD,
                )
            }
        }
        #[inline]
        pub fn into_pad(self) -> _p::AccessorOwned<'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::accessor(self.0, &Struct16c::PAD)
            }
        }
    }
    pub mod struct16c {
        use super::{__file, __imports, _p};
        pub type Reader<'a, T = _p::rpc::Empty> = super::Struct16c<
            _p::StructReader<'a, T>,
        >;
        pub type Builder<'a, T = _p::rpc::Empty> = super::Struct16c<
            _p::StructBuilder<'a, T>,
        >;
    }
    #[derive(Clone)]
    pub struct Struct32c<T = _p::Family>(T);
    impl _p::ty::SchemaType for Struct32c {
        const ID: u64 = 17104576006234732804u64;
    }
    impl<T> _p::IntoFamily for Struct32c<T> {
        type Family = Struct32c;
    }
    impl<T: _p::Capable> _p::Capable for Struct32c<T> {
        type Table = T::Table;
        type Imbued = T::Imbued;
        type ImbuedWith<T2: _p::rpc::Table> = Struct32c<T::ImbuedWith<T2>>;
        #[inline]
        fn imbued(&self) -> &Self::Imbued {
            self.0.imbued()
        }
        #[inline]
        fn imbue_release<T2: _p::rpc::Table>(
            self,
            new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
        ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
            let (imbued, old) = self.0.imbue_release(new_table);
            (Struct32c(imbued), old)
        }
        #[inline]
        fn imbue_release_into<U>(
            &self,
            other: U,
        ) -> (U::ImbuedWith<Self::Table>, U::Imbued)
        where
            U: _p::Capable,
            U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
        {
            self.0.imbue_release_into(other)
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for struct32c::Reader<'a, T> {
        type Ptr = _p::StructReader<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
    for struct32c::Reader<'a, T> {
        #[inline]
        fn from(ptr: _p::StructReader<'a, T>) -> Self {
            Struct32c(ptr)
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<struct32c::Reader<'a, T>>
    for _p::StructReader<'a, T> {
        #[inline]
        fn from(reader: struct32c::Reader<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
    for struct32c::Reader<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructReader<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructReader for struct32c::Reader<'a, T> {}
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for struct32c::Builder<'a, T> {
        type Ptr = _p::StructBuilder<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<struct32c::Builder<'a, T>>
    for _p::StructBuilder<'a, T> {
        #[inline]
        fn from(reader: struct32c::Builder<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
    for struct32c::Builder<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
    for struct32c::Builder<'a, T> {
        #[inline]
        fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
            &mut self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for struct32c::Builder<'a, T> {
        unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
            Self(ptr)
        }
    }
    impl _p::StructView for Struct32c {
        type Reader<'a, T: _p::rpc::Table> = struct32c::Reader<'a, T>;
        type Builder<'a, T: _p::rpc::Table> = struct32c::Builder<'a, T>;
    }
    impl _p::ty::Struct for Struct32c {
        const SIZE: _p::StructSize = _p::StructSize {
            data: 1u16,
            ptrs: 1u16,
        };
    }
    impl Struct32c {
        const F: _p::Descriptor<u32> = _p::Descriptor::<u32> {
            slot: 0u32,
            default: 0u32,
        };
        const PAD: _p::Descriptor<_p::Text> = _p::Descriptor::<_p::Text> {
            slot: 0u32,
            default: ::core::option::Option::None,
        };
    }
    impl<'p, T: _p::rpc::Table + 'p> struct32c::Reader<'p, T> {
        #[inline]
        pub fn f(&self) -> _p::Accessor<'_, 'p, T, u32> {
            unsafe { <u32 as _p::field::FieldType>::accessor(&self.0, &Struct32c::F) }
        }
        #[inline]
        pub fn pad(&self) -> _p::Accessor<'_, 'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::accessor(&self.0, &Struct32c::PAD)
            }
        }
    }
    impl<'p, T: _p::rpc::Table + 'p> struct32c::Builder<'p, T> {
        #[inline]
        pub fn f(&mut self) -> _p::AccessorMut<'_, 'p, T, u32> {
            unsafe {
                <u32 as _p::field::FieldType>::accessor(&mut self.0, &Struct32c::F)
            }
        }
        #[inline]
        pub fn pad(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::accessor(
                    &mut self.0,
                    &Struct32c::PAD,
                )
            }
        }
        #[inline]
        pub fn into_pad(self) -> _p::AccessorOwned<'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::accessor(self.0, &Struct32c::PAD)
            }
        }
    }
    pub mod struct32c {
        use super::{__file, __imports, _p};
        pub type Reader<'a, T = _p::rpc::Empty> = super::Struct32c<
            _p::StructReader<'a, T>,
        >;
        pub type Builder<'a, T = _p::rpc::Empty> = super::Struct32c<
            _p::StructBuilder<'a, T>,
        >;
    }
    #[derive(Clone)]
    pub struct Struct64c<T = _p::Family>(T);
    impl _p::ty::SchemaType for Struct64c {
        const ID: u64 = 13579539769030442109u64;
    }
    impl<T> _p::IntoFamily for Struct64c<T> {
        type Family = Struct64c;
    }
    impl<T: _p::Capable> _p::Capable for Struct64c<T> {
        type Table = T::Table;
        type Imbued = T::Imbued;
        type ImbuedWith<T2: _p::rpc::Table> = Struct64c<T::ImbuedWith<T2>>;
        #[inline]
        fn imbued(&self) -> &Self::Imbued {
            self.0.imbued()
        }
        #[inline]
        fn imbue_release<T2: _p::rpc::Table>(
            self,
            new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
        ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
            let (imbued, old) = self.0.imbue_release(new_table);
            (Struct64c(imbued), old)
        }
        #[inline]
        fn imbue_release_into<U>(
            &self,
            other: U,
        ) -> (U::ImbuedWith<Self::Table>, U::Imbued)
        where
            U: _p::Capable,
            U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
        {
            self.0.imbue_release_into(other)
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for struct64c::Reader<'a, T> {
        type Ptr = _p::StructReader<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
    for struct64c::Reader<'a, T> {
        #[inline]
        fn from(ptr: _p::StructReader<'a, T>) -> Self {
            Struct64c(ptr)
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<struct64c::Reader<'a, T>>
    for _p::StructReader<'a, T> {
        #[inline]
        fn from(reader: struct64c::Reader<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
    for struct64c::Reader<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructReader<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructReader for struct64c::Reader<'a, T> {}
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for struct64c::Builder<'a, T> {
        type Ptr = _p::StructBuilder<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<struct64c::Builder<'a, T>>
    for _p::StructBuilder<'a, T> {
        #[inline]
        fn from(reader: struct64c::Builder<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
    for struct64c::Builder<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
    for struct64c::Builder<'a, T> {
        #[inline]
        fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
            &mut self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for struct64c::Builder<'a, T> {
        unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
            Self(ptr)
        }
    }
    impl _p::StructView for Struct64c {
        type Reader<'a, T: _p::rpc::Table> = struct64c::Reader<'a, T>;
        type Builder<'a, T: _p::rpc::Table> = struct64c::Builder<'a, T>;
    }
    impl _p::ty::Struct for Struct64c {
        const SIZE: _p::StructSize = _p::StructSize {
            data: 1u16,
            ptrs: 1u16,
        };
    }
    impl Struct64c {
        const F: _p::Descriptor<u64> = _p::Descriptor::<u64> {
            slot: 0u32,
            default: 0u64,
        };
        const PAD: _p::Descriptor<_p::Text> = _p::Descriptor::<_p::Text> {
            slot: 0u32,
            default: ::core::option::Option::None,
        };
    }
    impl<'p, T: _p::rpc::Table + 'p> struct64c::Reader<'p, T> {
        #[inline]
        pub fn f(&self) -> _p::Accessor<'_, 'p, T, u64> {
            unsafe { <u64 as _p::field::FieldType>::accessor(&self.0, &Struct64c::F) }
        }
        #[inline]
        pub fn pad(&self) -> _p::Accessor<'_, 'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::accessor(&self.0, &Struct64c::PAD)
            }
        }
    }
    impl<'p, T: _p::rpc::Table + 'p> struct64c::Builder<'p, T> {
        #[inline]
        pub fn f(&mut self) -> _p::AccessorMut<'_, 'p, T, u64> {
            unsafe {
                <u64 as _p::field::FieldType>::accessor(&mut self.0, &Struct64c::F)
            }
        }
        #[inline]
        pub fn pad(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::accessor(
                    &mut self.0,
                    &Struct64c::PAD,
                )
            }
        }
        #[inline]
        pub fn into_pad(self) -> _p::AccessorOwned<'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::accessor(self.0, &Struct64c::PAD)
            }
        }
    }
    pub mod struct64c {
        use super::{__file, __imports, _p};
        pub type Reader<'a, T = _p::rpc::Empty> = super::Struct64c<
            _p::StructReader<'a, T>,
        >;
        pub type Builder<'a, T = _p::rpc::Empty> = super::Struct64c<
            _p::StructBuilder<'a, T>,
        >;
    }
    #[derive(Clone)]
    pub struct StructPc<T = _p::Family>(T);
    impl _p::ty::SchemaType for StructPc {
        const ID: u64 = 14043178718634049853u64;
    }
    impl<T> _p::IntoFamily for StructPc<T> {
        type Family = StructPc;
    }
    impl<T: _p::Capable> _p::Capable for StructPc<T> {
        type Table = T::Table;
        type Imbued = T::Imbued;
        type ImbuedWith<T2: _p::rpc::Table> = StructPc<T::ImbuedWith<T2>>;
        #[inline]
        fn imbued(&self) -> &Self::Imbued {
            self.0.imbued()
        }
        #[inline]
        fn imbue_release<T2: _p::rpc::Table>(
            self,
            new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
        ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
            let (imbued, old) = self.0.imbue_release(new_table);
            (StructPc(imbued), old)
        }
        #[inline]
        fn imbue_release_into<U>(
            &self,
            other: U,
        ) -> (U::ImbuedWith<Self::Table>, U::Imbued)
        where
            U: _p::Capable,
            U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
        {
            self.0.imbue_release_into(other)
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for struct_pc::Reader<'a, T> {
        type Ptr = _p::StructReader<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
    for struct_pc::Reader<'a, T> {
        #[inline]
        fn from(ptr: _p::StructReader<'a, T>) -> Self {
            StructPc(ptr)
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<struct_pc::Reader<'a, T>>
    for _p::StructReader<'a, T> {
        #[inline]
        fn from(reader: struct_pc::Reader<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
    for struct_pc::Reader<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructReader<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructReader for struct_pc::Reader<'a, T> {}
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for struct_pc::Builder<'a, T> {
        type Ptr = _p::StructBuilder<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<struct_pc::Builder<'a, T>>
    for _p::StructBuilder<'a, T> {
        #[inline]
        fn from(reader: struct_pc::Builder<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
    for struct_pc::Builder<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
    for struct_pc::Builder<'a, T> {
        #[inline]
        fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
            &mut self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for struct_pc::Builder<'a, T> {
        unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
            Self(ptr)
        }
    }
    impl _p::StructView for StructPc {
        type Reader<'a, T: _p::rpc::Table> = struct_pc::Reader<'a, T>;
        type Builder<'a, T: _p::rpc::Table> = struct_pc::Builder<'a, T>;
    }
    impl _p::ty::Struct for StructPc {
        const SIZE: _p::StructSize = _p::StructSize {
            data: 1u16,
            ptrs: 1u16,
        };
    }
    impl StructPc {
        const F: _p::Descriptor<_p::Text> = _p::Descriptor::<_p::Text> {
            slot: 0u32,
            default: ::core::option::Option::None,
        };
        const PAD: _p::Descriptor<u64> = _p::Descriptor::<u64> {
            slot: 0u32,
            default: 0u64,
        };
    }
    impl<'p, T: _p::rpc::Table + 'p> struct_pc::Reader<'p, T> {
        #[inline]
        pub fn f(&self) -> _p::Accessor<'_, 'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::accessor(&self.0, &StructPc::F)
            }
        }
        #[inline]
        pub fn pad(&self) -> _p::Accessor<'_, 'p, T, u64> {
            unsafe { <u64 as _p::field::FieldType>::accessor(&self.0, &StructPc::PAD) }
        }
    }
    impl<'p, T: _p::rpc::Table + 'p> struct_pc::Builder<'p, T> {
        #[inline]
        pub fn f(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::accessor(&mut self.0, &StructPc::F)
            }
        }
        #[inline]
        pub fn pad(&mut self) -> _p::AccessorMut<'_, 'p, T, u64> {
            unsafe {
                <u64 as _p::field::FieldType>::accessor(&mut self.0, &StructPc::PAD)
            }
        }
        #[inline]
        pub fn into_f(self) -> _p::AccessorOwned<'p, T, _p::Text> {
            unsafe { <_p::Text as _p::field::FieldType>::accessor(self.0, &StructPc::F) }
        }
    }
    pub mod struct_pc {
        use super::{__file, __imports, _p};
        pub type Reader<'a, T = _p::rpc::Empty> = super::StructPc<
            _p::StructReader<'a, T>,
        >;
        pub type Builder<'a, T = _p::rpc::Empty> = super::StructPc<
            _p::StructBuilder<'a, T>,
        >;
    }
}
#[derive(Clone)]
pub struct TestFieldZeroIsBit<T = _p::Family>(T);
impl _p::ty::SchemaType for TestFieldZeroIsBit {
    const ID: u64 = 10591386225455521116u64;
}
impl<T> _p::IntoFamily for TestFieldZeroIsBit<T> {
    type Family = TestFieldZeroIsBit;
}
impl<T: _p::Capable> _p::Capable for TestFieldZeroIsBit<T> {
    type Table = T::Table;
    type Imbued = T::Imbued;
    type ImbuedWith<T2: _p::rpc::Table> = TestFieldZeroIsBit<T::ImbuedWith<T2>>;
    #[inline]
    fn imbued(&self) -> &Self::Imbued {
        self.0.imbued()
    }
    #[inline]
    fn imbue_release<T2: _p::rpc::Table>(
        self,
        new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
    ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
        let (imbued, old) = self.0.imbue_release(new_table);
        (TestFieldZeroIsBit(imbued), old)
    }
    #[inline]
    fn imbue_release_into<U>(&self, other: U) -> (U::ImbuedWith<Self::Table>, U::Imbued)
    where
        U: _p::Capable,
        U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
    {
        self.0.imbue_release_into(other)
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_field_zero_is_bit::Reader<'a, T> {
    type Ptr = _p::StructReader<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
for test_field_zero_is_bit::Reader<'a, T> {
    #[inline]
    fn from(ptr: _p::StructReader<'a, T>) -> Self {
        TestFieldZeroIsBit(ptr)
    }
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_field_zero_is_bit::Reader<'a, T>>
for _p::StructReader<'a, T> {
    #[inline]
    fn from(reader: test_field_zero_is_bit::Reader<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
for test_field_zero_is_bit::Reader<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructReader<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructReader
for test_field_zero_is_bit::Reader<'a, T> {}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_field_zero_is_bit::Builder<'a, T> {
    type Ptr = _p::StructBuilder<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_field_zero_is_bit::Builder<'a, T>>
for _p::StructBuilder<'a, T> {
    #[inline]
    fn from(reader: test_field_zero_is_bit::Builder<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
for test_field_zero_is_bit::Builder<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
for test_field_zero_is_bit::Builder<'a, T> {
    #[inline]
    fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
        &mut self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder
for test_field_zero_is_bit::Builder<'a, T> {
    unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
        Self(ptr)
    }
}
impl _p::StructView for TestFieldZeroIsBit {
    type Reader<'a, T: _p::rpc::Table> = test_field_zero_is_bit::Reader<'a, T>;
    type Builder<'a, T: _p::rpc::Table> = test_field_zero_is_bit::Builder<'a, T>;
}
impl _p::ty::Struct for TestFieldZeroIsBit {
    const SIZE: _p::StructSize = _p::StructSize {
        data: 1u16,
        ptrs: 0u16,
    };
}
impl TestFieldZeroIsBit {
    const BIT: _p::Descriptor<bool> = _p::Descriptor::<bool> {
        slot: 0u32,
        default: false,
    };
    const SECOND_BIT: _p::Descriptor<bool> = _p::Descriptor::<bool> {
        slot: 1u32,
        default: true,
    };
    const THIRD_FIELD: _p::Descriptor<u8> = _p::Descriptor::<u8> {
        slot: 1u32,
        default: 123u8,
    };
}
impl<'p, T: _p::rpc::Table + 'p> test_field_zero_is_bit::Reader<'p, T> {
    #[inline]
    pub fn bit(&self) -> _p::Accessor<'_, 'p, T, bool> {
        unsafe {
            <bool as _p::field::FieldType>::accessor(&self.0, &TestFieldZeroIsBit::BIT)
        }
    }
    #[inline]
    pub fn second_bit(&self) -> _p::Accessor<'_, 'p, T, bool> {
        unsafe {
            <bool as _p::field::FieldType>::accessor(
                &self.0,
                &TestFieldZeroIsBit::SECOND_BIT,
            )
        }
    }
    #[inline]
    pub fn third_field(&self) -> _p::Accessor<'_, 'p, T, u8> {
        unsafe {
            <u8 as _p::field::FieldType>::accessor(
                &self.0,
                &TestFieldZeroIsBit::THIRD_FIELD,
            )
        }
    }
}
impl<'p, T: _p::rpc::Table + 'p> test_field_zero_is_bit::Builder<'p, T> {
    #[inline]
    pub fn bit(&mut self) -> _p::AccessorMut<'_, 'p, T, bool> {
        unsafe {
            <bool as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestFieldZeroIsBit::BIT,
            )
        }
    }
    #[inline]
    pub fn second_bit(&mut self) -> _p::AccessorMut<'_, 'p, T, bool> {
        unsafe {
            <bool as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestFieldZeroIsBit::SECOND_BIT,
            )
        }
    }
    #[inline]
    pub fn third_field(&mut self) -> _p::AccessorMut<'_, 'p, T, u8> {
        unsafe {
            <u8 as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestFieldZeroIsBit::THIRD_FIELD,
            )
        }
    }
}
pub mod test_field_zero_is_bit {
    use super::{__file, __imports, _p};
    pub type Reader<'a, T = _p::rpc::Empty> = super::TestFieldZeroIsBit<
        _p::StructReader<'a, T>,
    >;
    pub type Builder<'a, T = _p::rpc::Empty> = super::TestFieldZeroIsBit<
        _p::StructBuilder<'a, T>,
    >;
}
#[derive(Clone)]
pub struct TestListDefaults<T = _p::Family>(T);
impl _p::ty::SchemaType for TestListDefaults {
    const ID: u64 = 12128665705163980778u64;
}
impl<T> _p::IntoFamily for TestListDefaults<T> {
    type Family = TestListDefaults;
}
impl<T: _p::Capable> _p::Capable for TestListDefaults<T> {
    type Table = T::Table;
    type Imbued = T::Imbued;
    type ImbuedWith<T2: _p::rpc::Table> = TestListDefaults<T::ImbuedWith<T2>>;
    #[inline]
    fn imbued(&self) -> &Self::Imbued {
        self.0.imbued()
    }
    #[inline]
    fn imbue_release<T2: _p::rpc::Table>(
        self,
        new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
    ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
        let (imbued, old) = self.0.imbue_release(new_table);
        (TestListDefaults(imbued), old)
    }
    #[inline]
    fn imbue_release_into<U>(&self, other: U) -> (U::ImbuedWith<Self::Table>, U::Imbued)
    where
        U: _p::Capable,
        U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
    {
        self.0.imbue_release_into(other)
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_list_defaults::Reader<'a, T> {
    type Ptr = _p::StructReader<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
for test_list_defaults::Reader<'a, T> {
    #[inline]
    fn from(ptr: _p::StructReader<'a, T>) -> Self {
        TestListDefaults(ptr)
    }
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_list_defaults::Reader<'a, T>>
for _p::StructReader<'a, T> {
    #[inline]
    fn from(reader: test_list_defaults::Reader<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
for test_list_defaults::Reader<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructReader<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructReader for test_list_defaults::Reader<'a, T> {}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_list_defaults::Builder<'a, T> {
    type Ptr = _p::StructBuilder<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_list_defaults::Builder<'a, T>>
for _p::StructBuilder<'a, T> {
    #[inline]
    fn from(reader: test_list_defaults::Builder<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
for test_list_defaults::Builder<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
for test_list_defaults::Builder<'a, T> {
    #[inline]
    fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
        &mut self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder
for test_list_defaults::Builder<'a, T> {
    unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
        Self(ptr)
    }
}
impl _p::StructView for TestListDefaults {
    type Reader<'a, T: _p::rpc::Table> = test_list_defaults::Reader<'a, T>;
    type Builder<'a, T: _p::rpc::Table> = test_list_defaults::Builder<'a, T>;
}
impl _p::ty::Struct for TestListDefaults {
    const SIZE: _p::StructSize = _p::StructSize {
        data: 0u16,
        ptrs: 1u16,
    };
}
impl TestListDefaults {
    const LISTS: _p::Descriptor<_p::Struct<TestLists>> = _p::Descriptor::<
        _p::Struct<TestLists>,
    > {
        slot: 0u32,
        default: ::core::option::Option::Some(unsafe {
            _p::StructReader::slice_unchecked(
                &[
                    _p::Word([37u8, 0u8, 0u8, 0u8, 7u8, 0u8, 0u8, 0u8]),
                    _p::Word([37u8, 0u8, 0u8, 0u8, 39u8, 0u8, 0u8, 0u8]),
                    _p::Word([53u8, 0u8, 0u8, 0u8, 23u8, 0u8, 0u8, 0u8]),
                    _p::Word([61u8, 0u8, 0u8, 0u8, 23u8, 0u8, 0u8, 0u8]),
                    _p::Word([69u8, 0u8, 0u8, 0u8, 23u8, 0u8, 0u8, 0u8]),
                    _p::Word([77u8, 0u8, 0u8, 0u8, 23u8, 0u8, 0u8, 0u8]),
                    _p::Word([85u8, 0u8, 0u8, 0u8, 23u8, 0u8, 0u8, 0u8]),
                    _p::Word([101u8, 0u8, 0u8, 0u8, 30u8, 0u8, 0u8, 0u8]),
                    _p::Word([125u8, 0u8, 0u8, 0u8, 30u8, 0u8, 0u8, 0u8]),
                    _p::Word([173u8, 0u8, 0u8, 0u8, 22u8, 0u8, 0u8, 0u8]),
                    _p::Word([8u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([16u8, 0u8, 0u8, 0u8, 1u8, 0u8, 0u8, 0u8]),
                    _p::Word([1u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([1u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([1u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([8u8, 0u8, 0u8, 0u8, 1u8, 0u8, 0u8, 0u8]),
                    _p::Word([123u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([45u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([8u8, 0u8, 0u8, 0u8, 1u8, 0u8, 0u8, 0u8]),
                    _p::Word([57u8, 48u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([133u8, 26u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([8u8, 0u8, 0u8, 0u8, 1u8, 0u8, 0u8, 0u8]),
                    _p::Word([21u8, 205u8, 91u8, 7u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([210u8, 56u8, 251u8, 13u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([8u8, 0u8, 0u8, 0u8, 1u8, 0u8, 0u8, 0u8]),
                    _p::Word([192u8, 186u8, 138u8, 60u8, 213u8, 98u8, 4u8, 0u8]),
                    _p::Word([135u8, 75u8, 170u8, 237u8, 97u8, 85u8, 8u8, 0u8]),
                    _p::Word([8u8, 0u8, 0u8, 0u8, 0u8, 0u8, 1u8, 0u8]),
                    _p::Word([5u8, 0u8, 0u8, 0u8, 34u8, 0u8, 0u8, 0u8]),
                    _p::Word([5u8, 0u8, 0u8, 0u8, 34u8, 0u8, 0u8, 0u8]),
                    _p::Word([102u8, 111u8, 111u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([98u8, 97u8, 114u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([9u8, 0u8, 0u8, 0u8, 28u8, 0u8, 0u8, 0u8]),
                    _p::Word([13u8, 0u8, 0u8, 0u8, 20u8, 0u8, 0u8, 0u8]),
                    _p::Word([13u8, 0u8, 0u8, 0u8, 12u8, 0u8, 0u8, 0u8]),
                    _p::Word([1u8, 0u8, 0u8, 0u8, 2u8, 0u8, 0u8, 0u8]),
                    _p::Word([3u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([4u8, 0u8, 0u8, 0u8, 5u8, 0u8, 0u8, 0u8]),
                    _p::Word([242u8, 79u8, 188u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([9u8, 0u8, 0u8, 0u8, 22u8, 0u8, 0u8, 0u8]),
                    _p::Word([21u8, 0u8, 0u8, 0u8, 14u8, 0u8, 0u8, 0u8]),
                    _p::Word([25u8, 0u8, 0u8, 0u8, 22u8, 0u8, 0u8, 0u8]),
                    _p::Word([5u8, 0u8, 0u8, 0u8, 34u8, 0u8, 0u8, 0u8]),
                    _p::Word([5u8, 0u8, 0u8, 0u8, 34u8, 0u8, 0u8, 0u8]),
                    _p::Word([102u8, 111u8, 111u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([98u8, 97u8, 114u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([1u8, 0u8, 0u8, 0u8, 34u8, 0u8, 0u8, 0u8]),
                    _p::Word([98u8, 97u8, 122u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([5u8, 0u8, 0u8, 0u8, 34u8, 0u8, 0u8, 0u8]),
                    _p::Word([5u8, 0u8, 0u8, 0u8, 50u8, 0u8, 0u8, 0u8]),
                    _p::Word([113u8, 117u8, 120u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([99u8, 111u8, 114u8, 103u8, 101u8, 0u8, 0u8, 0u8]),
                    _p::Word([5u8, 0u8, 0u8, 0u8, 167u8, 1u8, 0u8, 0u8]),
                    _p::Word([213u8, 0u8, 0u8, 0u8, 215u8, 0u8, 0u8, 0u8]),
                    _p::Word([8u8, 0u8, 0u8, 0u8, 6u8, 0u8, 20u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 123u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 200u8, 1u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([4u8, 0u8, 0u8, 0u8, 6u8, 0u8, 20u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 21u8, 3u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                ],
                _p::StructSize {
                    data: 0u16,
                    ptrs: 10u16,
                },
            )
        }),
    };
}
impl<'p, T: _p::rpc::Table + 'p> test_list_defaults::Reader<'p, T> {
    #[inline]
    pub fn lists(&self) -> _p::Accessor<'_, 'p, T, _p::Struct<TestLists>> {
        unsafe {
            <_p::Struct<
                TestLists,
            > as _p::field::FieldType>::accessor(&self.0, &TestListDefaults::LISTS)
        }
    }
}
impl<'p, T: _p::rpc::Table + 'p> test_list_defaults::Builder<'p, T> {
    #[inline]
    pub fn lists(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Struct<TestLists>> {
        unsafe {
            <_p::Struct<
                TestLists,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestListDefaults::LISTS)
        }
    }
    #[inline]
    pub fn into_lists(self) -> _p::AccessorOwned<'p, T, _p::Struct<TestLists>> {
        unsafe {
            <_p::Struct<
                TestLists,
            > as _p::field::FieldType>::accessor(self.0, &TestListDefaults::LISTS)
        }
    }
}
pub mod test_list_defaults {
    use super::{__file, __imports, _p};
    pub type Reader<'a, T = _p::rpc::Empty> = super::TestListDefaults<
        _p::StructReader<'a, T>,
    >;
    pub type Builder<'a, T = _p::rpc::Empty> = super::TestListDefaults<
        _p::StructBuilder<'a, T>,
    >;
}
#[derive(Clone)]
pub struct TestLateUnion<T = _p::Family>(T);
impl _p::ty::SchemaType for TestLateUnion {
    const ID: u64 = 12064647091276568275u64;
}
impl<T> _p::IntoFamily for TestLateUnion<T> {
    type Family = TestLateUnion;
}
impl<T: _p::Capable> _p::Capable for TestLateUnion<T> {
    type Table = T::Table;
    type Imbued = T::Imbued;
    type ImbuedWith<T2: _p::rpc::Table> = TestLateUnion<T::ImbuedWith<T2>>;
    #[inline]
    fn imbued(&self) -> &Self::Imbued {
        self.0.imbued()
    }
    #[inline]
    fn imbue_release<T2: _p::rpc::Table>(
        self,
        new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
    ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
        let (imbued, old) = self.0.imbue_release(new_table);
        (TestLateUnion(imbued), old)
    }
    #[inline]
    fn imbue_release_into<U>(&self, other: U) -> (U::ImbuedWith<Self::Table>, U::Imbued)
    where
        U: _p::Capable,
        U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
    {
        self.0.imbue_release_into(other)
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_late_union::Reader<'a, T> {
    type Ptr = _p::StructReader<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
for test_late_union::Reader<'a, T> {
    #[inline]
    fn from(ptr: _p::StructReader<'a, T>) -> Self {
        TestLateUnion(ptr)
    }
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_late_union::Reader<'a, T>>
for _p::StructReader<'a, T> {
    #[inline]
    fn from(reader: test_late_union::Reader<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
for test_late_union::Reader<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructReader<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructReader for test_late_union::Reader<'a, T> {}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_late_union::Builder<'a, T> {
    type Ptr = _p::StructBuilder<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_late_union::Builder<'a, T>>
for _p::StructBuilder<'a, T> {
    #[inline]
    fn from(reader: test_late_union::Builder<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
for test_late_union::Builder<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
for test_late_union::Builder<'a, T> {
    #[inline]
    fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
        &mut self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for test_late_union::Builder<'a, T> {
    unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
        Self(ptr)
    }
}
impl _p::StructView for TestLateUnion {
    type Reader<'a, T: _p::rpc::Table> = test_late_union::Reader<'a, T>;
    type Builder<'a, T: _p::rpc::Table> = test_late_union::Builder<'a, T>;
}
impl _p::ty::Struct for TestLateUnion {
    const SIZE: _p::StructSize = _p::StructSize {
        data: 3u16,
        ptrs: 3u16,
    };
}
impl TestLateUnion {
    const FOO: _p::Descriptor<i32> = _p::Descriptor::<i32> {
        slot: 0u32,
        default: 0i32,
    };
    const BAR: _p::Descriptor<_p::Text> = _p::Descriptor::<_p::Text> {
        slot: 0u32,
        default: ::core::option::Option::None,
    };
    const BAZ: _p::Descriptor<i16> = _p::Descriptor::<i16> {
        slot: 2u32,
        default: 0i16,
    };
    const THE_UNION: _p::Descriptor<_p::Group<test_late_union::TheUnion>> = ();
    const ANOTHER_UNION: _p::Descriptor<_p::Group<test_late_union::AnotherUnion>> = ();
}
impl<'p, T: _p::rpc::Table + 'p> test_late_union::Reader<'p, T> {
    #[inline]
    pub fn foo(&self) -> _p::Accessor<'_, 'p, T, i32> {
        unsafe { <i32 as _p::field::FieldType>::accessor(&self.0, &TestLateUnion::FOO) }
    }
    #[inline]
    pub fn bar(&self) -> _p::Accessor<'_, 'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(&self.0, &TestLateUnion::BAR)
        }
    }
    #[inline]
    pub fn baz(&self) -> _p::Accessor<'_, 'p, T, i16> {
        unsafe { <i16 as _p::field::FieldType>::accessor(&self.0, &TestLateUnion::BAZ) }
    }
    #[inline]
    pub fn the_union(
        &self,
    ) -> _p::Accessor<'_, 'p, T, _p::Group<test_late_union::TheUnion>> {
        unsafe {
            <_p::Group<
                test_late_union::TheUnion,
            > as _p::field::FieldType>::accessor(&self.0, &TestLateUnion::THE_UNION)
        }
    }
    #[inline]
    pub fn another_union(
        &self,
    ) -> _p::Accessor<'_, 'p, T, _p::Group<test_late_union::AnotherUnion>> {
        unsafe {
            <_p::Group<
                test_late_union::AnotherUnion,
            > as _p::field::FieldType>::accessor(&self.0, &TestLateUnion::ANOTHER_UNION)
        }
    }
}
impl<'p, T: _p::rpc::Table + 'p> test_late_union::Builder<'p, T> {
    #[inline]
    pub fn foo(&mut self) -> _p::AccessorMut<'_, 'p, T, i32> {
        unsafe {
            <i32 as _p::field::FieldType>::accessor(&mut self.0, &TestLateUnion::FOO)
        }
    }
    #[inline]
    pub fn bar(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestLateUnion::BAR,
            )
        }
    }
    #[inline]
    pub fn baz(&mut self) -> _p::AccessorMut<'_, 'p, T, i16> {
        unsafe {
            <i16 as _p::field::FieldType>::accessor(&mut self.0, &TestLateUnion::BAZ)
        }
    }
    #[inline]
    pub fn the_union(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::Group<test_late_union::TheUnion>> {
        unsafe {
            <_p::Group<
                test_late_union::TheUnion,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestLateUnion::THE_UNION)
        }
    }
    #[inline]
    pub fn another_union(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::Group<test_late_union::AnotherUnion>> {
        unsafe {
            <_p::Group<
                test_late_union::AnotherUnion,
            > as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestLateUnion::ANOTHER_UNION,
            )
        }
    }
    #[inline]
    pub fn into_bar(self) -> _p::AccessorOwned<'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(self.0, &TestLateUnion::BAR)
        }
    }
    #[inline]
    pub fn into_the_union(
        self,
    ) -> _p::AccessorOwned<'p, T, _p::Group<test_late_union::TheUnion>> {
        unsafe {
            <_p::Group<
                test_late_union::TheUnion,
            > as _p::field::FieldType>::accessor(self.0, &TestLateUnion::THE_UNION)
        }
    }
    #[inline]
    pub fn into_another_union(
        self,
    ) -> _p::AccessorOwned<'p, T, _p::Group<test_late_union::AnotherUnion>> {
        unsafe {
            <_p::Group<
                test_late_union::AnotherUnion,
            > as _p::field::FieldType>::accessor(self.0, &TestLateUnion::ANOTHER_UNION)
        }
    }
}
pub mod test_late_union {
    use super::{__file, __imports, _p};
    pub type Reader<'a, T = _p::rpc::Empty> = super::TestLateUnion<
        _p::StructReader<'a, T>,
    >;
    pub type Builder<'a, T = _p::rpc::Empty> = super::TestLateUnion<
        _p::StructBuilder<'a, T>,
    >;
    #[derive(Clone)]
    pub struct TheUnion<T = _p::Family>(T);
    impl _p::ty::SchemaType for TheUnion {
        const ID: u64 = 9255601619890511993u64;
    }
    impl<T> _p::IntoFamily for TheUnion<T> {
        type Family = TheUnion;
    }
    impl<T: _p::Capable> _p::Capable for TheUnion<T> {
        type Table = T::Table;
        type Imbued = T::Imbued;
        type ImbuedWith<T2: _p::rpc::Table> = TheUnion<T::ImbuedWith<T2>>;
        #[inline]
        fn imbued(&self) -> &Self::Imbued {
            self.0.imbued()
        }
        #[inline]
        fn imbue_release<T2: _p::rpc::Table>(
            self,
            new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
        ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
            let (imbued, old) = self.0.imbue_release(new_table);
            (TheUnion(imbued), old)
        }
        #[inline]
        fn imbue_release_into<U>(
            &self,
            other: U,
        ) -> (U::ImbuedWith<Self::Table>, U::Imbued)
        where
            U: _p::Capable,
            U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
        {
            self.0.imbue_release_into(other)
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for the_union::Reader<'a, T> {
        type Ptr = _p::StructReader<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
    for the_union::Reader<'a, T> {
        #[inline]
        fn from(ptr: _p::StructReader<'a, T>) -> Self {
            TheUnion(ptr)
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<the_union::Reader<'a, T>>
    for _p::StructReader<'a, T> {
        #[inline]
        fn from(reader: the_union::Reader<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
    for the_union::Reader<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructReader<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructReader for the_union::Reader<'a, T> {}
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for the_union::Builder<'a, T> {
        type Ptr = _p::StructBuilder<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<the_union::Builder<'a, T>>
    for _p::StructBuilder<'a, T> {
        #[inline]
        fn from(reader: the_union::Builder<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
    for the_union::Builder<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
    for the_union::Builder<'a, T> {
        #[inline]
        fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
            &mut self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for the_union::Builder<'a, T> {
        unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
            Self(ptr)
        }
    }
    impl _p::StructView for TheUnion {
        type Reader<'a, T: _p::rpc::Table> = the_union::Reader<'a, T>;
        type Builder<'a, T: _p::rpc::Table> = the_union::Builder<'a, T>;
    }
    impl _p::FieldGroup for TheUnion {
        unsafe fn clear<'a, 'b, T: _p::rpc::Table>(s: &'a mut _p::StructBuilder<'b, T>) {
            s.set_field_unchecked(3usize, 0);
            <_p::Text as _p::field::FieldType>::clear(s, &TheUnion::QUX.field);
        }
    }
    impl TheUnion {
        const QUX: _p::VariantDescriptor<_p::Text> = _p::VariantDescriptor::<_p::Text> {
            variant: _p::VariantInfo {
                slot: 3u32,
                case: 0u16,
            },
            field: _p::Descriptor::<_p::Text> {
                slot: 1u32,
                default: ::core::option::Option::None,
            },
        };
        const CORGE: _p::VariantDescriptor<_p::List<i32>> = _p::VariantDescriptor::<
            _p::List<i32>,
        > {
            variant: _p::VariantInfo {
                slot: 3u32,
                case: 1u16,
            },
            field: _p::Descriptor::<_p::List<i32>> {
                slot: 1u32,
                default: ::core::option::Option::None,
            },
        };
        const GRAULT: _p::VariantDescriptor<f32> = _p::VariantDescriptor::<f32> {
            variant: _p::VariantInfo {
                slot: 3u32,
                case: 2u16,
            },
            field: _p::Descriptor::<f32> {
                slot: 2u32,
                default: 0.0f32,
            },
        };
    }
    impl<'p, T: _p::rpc::Table + 'p> the_union::Reader<'p, T> {
        #[inline]
        pub fn qux(&self) -> _p::Variant<'_, 'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::variant(&self.0, &TheUnion::QUX)
            }
        }
        #[inline]
        pub fn corge(&self) -> _p::Variant<'_, 'p, T, _p::List<i32>> {
            unsafe {
                <_p::List<
                    i32,
                > as _p::field::FieldType>::variant(&self.0, &TheUnion::CORGE)
            }
        }
        #[inline]
        pub fn grault(&self) -> _p::Variant<'_, 'p, T, f32> {
            unsafe { <f32 as _p::field::FieldType>::variant(&self.0, &TheUnion::GRAULT) }
        }
        #[inline]
        pub fn which(&self) -> Result<the_union::Which<&Self>, _p::NotInSchema> {
            unsafe { <the_union::Which<_> as _p::UnionViewer<_>>::get(self) }
        }
    }
    impl<'p, T: _p::rpc::Table + 'p> the_union::Builder<'p, T> {
        #[inline]
        pub fn qux(&mut self) -> _p::VariantMut<'_, 'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::variant(&mut self.0, &TheUnion::QUX)
            }
        }
        #[inline]
        pub fn corge(&mut self) -> _p::VariantMut<'_, 'p, T, _p::List<i32>> {
            unsafe {
                <_p::List<
                    i32,
                > as _p::field::FieldType>::variant(&mut self.0, &TheUnion::CORGE)
            }
        }
        #[inline]
        pub fn grault(&mut self) -> _p::VariantMut<'_, 'p, T, f32> {
            unsafe {
                <f32 as _p::field::FieldType>::variant(&mut self.0, &TheUnion::GRAULT)
            }
        }
        #[inline]
        pub fn into_qux(self) -> _p::VariantOwned<'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::variant(self.0, &TheUnion::QUX)
            }
        }
        #[inline]
        pub fn into_corge(self) -> _p::VariantOwned<'p, T, _p::List<i32>> {
            unsafe {
                <_p::List<
                    i32,
                > as _p::field::FieldType>::variant(self.0, &TheUnion::CORGE)
            }
        }
        #[inline]
        pub fn which(&mut self) -> Result<the_union::Which<&mut Self>, _p::NotInSchema> {
            unsafe { <the_union::Which<_> as _p::UnionViewer<_>>::get(self) }
        }
    }
    pub mod the_union {
        use super::{__file, __imports, _p};
        pub type Reader<'a, T = _p::rpc::Empty> = super::TheUnion<
            _p::StructReader<'a, T>,
        >;
        pub type Builder<'a, T = _p::rpc::Empty> = super::TheUnion<
            _p::StructBuilder<'a, T>,
        >;
        pub enum Which<T: _p::Viewable = _p::Family> {
            Qux(_p::ViewOf<T, _p::Text>),
            Corge(_p::ViewOf<T, _p::List<i32>>),
            Grault(_p::ViewOf<T, f32>),
        }
        impl<'b, 'p: 'b, T: _p::Table + 'p> _p::UnionViewer<&'b Reader<'p, T>>
        for Which {
            type View = Which<&'b Reader<'p, T>>;
            unsafe fn get(
                repr: &'b Reader<'p, T>,
            ) -> Result<Self::View, _p::NotInSchema> {
                let tag = repr.0.data_field::<u16>(3usize);
                match tag {
                    0u16 => {
                        Ok(
                            Which::Qux(
                                <_p::Text as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::TheUnion::QUX.field,
                                ),
                            ),
                        )
                    }
                    1u16 => {
                        Ok(
                            Which::Corge(
                                <_p::List<
                                    i32,
                                > as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::TheUnion::CORGE.field,
                                ),
                            ),
                        )
                    }
                    2u16 => {
                        Ok(
                            Which::Grault(
                                <f32 as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::TheUnion::GRAULT.field,
                                ),
                            ),
                        )
                    }
                    unknown => Err(_p::NotInSchema(unknown)),
                }
            }
        }
        impl<'b, 'p: 'b, T: _p::Table + 'p> _p::UnionViewer<&'b mut Builder<'p, T>>
        for Which {
            type View = Which<&'b mut Builder<'p, T>>;
            unsafe fn get(
                repr: &'b mut Builder<'p, T>,
            ) -> Result<Self::View, _p::NotInSchema> {
                let tag = repr.0.data_field::<u16>(3usize);
                match tag {
                    0u16 => {
                        Ok(
                            Which::Qux(
                                <_p::Text as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::TheUnion::QUX.field,
                                ),
                            ),
                        )
                    }
                    1u16 => {
                        Ok(
                            Which::Corge(
                                <_p::List<
                                    i32,
                                > as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::TheUnion::CORGE.field,
                                ),
                            ),
                        )
                    }
                    2u16 => {
                        Ok(
                            Which::Grault(
                                <f32 as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::TheUnion::GRAULT.field,
                                ),
                            ),
                        )
                    }
                    unknown => Err(_p::NotInSchema(unknown)),
                }
            }
        }
    }
    #[derive(Clone)]
    pub struct AnotherUnion<T = _p::Family>(T);
    impl _p::ty::SchemaType for AnotherUnion {
        const ID: u64 = 13949681613641715258u64;
    }
    impl<T> _p::IntoFamily for AnotherUnion<T> {
        type Family = AnotherUnion;
    }
    impl<T: _p::Capable> _p::Capable for AnotherUnion<T> {
        type Table = T::Table;
        type Imbued = T::Imbued;
        type ImbuedWith<T2: _p::rpc::Table> = AnotherUnion<T::ImbuedWith<T2>>;
        #[inline]
        fn imbued(&self) -> &Self::Imbued {
            self.0.imbued()
        }
        #[inline]
        fn imbue_release<T2: _p::rpc::Table>(
            self,
            new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
        ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
            let (imbued, old) = self.0.imbue_release(new_table);
            (AnotherUnion(imbued), old)
        }
        #[inline]
        fn imbue_release_into<U>(
            &self,
            other: U,
        ) -> (U::ImbuedWith<Self::Table>, U::Imbued)
        where
            U: _p::Capable,
            U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
        {
            self.0.imbue_release_into(other)
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for another_union::Reader<'a, T> {
        type Ptr = _p::StructReader<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
    for another_union::Reader<'a, T> {
        #[inline]
        fn from(ptr: _p::StructReader<'a, T>) -> Self {
            AnotherUnion(ptr)
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<another_union::Reader<'a, T>>
    for _p::StructReader<'a, T> {
        #[inline]
        fn from(reader: another_union::Reader<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
    for another_union::Reader<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructReader<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructReader for another_union::Reader<'a, T> {}
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for another_union::Builder<'a, T> {
        type Ptr = _p::StructBuilder<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<another_union::Builder<'a, T>>
    for _p::StructBuilder<'a, T> {
        #[inline]
        fn from(reader: another_union::Builder<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
    for another_union::Builder<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
    for another_union::Builder<'a, T> {
        #[inline]
        fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
            &mut self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for another_union::Builder<'a, T> {
        unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
            Self(ptr)
        }
    }
    impl _p::StructView for AnotherUnion {
        type Reader<'a, T: _p::rpc::Table> = another_union::Reader<'a, T>;
        type Builder<'a, T: _p::rpc::Table> = another_union::Builder<'a, T>;
    }
    impl _p::FieldGroup for AnotherUnion {
        unsafe fn clear<'a, 'b, T: _p::rpc::Table>(s: &'a mut _p::StructBuilder<'b, T>) {
            s.set_field_unchecked(6usize, 0);
            <_p::Text as _p::field::FieldType>::clear(s, &AnotherUnion::QUX.field);
        }
    }
    impl AnotherUnion {
        const QUX: _p::VariantDescriptor<_p::Text> = _p::VariantDescriptor::<_p::Text> {
            variant: _p::VariantInfo {
                slot: 6u32,
                case: 0u16,
            },
            field: _p::Descriptor::<_p::Text> {
                slot: 2u32,
                default: ::core::option::Option::None,
            },
        };
        const CORGE: _p::VariantDescriptor<_p::List<i32>> = _p::VariantDescriptor::<
            _p::List<i32>,
        > {
            variant: _p::VariantInfo {
                slot: 6u32,
                case: 1u16,
            },
            field: _p::Descriptor::<_p::List<i32>> {
                slot: 2u32,
                default: ::core::option::Option::None,
            },
        };
        const GRAULT: _p::VariantDescriptor<f32> = _p::VariantDescriptor::<f32> {
            variant: _p::VariantInfo {
                slot: 6u32,
                case: 2u16,
            },
            field: _p::Descriptor::<f32> {
                slot: 4u32,
                default: 0.0f32,
            },
        };
    }
    impl<'p, T: _p::rpc::Table + 'p> another_union::Reader<'p, T> {
        #[inline]
        pub fn qux(&self) -> _p::Variant<'_, 'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::variant(&self.0, &AnotherUnion::QUX)
            }
        }
        #[inline]
        pub fn corge(&self) -> _p::Variant<'_, 'p, T, _p::List<i32>> {
            unsafe {
                <_p::List<
                    i32,
                > as _p::field::FieldType>::variant(&self.0, &AnotherUnion::CORGE)
            }
        }
        #[inline]
        pub fn grault(&self) -> _p::Variant<'_, 'p, T, f32> {
            unsafe {
                <f32 as _p::field::FieldType>::variant(&self.0, &AnotherUnion::GRAULT)
            }
        }
        #[inline]
        pub fn which(&self) -> Result<another_union::Which<&Self>, _p::NotInSchema> {
            unsafe { <another_union::Which<_> as _p::UnionViewer<_>>::get(self) }
        }
    }
    impl<'p, T: _p::rpc::Table + 'p> another_union::Builder<'p, T> {
        #[inline]
        pub fn qux(&mut self) -> _p::VariantMut<'_, 'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::variant(
                    &mut self.0,
                    &AnotherUnion::QUX,
                )
            }
        }
        #[inline]
        pub fn corge(&mut self) -> _p::VariantMut<'_, 'p, T, _p::List<i32>> {
            unsafe {
                <_p::List<
                    i32,
                > as _p::field::FieldType>::variant(&mut self.0, &AnotherUnion::CORGE)
            }
        }
        #[inline]
        pub fn grault(&mut self) -> _p::VariantMut<'_, 'p, T, f32> {
            unsafe {
                <f32 as _p::field::FieldType>::variant(
                    &mut self.0,
                    &AnotherUnion::GRAULT,
                )
            }
        }
        #[inline]
        pub fn into_qux(self) -> _p::VariantOwned<'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::variant(self.0, &AnotherUnion::QUX)
            }
        }
        #[inline]
        pub fn into_corge(self) -> _p::VariantOwned<'p, T, _p::List<i32>> {
            unsafe {
                <_p::List<
                    i32,
                > as _p::field::FieldType>::variant(self.0, &AnotherUnion::CORGE)
            }
        }
        #[inline]
        pub fn which(
            &mut self,
        ) -> Result<another_union::Which<&mut Self>, _p::NotInSchema> {
            unsafe { <another_union::Which<_> as _p::UnionViewer<_>>::get(self) }
        }
    }
    pub mod another_union {
        use super::{__file, __imports, _p};
        pub type Reader<'a, T = _p::rpc::Empty> = super::AnotherUnion<
            _p::StructReader<'a, T>,
        >;
        pub type Builder<'a, T = _p::rpc::Empty> = super::AnotherUnion<
            _p::StructBuilder<'a, T>,
        >;
        pub enum Which<T: _p::Viewable = _p::Family> {
            Qux(_p::ViewOf<T, _p::Text>),
            Corge(_p::ViewOf<T, _p::List<i32>>),
            Grault(_p::ViewOf<T, f32>),
        }
        impl<'b, 'p: 'b, T: _p::Table + 'p> _p::UnionViewer<&'b Reader<'p, T>>
        for Which {
            type View = Which<&'b Reader<'p, T>>;
            unsafe fn get(
                repr: &'b Reader<'p, T>,
            ) -> Result<Self::View, _p::NotInSchema> {
                let tag = repr.0.data_field::<u16>(6usize);
                match tag {
                    0u16 => {
                        Ok(
                            Which::Qux(
                                <_p::Text as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::AnotherUnion::QUX.field,
                                ),
                            ),
                        )
                    }
                    1u16 => {
                        Ok(
                            Which::Corge(
                                <_p::List<
                                    i32,
                                > as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::AnotherUnion::CORGE.field,
                                ),
                            ),
                        )
                    }
                    2u16 => {
                        Ok(
                            Which::Grault(
                                <f32 as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::AnotherUnion::GRAULT.field,
                                ),
                            ),
                        )
                    }
                    unknown => Err(_p::NotInSchema(unknown)),
                }
            }
        }
        impl<'b, 'p: 'b, T: _p::Table + 'p> _p::UnionViewer<&'b mut Builder<'p, T>>
        for Which {
            type View = Which<&'b mut Builder<'p, T>>;
            unsafe fn get(
                repr: &'b mut Builder<'p, T>,
            ) -> Result<Self::View, _p::NotInSchema> {
                let tag = repr.0.data_field::<u16>(6usize);
                match tag {
                    0u16 => {
                        Ok(
                            Which::Qux(
                                <_p::Text as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::AnotherUnion::QUX.field,
                                ),
                            ),
                        )
                    }
                    1u16 => {
                        Ok(
                            Which::Corge(
                                <_p::List<
                                    i32,
                                > as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::AnotherUnion::CORGE.field,
                                ),
                            ),
                        )
                    }
                    2u16 => {
                        Ok(
                            Which::Grault(
                                <f32 as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::AnotherUnion::GRAULT.field,
                                ),
                            ),
                        )
                    }
                    unknown => Err(_p::NotInSchema(unknown)),
                }
            }
        }
    }
}
#[derive(Clone)]
pub struct TestOldVersion<T = _p::Family>(T);
impl _p::ty::SchemaType for TestOldVersion {
    const ID: u64 = 10786980725090540968u64;
}
impl<T> _p::IntoFamily for TestOldVersion<T> {
    type Family = TestOldVersion;
}
impl<T: _p::Capable> _p::Capable for TestOldVersion<T> {
    type Table = T::Table;
    type Imbued = T::Imbued;
    type ImbuedWith<T2: _p::rpc::Table> = TestOldVersion<T::ImbuedWith<T2>>;
    #[inline]
    fn imbued(&self) -> &Self::Imbued {
        self.0.imbued()
    }
    #[inline]
    fn imbue_release<T2: _p::rpc::Table>(
        self,
        new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
    ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
        let (imbued, old) = self.0.imbue_release(new_table);
        (TestOldVersion(imbued), old)
    }
    #[inline]
    fn imbue_release_into<U>(&self, other: U) -> (U::ImbuedWith<Self::Table>, U::Imbued)
    where
        U: _p::Capable,
        U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
    {
        self.0.imbue_release_into(other)
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_old_version::Reader<'a, T> {
    type Ptr = _p::StructReader<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
for test_old_version::Reader<'a, T> {
    #[inline]
    fn from(ptr: _p::StructReader<'a, T>) -> Self {
        TestOldVersion(ptr)
    }
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_old_version::Reader<'a, T>>
for _p::StructReader<'a, T> {
    #[inline]
    fn from(reader: test_old_version::Reader<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
for test_old_version::Reader<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructReader<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructReader for test_old_version::Reader<'a, T> {}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_old_version::Builder<'a, T> {
    type Ptr = _p::StructBuilder<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_old_version::Builder<'a, T>>
for _p::StructBuilder<'a, T> {
    #[inline]
    fn from(reader: test_old_version::Builder<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
for test_old_version::Builder<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
for test_old_version::Builder<'a, T> {
    #[inline]
    fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
        &mut self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for test_old_version::Builder<'a, T> {
    unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
        Self(ptr)
    }
}
impl _p::StructView for TestOldVersion {
    type Reader<'a, T: _p::rpc::Table> = test_old_version::Reader<'a, T>;
    type Builder<'a, T: _p::rpc::Table> = test_old_version::Builder<'a, T>;
}
impl _p::ty::Struct for TestOldVersion {
    const SIZE: _p::StructSize = _p::StructSize {
        data: 1u16,
        ptrs: 2u16,
    };
}
impl TestOldVersion {
    const OLD1: _p::Descriptor<i64> = _p::Descriptor::<i64> {
        slot: 0u32,
        default: 0i64,
    };
    const OLD2: _p::Descriptor<_p::Text> = _p::Descriptor::<_p::Text> {
        slot: 0u32,
        default: ::core::option::Option::None,
    };
    const OLD3: _p::Descriptor<_p::Struct<TestOldVersion>> = _p::Descriptor::<
        _p::Struct<TestOldVersion>,
    > {
        slot: 1u32,
        default: ::core::option::Option::None,
    };
}
impl<'p, T: _p::rpc::Table + 'p> test_old_version::Reader<'p, T> {
    #[inline]
    pub fn old1(&self) -> _p::Accessor<'_, 'p, T, i64> {
        unsafe {
            <i64 as _p::field::FieldType>::accessor(&self.0, &TestOldVersion::OLD1)
        }
    }
    #[inline]
    pub fn old2(&self) -> _p::Accessor<'_, 'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(&self.0, &TestOldVersion::OLD2)
        }
    }
    #[inline]
    pub fn old3(&self) -> _p::Accessor<'_, 'p, T, _p::Struct<TestOldVersion>> {
        unsafe {
            <_p::Struct<
                TestOldVersion,
            > as _p::field::FieldType>::accessor(&self.0, &TestOldVersion::OLD3)
        }
    }
}
impl<'p, T: _p::rpc::Table + 'p> test_old_version::Builder<'p, T> {
    #[inline]
    pub fn old1(&mut self) -> _p::AccessorMut<'_, 'p, T, i64> {
        unsafe {
            <i64 as _p::field::FieldType>::accessor(&mut self.0, &TestOldVersion::OLD1)
        }
    }
    #[inline]
    pub fn old2(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestOldVersion::OLD2,
            )
        }
    }
    #[inline]
    pub fn old3(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Struct<TestOldVersion>> {
        unsafe {
            <_p::Struct<
                TestOldVersion,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestOldVersion::OLD3)
        }
    }
    #[inline]
    pub fn into_old2(self) -> _p::AccessorOwned<'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(self.0, &TestOldVersion::OLD2)
        }
    }
    #[inline]
    pub fn into_old3(self) -> _p::AccessorOwned<'p, T, _p::Struct<TestOldVersion>> {
        unsafe {
            <_p::Struct<
                TestOldVersion,
            > as _p::field::FieldType>::accessor(self.0, &TestOldVersion::OLD3)
        }
    }
}
pub mod test_old_version {
    use super::{__file, __imports, _p};
    pub type Reader<'a, T = _p::rpc::Empty> = super::TestOldVersion<
        _p::StructReader<'a, T>,
    >;
    pub type Builder<'a, T = _p::rpc::Empty> = super::TestOldVersion<
        _p::StructBuilder<'a, T>,
    >;
}
#[derive(Clone)]
pub struct TestNewVersion<T = _p::Family>(T);
impl _p::ty::SchemaType for TestNewVersion {
    const ID: u64 = 10292794929418620131u64;
}
impl<T> _p::IntoFamily for TestNewVersion<T> {
    type Family = TestNewVersion;
}
impl<T: _p::Capable> _p::Capable for TestNewVersion<T> {
    type Table = T::Table;
    type Imbued = T::Imbued;
    type ImbuedWith<T2: _p::rpc::Table> = TestNewVersion<T::ImbuedWith<T2>>;
    #[inline]
    fn imbued(&self) -> &Self::Imbued {
        self.0.imbued()
    }
    #[inline]
    fn imbue_release<T2: _p::rpc::Table>(
        self,
        new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
    ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
        let (imbued, old) = self.0.imbue_release(new_table);
        (TestNewVersion(imbued), old)
    }
    #[inline]
    fn imbue_release_into<U>(&self, other: U) -> (U::ImbuedWith<Self::Table>, U::Imbued)
    where
        U: _p::Capable,
        U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
    {
        self.0.imbue_release_into(other)
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_new_version::Reader<'a, T> {
    type Ptr = _p::StructReader<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
for test_new_version::Reader<'a, T> {
    #[inline]
    fn from(ptr: _p::StructReader<'a, T>) -> Self {
        TestNewVersion(ptr)
    }
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_new_version::Reader<'a, T>>
for _p::StructReader<'a, T> {
    #[inline]
    fn from(reader: test_new_version::Reader<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
for test_new_version::Reader<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructReader<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructReader for test_new_version::Reader<'a, T> {}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_new_version::Builder<'a, T> {
    type Ptr = _p::StructBuilder<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_new_version::Builder<'a, T>>
for _p::StructBuilder<'a, T> {
    #[inline]
    fn from(reader: test_new_version::Builder<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
for test_new_version::Builder<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
for test_new_version::Builder<'a, T> {
    #[inline]
    fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
        &mut self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for test_new_version::Builder<'a, T> {
    unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
        Self(ptr)
    }
}
impl _p::StructView for TestNewVersion {
    type Reader<'a, T: _p::rpc::Table> = test_new_version::Reader<'a, T>;
    type Builder<'a, T: _p::rpc::Table> = test_new_version::Builder<'a, T>;
}
impl _p::ty::Struct for TestNewVersion {
    const SIZE: _p::StructSize = _p::StructSize {
        data: 2u16,
        ptrs: 3u16,
    };
}
impl TestNewVersion {
    const OLD1: _p::Descriptor<i64> = _p::Descriptor::<i64> {
        slot: 0u32,
        default: 0i64,
    };
    const OLD2: _p::Descriptor<_p::Text> = _p::Descriptor::<_p::Text> {
        slot: 0u32,
        default: ::core::option::Option::None,
    };
    const OLD3: _p::Descriptor<_p::Struct<TestNewVersion>> = _p::Descriptor::<
        _p::Struct<TestNewVersion>,
    > {
        slot: 1u32,
        default: ::core::option::Option::None,
    };
    const NEW1: _p::Descriptor<i64> = _p::Descriptor::<i64> {
        slot: 1u32,
        default: 987i64,
    };
    const NEW2: _p::Descriptor<_p::Text> = _p::Descriptor::<_p::Text> {
        slot: 2u32,
        default: ::core::option::Option::Some(_p::text::Reader::from_slice(b"baz\0")),
    };
}
impl<'p, T: _p::rpc::Table + 'p> test_new_version::Reader<'p, T> {
    #[inline]
    pub fn old1(&self) -> _p::Accessor<'_, 'p, T, i64> {
        unsafe {
            <i64 as _p::field::FieldType>::accessor(&self.0, &TestNewVersion::OLD1)
        }
    }
    #[inline]
    pub fn old2(&self) -> _p::Accessor<'_, 'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(&self.0, &TestNewVersion::OLD2)
        }
    }
    #[inline]
    pub fn old3(&self) -> _p::Accessor<'_, 'p, T, _p::Struct<TestNewVersion>> {
        unsafe {
            <_p::Struct<
                TestNewVersion,
            > as _p::field::FieldType>::accessor(&self.0, &TestNewVersion::OLD3)
        }
    }
    #[inline]
    pub fn new1(&self) -> _p::Accessor<'_, 'p, T, i64> {
        unsafe {
            <i64 as _p::field::FieldType>::accessor(&self.0, &TestNewVersion::NEW1)
        }
    }
    #[inline]
    pub fn new2(&self) -> _p::Accessor<'_, 'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(&self.0, &TestNewVersion::NEW2)
        }
    }
}
impl<'p, T: _p::rpc::Table + 'p> test_new_version::Builder<'p, T> {
    #[inline]
    pub fn old1(&mut self) -> _p::AccessorMut<'_, 'p, T, i64> {
        unsafe {
            <i64 as _p::field::FieldType>::accessor(&mut self.0, &TestNewVersion::OLD1)
        }
    }
    #[inline]
    pub fn old2(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestNewVersion::OLD2,
            )
        }
    }
    #[inline]
    pub fn old3(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Struct<TestNewVersion>> {
        unsafe {
            <_p::Struct<
                TestNewVersion,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestNewVersion::OLD3)
        }
    }
    #[inline]
    pub fn new1(&mut self) -> _p::AccessorMut<'_, 'p, T, i64> {
        unsafe {
            <i64 as _p::field::FieldType>::accessor(&mut self.0, &TestNewVersion::NEW1)
        }
    }
    #[inline]
    pub fn new2(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestNewVersion::NEW2,
            )
        }
    }
    #[inline]
    pub fn into_old2(self) -> _p::AccessorOwned<'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(self.0, &TestNewVersion::OLD2)
        }
    }
    #[inline]
    pub fn into_old3(self) -> _p::AccessorOwned<'p, T, _p::Struct<TestNewVersion>> {
        unsafe {
            <_p::Struct<
                TestNewVersion,
            > as _p::field::FieldType>::accessor(self.0, &TestNewVersion::OLD3)
        }
    }
    #[inline]
    pub fn into_new2(self) -> _p::AccessorOwned<'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(self.0, &TestNewVersion::NEW2)
        }
    }
}
pub mod test_new_version {
    use super::{__file, __imports, _p};
    pub type Reader<'a, T = _p::rpc::Empty> = super::TestNewVersion<
        _p::StructReader<'a, T>,
    >;
    pub type Builder<'a, T = _p::rpc::Empty> = super::TestNewVersion<
        _p::StructBuilder<'a, T>,
    >;
}
#[derive(Clone)]
pub struct TestOldUnionVersion<T = _p::Family>(T);
impl _p::ty::SchemaType for TestOldUnionVersion {
    const ID: u64 = 13645873259884889234u64;
}
impl<T> _p::IntoFamily for TestOldUnionVersion<T> {
    type Family = TestOldUnionVersion;
}
impl<T: _p::Capable> _p::Capable for TestOldUnionVersion<T> {
    type Table = T::Table;
    type Imbued = T::Imbued;
    type ImbuedWith<T2: _p::rpc::Table> = TestOldUnionVersion<T::ImbuedWith<T2>>;
    #[inline]
    fn imbued(&self) -> &Self::Imbued {
        self.0.imbued()
    }
    #[inline]
    fn imbue_release<T2: _p::rpc::Table>(
        self,
        new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
    ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
        let (imbued, old) = self.0.imbue_release(new_table);
        (TestOldUnionVersion(imbued), old)
    }
    #[inline]
    fn imbue_release_into<U>(&self, other: U) -> (U::ImbuedWith<Self::Table>, U::Imbued)
    where
        U: _p::Capable,
        U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
    {
        self.0.imbue_release_into(other)
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_old_union_version::Reader<'a, T> {
    type Ptr = _p::StructReader<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
for test_old_union_version::Reader<'a, T> {
    #[inline]
    fn from(ptr: _p::StructReader<'a, T>) -> Self {
        TestOldUnionVersion(ptr)
    }
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_old_union_version::Reader<'a, T>>
for _p::StructReader<'a, T> {
    #[inline]
    fn from(reader: test_old_union_version::Reader<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
for test_old_union_version::Reader<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructReader<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructReader
for test_old_union_version::Reader<'a, T> {}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_old_union_version::Builder<'a, T> {
    type Ptr = _p::StructBuilder<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_old_union_version::Builder<'a, T>>
for _p::StructBuilder<'a, T> {
    #[inline]
    fn from(reader: test_old_union_version::Builder<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
for test_old_union_version::Builder<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
for test_old_union_version::Builder<'a, T> {
    #[inline]
    fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
        &mut self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder
for test_old_union_version::Builder<'a, T> {
    unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
        Self(ptr)
    }
}
impl _p::StructView for TestOldUnionVersion {
    type Reader<'a, T: _p::rpc::Table> = test_old_union_version::Reader<'a, T>;
    type Builder<'a, T: _p::rpc::Table> = test_old_union_version::Builder<'a, T>;
}
impl _p::ty::Struct for TestOldUnionVersion {
    const SIZE: _p::StructSize = _p::StructSize {
        data: 2u16,
        ptrs: 0u16,
    };
}
impl TestOldUnionVersion {
    const A: _p::VariantDescriptor<()> = _p::VariantDescriptor::<()> {
        variant: _p::VariantInfo {
            slot: 0u32,
            case: 0u16,
        },
        field: (),
    };
    const B: _p::VariantDescriptor<u64> = _p::VariantDescriptor::<u64> {
        variant: _p::VariantInfo {
            slot: 0u32,
            case: 1u16,
        },
        field: _p::Descriptor::<u64> {
            slot: 1u32,
            default: 0u64,
        },
    };
}
impl<'p, T: _p::rpc::Table + 'p> test_old_union_version::Reader<'p, T> {
    #[inline]
    pub fn a(&self) -> _p::Variant<'_, 'p, T, ()> {
        unsafe {
            <() as _p::field::FieldType>::variant(&self.0, &TestOldUnionVersion::A)
        }
    }
    #[inline]
    pub fn b(&self) -> _p::Variant<'_, 'p, T, u64> {
        unsafe {
            <u64 as _p::field::FieldType>::variant(&self.0, &TestOldUnionVersion::B)
        }
    }
    #[inline]
    pub fn which(
        &self,
    ) -> Result<test_old_union_version::Which<&Self>, _p::NotInSchema> {
        unsafe { <test_old_union_version::Which<_> as _p::UnionViewer<_>>::get(self) }
    }
}
impl<'p, T: _p::rpc::Table + 'p> test_old_union_version::Builder<'p, T> {
    #[inline]
    pub fn a(&mut self) -> _p::VariantMut<'_, 'p, T, ()> {
        unsafe {
            <() as _p::field::FieldType>::variant(&mut self.0, &TestOldUnionVersion::A)
        }
    }
    #[inline]
    pub fn b(&mut self) -> _p::VariantMut<'_, 'p, T, u64> {
        unsafe {
            <u64 as _p::field::FieldType>::variant(&mut self.0, &TestOldUnionVersion::B)
        }
    }
    #[inline]
    pub fn which(
        &mut self,
    ) -> Result<test_old_union_version::Which<&mut Self>, _p::NotInSchema> {
        unsafe { <test_old_union_version::Which<_> as _p::UnionViewer<_>>::get(self) }
    }
}
pub mod test_old_union_version {
    use super::{__file, __imports, _p};
    pub type Reader<'a, T = _p::rpc::Empty> = super::TestOldUnionVersion<
        _p::StructReader<'a, T>,
    >;
    pub type Builder<'a, T = _p::rpc::Empty> = super::TestOldUnionVersion<
        _p::StructBuilder<'a, T>,
    >;
    pub enum Which<T: _p::Viewable = _p::Family> {
        A(_p::ViewOf<T, ()>),
        B(_p::ViewOf<T, u64>),
    }
    impl<'b, 'p: 'b, T: _p::Table + 'p> _p::UnionViewer<&'b Reader<'p, T>> for Which {
        type View = Which<&'b Reader<'p, T>>;
        unsafe fn get(repr: &'b Reader<'p, T>) -> Result<Self::View, _p::NotInSchema> {
            let tag = repr.0.data_field::<u16>(0usize);
            match tag {
                0u16 => {
                    Ok(
                        Which::A(
                            <() as _p::field::FieldType>::accessor(
                                &repr.0,
                                &super::TestOldUnionVersion::A.field,
                            ),
                        ),
                    )
                }
                1u16 => {
                    Ok(
                        Which::B(
                            <u64 as _p::field::FieldType>::accessor(
                                &repr.0,
                                &super::TestOldUnionVersion::B.field,
                            ),
                        ),
                    )
                }
                unknown => Err(_p::NotInSchema(unknown)),
            }
        }
    }
    impl<'b, 'p: 'b, T: _p::Table + 'p> _p::UnionViewer<&'b mut Builder<'p, T>>
    for Which {
        type View = Which<&'b mut Builder<'p, T>>;
        unsafe fn get(
            repr: &'b mut Builder<'p, T>,
        ) -> Result<Self::View, _p::NotInSchema> {
            let tag = repr.0.data_field::<u16>(0usize);
            match tag {
                0u16 => {
                    Ok(
                        Which::A(
                            <() as _p::field::FieldType>::accessor(
                                &mut repr.0,
                                &super::TestOldUnionVersion::A.field,
                            ),
                        ),
                    )
                }
                1u16 => {
                    Ok(
                        Which::B(
                            <u64 as _p::field::FieldType>::accessor(
                                &mut repr.0,
                                &super::TestOldUnionVersion::B.field,
                            ),
                        ),
                    )
                }
                unknown => Err(_p::NotInSchema(unknown)),
            }
        }
    }
}
#[derive(Clone)]
pub struct TestNewUnionVersion<T = _p::Family>(T);
impl _p::ty::SchemaType for TestNewUnionVersion {
    const ID: u64 = 14403854196475775275u64;
}
impl<T> _p::IntoFamily for TestNewUnionVersion<T> {
    type Family = TestNewUnionVersion;
}
impl<T: _p::Capable> _p::Capable for TestNewUnionVersion<T> {
    type Table = T::Table;
    type Imbued = T::Imbued;
    type ImbuedWith<T2: _p::rpc::Table> = TestNewUnionVersion<T::ImbuedWith<T2>>;
    #[inline]
    fn imbued(&self) -> &Self::Imbued {
        self.0.imbued()
    }
    #[inline]
    fn imbue_release<T2: _p::rpc::Table>(
        self,
        new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
    ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
        let (imbued, old) = self.0.imbue_release(new_table);
        (TestNewUnionVersion(imbued), old)
    }
    #[inline]
    fn imbue_release_into<U>(&self, other: U) -> (U::ImbuedWith<Self::Table>, U::Imbued)
    where
        U: _p::Capable,
        U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
    {
        self.0.imbue_release_into(other)
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_new_union_version::Reader<'a, T> {
    type Ptr = _p::StructReader<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
for test_new_union_version::Reader<'a, T> {
    #[inline]
    fn from(ptr: _p::StructReader<'a, T>) -> Self {
        TestNewUnionVersion(ptr)
    }
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_new_union_version::Reader<'a, T>>
for _p::StructReader<'a, T> {
    #[inline]
    fn from(reader: test_new_union_version::Reader<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
for test_new_union_version::Reader<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructReader<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructReader
for test_new_union_version::Reader<'a, T> {}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_new_union_version::Builder<'a, T> {
    type Ptr = _p::StructBuilder<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_new_union_version::Builder<'a, T>>
for _p::StructBuilder<'a, T> {
    #[inline]
    fn from(reader: test_new_union_version::Builder<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
for test_new_union_version::Builder<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
for test_new_union_version::Builder<'a, T> {
    #[inline]
    fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
        &mut self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder
for test_new_union_version::Builder<'a, T> {
    unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
        Self(ptr)
    }
}
impl _p::StructView for TestNewUnionVersion {
    type Reader<'a, T: _p::rpc::Table> = test_new_union_version::Reader<'a, T>;
    type Builder<'a, T: _p::rpc::Table> = test_new_union_version::Builder<'a, T>;
}
impl _p::ty::Struct for TestNewUnionVersion {
    const SIZE: _p::StructSize = _p::StructSize {
        data: 3u16,
        ptrs: 0u16,
    };
}
impl TestNewUnionVersion {
    const A: _p::VariantDescriptor<_p::Group<test_new_union_version::A>> = _p::VariantDescriptor::<
        _p::Group<test_new_union_version::A>,
    > {
        variant: _p::VariantInfo {
            slot: 0u32,
            case: 0u16,
        },
        field: (),
    };
    const B: _p::VariantDescriptor<u64> = _p::VariantDescriptor::<u64> {
        variant: _p::VariantInfo {
            slot: 0u32,
            case: 1u16,
        },
        field: _p::Descriptor::<u64> {
            slot: 1u32,
            default: 0u64,
        },
    };
}
impl<'p, T: _p::rpc::Table + 'p> test_new_union_version::Reader<'p, T> {
    #[inline]
    pub fn a(&self) -> _p::Variant<'_, 'p, T, _p::Group<test_new_union_version::A>> {
        unsafe {
            <_p::Group<
                test_new_union_version::A,
            > as _p::field::FieldType>::variant(&self.0, &TestNewUnionVersion::A)
        }
    }
    #[inline]
    pub fn b(&self) -> _p::Variant<'_, 'p, T, u64> {
        unsafe {
            <u64 as _p::field::FieldType>::variant(&self.0, &TestNewUnionVersion::B)
        }
    }
    #[inline]
    pub fn which(
        &self,
    ) -> Result<test_new_union_version::Which<&Self>, _p::NotInSchema> {
        unsafe { <test_new_union_version::Which<_> as _p::UnionViewer<_>>::get(self) }
    }
}
impl<'p, T: _p::rpc::Table + 'p> test_new_union_version::Builder<'p, T> {
    #[inline]
    pub fn a(
        &mut self,
    ) -> _p::VariantMut<'_, 'p, T, _p::Group<test_new_union_version::A>> {
        unsafe {
            <_p::Group<
                test_new_union_version::A,
            > as _p::field::FieldType>::variant(&mut self.0, &TestNewUnionVersion::A)
        }
    }
    #[inline]
    pub fn b(&mut self) -> _p::VariantMut<'_, 'p, T, u64> {
        unsafe {
            <u64 as _p::field::FieldType>::variant(&mut self.0, &TestNewUnionVersion::B)
        }
    }
    #[inline]
    pub fn into_a(
        self,
    ) -> _p::VariantOwned<'p, T, _p::Group<test_new_union_version::A>> {
        unsafe {
            <_p::Group<
                test_new_union_version::A,
            > as _p::field::FieldType>::variant(self.0, &TestNewUnionVersion::A)
        }
    }
    #[inline]
    pub fn which(
        &mut self,
    ) -> Result<test_new_union_version::Which<&mut Self>, _p::NotInSchema> {
        unsafe { <test_new_union_version::Which<_> as _p::UnionViewer<_>>::get(self) }
    }
}
pub mod test_new_union_version {
    use super::{__file, __imports, _p};
    pub type Reader<'a, T = _p::rpc::Empty> = super::TestNewUnionVersion<
        _p::StructReader<'a, T>,
    >;
    pub type Builder<'a, T = _p::rpc::Empty> = super::TestNewUnionVersion<
        _p::StructBuilder<'a, T>,
    >;
    pub enum Which<T: _p::Viewable = _p::Family> {
        A(_p::ViewOf<T, _p::Group<A>>),
        B(_p::ViewOf<T, u64>),
    }
    impl<'b, 'p: 'b, T: _p::Table + 'p> _p::UnionViewer<&'b Reader<'p, T>> for Which {
        type View = Which<&'b Reader<'p, T>>;
        unsafe fn get(repr: &'b Reader<'p, T>) -> Result<Self::View, _p::NotInSchema> {
            let tag = repr.0.data_field::<u16>(0usize);
            match tag {
                0u16 => {
                    Ok(
                        Which::A(
                            <_p::Group<
                                A,
                            > as _p::field::FieldType>::accessor(
                                &repr.0,
                                &super::TestNewUnionVersion::A.field,
                            ),
                        ),
                    )
                }
                1u16 => {
                    Ok(
                        Which::B(
                            <u64 as _p::field::FieldType>::accessor(
                                &repr.0,
                                &super::TestNewUnionVersion::B.field,
                            ),
                        ),
                    )
                }
                unknown => Err(_p::NotInSchema(unknown)),
            }
        }
    }
    impl<'b, 'p: 'b, T: _p::Table + 'p> _p::UnionViewer<&'b mut Builder<'p, T>>
    for Which {
        type View = Which<&'b mut Builder<'p, T>>;
        unsafe fn get(
            repr: &'b mut Builder<'p, T>,
        ) -> Result<Self::View, _p::NotInSchema> {
            let tag = repr.0.data_field::<u16>(0usize);
            match tag {
                0u16 => {
                    Ok(
                        Which::A(
                            <_p::Group<
                                A,
                            > as _p::field::FieldType>::accessor(
                                &mut repr.0,
                                &super::TestNewUnionVersion::A.field,
                            ),
                        ),
                    )
                }
                1u16 => {
                    Ok(
                        Which::B(
                            <u64 as _p::field::FieldType>::accessor(
                                &mut repr.0,
                                &super::TestNewUnionVersion::B.field,
                            ),
                        ),
                    )
                }
                unknown => Err(_p::NotInSchema(unknown)),
            }
        }
    }
    #[derive(Clone)]
    pub struct A<T = _p::Family>(T);
    impl _p::ty::SchemaType for A {
        const ID: u64 = 9665617732163419780u64;
    }
    impl<T> _p::IntoFamily for A<T> {
        type Family = A;
    }
    impl<T: _p::Capable> _p::Capable for A<T> {
        type Table = T::Table;
        type Imbued = T::Imbued;
        type ImbuedWith<T2: _p::rpc::Table> = A<T::ImbuedWith<T2>>;
        #[inline]
        fn imbued(&self) -> &Self::Imbued {
            self.0.imbued()
        }
        #[inline]
        fn imbue_release<T2: _p::rpc::Table>(
            self,
            new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
        ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
            let (imbued, old) = self.0.imbue_release(new_table);
            (A(imbued), old)
        }
        #[inline]
        fn imbue_release_into<U>(
            &self,
            other: U,
        ) -> (U::ImbuedWith<Self::Table>, U::Imbued)
        where
            U: _p::Capable,
            U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
        {
            self.0.imbue_release_into(other)
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for a::Reader<'a, T> {
        type Ptr = _p::StructReader<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
    for a::Reader<'a, T> {
        #[inline]
        fn from(ptr: _p::StructReader<'a, T>) -> Self {
            A(ptr)
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<a::Reader<'a, T>>
    for _p::StructReader<'a, T> {
        #[inline]
        fn from(reader: a::Reader<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
    for a::Reader<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructReader<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructReader for a::Reader<'a, T> {}
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for a::Builder<'a, T> {
        type Ptr = _p::StructBuilder<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<a::Builder<'a, T>>
    for _p::StructBuilder<'a, T> {
        #[inline]
        fn from(reader: a::Builder<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
    for a::Builder<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
    for a::Builder<'a, T> {
        #[inline]
        fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
            &mut self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for a::Builder<'a, T> {
        unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
            Self(ptr)
        }
    }
    impl _p::StructView for A {
        type Reader<'a, T: _p::rpc::Table> = a::Reader<'a, T>;
        type Builder<'a, T: _p::rpc::Table> = a::Builder<'a, T>;
    }
    impl _p::FieldGroup for A {
        unsafe fn clear<'a, 'b, T: _p::rpc::Table>(s: &'a mut _p::StructBuilder<'b, T>) {
            s.set_field_unchecked(4usize, 0);
            <() as _p::field::FieldType>::clear(s, &A::A0.field);
        }
    }
    impl A {
        const A0: _p::VariantDescriptor<()> = _p::VariantDescriptor::<()> {
            variant: _p::VariantInfo {
                slot: 4u32,
                case: 0u16,
            },
            field: (),
        };
        const A1: _p::VariantDescriptor<u64> = _p::VariantDescriptor::<u64> {
            variant: _p::VariantInfo {
                slot: 4u32,
                case: 1u16,
            },
            field: _p::Descriptor::<u64> {
                slot: 2u32,
                default: 0u64,
            },
        };
    }
    impl<'p, T: _p::rpc::Table + 'p> a::Reader<'p, T> {
        #[inline]
        pub fn a0(&self) -> _p::Variant<'_, 'p, T, ()> {
            unsafe { <() as _p::field::FieldType>::variant(&self.0, &A::A0) }
        }
        #[inline]
        pub fn a1(&self) -> _p::Variant<'_, 'p, T, u64> {
            unsafe { <u64 as _p::field::FieldType>::variant(&self.0, &A::A1) }
        }
        #[inline]
        pub fn which(&self) -> Result<a::Which<&Self>, _p::NotInSchema> {
            unsafe { <a::Which<_> as _p::UnionViewer<_>>::get(self) }
        }
    }
    impl<'p, T: _p::rpc::Table + 'p> a::Builder<'p, T> {
        #[inline]
        pub fn a0(&mut self) -> _p::VariantMut<'_, 'p, T, ()> {
            unsafe { <() as _p::field::FieldType>::variant(&mut self.0, &A::A0) }
        }
        #[inline]
        pub fn a1(&mut self) -> _p::VariantMut<'_, 'p, T, u64> {
            unsafe { <u64 as _p::field::FieldType>::variant(&mut self.0, &A::A1) }
        }
        #[inline]
        pub fn which(&mut self) -> Result<a::Which<&mut Self>, _p::NotInSchema> {
            unsafe { <a::Which<_> as _p::UnionViewer<_>>::get(self) }
        }
    }
    pub mod a {
        use super::{__file, __imports, _p};
        pub type Reader<'a, T = _p::rpc::Empty> = super::A<_p::StructReader<'a, T>>;
        pub type Builder<'a, T = _p::rpc::Empty> = super::A<_p::StructBuilder<'a, T>>;
        pub enum Which<T: _p::Viewable = _p::Family> {
            A0(_p::ViewOf<T, ()>),
            A1(_p::ViewOf<T, u64>),
        }
        impl<'b, 'p: 'b, T: _p::Table + 'p> _p::UnionViewer<&'b Reader<'p, T>>
        for Which {
            type View = Which<&'b Reader<'p, T>>;
            unsafe fn get(
                repr: &'b Reader<'p, T>,
            ) -> Result<Self::View, _p::NotInSchema> {
                let tag = repr.0.data_field::<u16>(4usize);
                match tag {
                    0u16 => {
                        Ok(
                            Which::A0(
                                <() as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::A::A0.field,
                                ),
                            ),
                        )
                    }
                    1u16 => {
                        Ok(
                            Which::A1(
                                <u64 as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::A::A1.field,
                                ),
                            ),
                        )
                    }
                    unknown => Err(_p::NotInSchema(unknown)),
                }
            }
        }
        impl<'b, 'p: 'b, T: _p::Table + 'p> _p::UnionViewer<&'b mut Builder<'p, T>>
        for Which {
            type View = Which<&'b mut Builder<'p, T>>;
            unsafe fn get(
                repr: &'b mut Builder<'p, T>,
            ) -> Result<Self::View, _p::NotInSchema> {
                let tag = repr.0.data_field::<u16>(4usize);
                match tag {
                    0u16 => {
                        Ok(
                            Which::A0(
                                <() as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::A::A0.field,
                                ),
                            ),
                        )
                    }
                    1u16 => {
                        Ok(
                            Which::A1(
                                <u64 as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::A::A1.field,
                                ),
                            ),
                        )
                    }
                    unknown => Err(_p::NotInSchema(unknown)),
                }
            }
        }
    }
}
#[derive(Clone)]
pub struct TestStructUnion<T = _p::Family>(T);
impl _p::ty::SchemaType for TestStructUnion {
    const ID: u64 = 18084065694535650873u64;
}
impl<T> _p::IntoFamily for TestStructUnion<T> {
    type Family = TestStructUnion;
}
impl<T: _p::Capable> _p::Capable for TestStructUnion<T> {
    type Table = T::Table;
    type Imbued = T::Imbued;
    type ImbuedWith<T2: _p::rpc::Table> = TestStructUnion<T::ImbuedWith<T2>>;
    #[inline]
    fn imbued(&self) -> &Self::Imbued {
        self.0.imbued()
    }
    #[inline]
    fn imbue_release<T2: _p::rpc::Table>(
        self,
        new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
    ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
        let (imbued, old) = self.0.imbue_release(new_table);
        (TestStructUnion(imbued), old)
    }
    #[inline]
    fn imbue_release_into<U>(&self, other: U) -> (U::ImbuedWith<Self::Table>, U::Imbued)
    where
        U: _p::Capable,
        U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
    {
        self.0.imbue_release_into(other)
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_struct_union::Reader<'a, T> {
    type Ptr = _p::StructReader<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
for test_struct_union::Reader<'a, T> {
    #[inline]
    fn from(ptr: _p::StructReader<'a, T>) -> Self {
        TestStructUnion(ptr)
    }
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_struct_union::Reader<'a, T>>
for _p::StructReader<'a, T> {
    #[inline]
    fn from(reader: test_struct_union::Reader<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
for test_struct_union::Reader<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructReader<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructReader for test_struct_union::Reader<'a, T> {}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_struct_union::Builder<'a, T> {
    type Ptr = _p::StructBuilder<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_struct_union::Builder<'a, T>>
for _p::StructBuilder<'a, T> {
    #[inline]
    fn from(reader: test_struct_union::Builder<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
for test_struct_union::Builder<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
for test_struct_union::Builder<'a, T> {
    #[inline]
    fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
        &mut self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for test_struct_union::Builder<'a, T> {
    unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
        Self(ptr)
    }
}
impl _p::StructView for TestStructUnion {
    type Reader<'a, T: _p::rpc::Table> = test_struct_union::Reader<'a, T>;
    type Builder<'a, T: _p::rpc::Table> = test_struct_union::Builder<'a, T>;
}
impl _p::ty::Struct for TestStructUnion {
    const SIZE: _p::StructSize = _p::StructSize {
        data: 1u16,
        ptrs: 1u16,
    };
}
impl TestStructUnion {
    const UN: _p::Descriptor<_p::Group<test_struct_union::Un>> = ();
}
impl<'p, T: _p::rpc::Table + 'p> test_struct_union::Reader<'p, T> {
    #[inline]
    pub fn un(&self) -> _p::Accessor<'_, 'p, T, _p::Group<test_struct_union::Un>> {
        unsafe {
            <_p::Group<
                test_struct_union::Un,
            > as _p::field::FieldType>::accessor(&self.0, &TestStructUnion::UN)
        }
    }
}
impl<'p, T: _p::rpc::Table + 'p> test_struct_union::Builder<'p, T> {
    #[inline]
    pub fn un(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::Group<test_struct_union::Un>> {
        unsafe {
            <_p::Group<
                test_struct_union::Un,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestStructUnion::UN)
        }
    }
    #[inline]
    pub fn into_un(self) -> _p::AccessorOwned<'p, T, _p::Group<test_struct_union::Un>> {
        unsafe {
            <_p::Group<
                test_struct_union::Un,
            > as _p::field::FieldType>::accessor(self.0, &TestStructUnion::UN)
        }
    }
}
pub mod test_struct_union {
    use super::{__file, __imports, _p};
    pub type Reader<'a, T = _p::rpc::Empty> = super::TestStructUnion<
        _p::StructReader<'a, T>,
    >;
    pub type Builder<'a, T = _p::rpc::Empty> = super::TestStructUnion<
        _p::StructBuilder<'a, T>,
    >;
    #[derive(Clone)]
    pub struct SomeStruct<T = _p::Family>(T);
    impl _p::ty::SchemaType for SomeStruct {
        const ID: u64 = 11362240471143747717u64;
    }
    impl<T> _p::IntoFamily for SomeStruct<T> {
        type Family = SomeStruct;
    }
    impl<T: _p::Capable> _p::Capable for SomeStruct<T> {
        type Table = T::Table;
        type Imbued = T::Imbued;
        type ImbuedWith<T2: _p::rpc::Table> = SomeStruct<T::ImbuedWith<T2>>;
        #[inline]
        fn imbued(&self) -> &Self::Imbued {
            self.0.imbued()
        }
        #[inline]
        fn imbue_release<T2: _p::rpc::Table>(
            self,
            new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
        ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
            let (imbued, old) = self.0.imbue_release(new_table);
            (SomeStruct(imbued), old)
        }
        #[inline]
        fn imbue_release_into<U>(
            &self,
            other: U,
        ) -> (U::ImbuedWith<Self::Table>, U::Imbued)
        where
            U: _p::Capable,
            U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
        {
            self.0.imbue_release_into(other)
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for some_struct::Reader<'a, T> {
        type Ptr = _p::StructReader<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
    for some_struct::Reader<'a, T> {
        #[inline]
        fn from(ptr: _p::StructReader<'a, T>) -> Self {
            SomeStruct(ptr)
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<some_struct::Reader<'a, T>>
    for _p::StructReader<'a, T> {
        #[inline]
        fn from(reader: some_struct::Reader<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
    for some_struct::Reader<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructReader<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructReader for some_struct::Reader<'a, T> {}
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for some_struct::Builder<'a, T> {
        type Ptr = _p::StructBuilder<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<some_struct::Builder<'a, T>>
    for _p::StructBuilder<'a, T> {
        #[inline]
        fn from(reader: some_struct::Builder<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
    for some_struct::Builder<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
    for some_struct::Builder<'a, T> {
        #[inline]
        fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
            &mut self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for some_struct::Builder<'a, T> {
        unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
            Self(ptr)
        }
    }
    impl _p::StructView for SomeStruct {
        type Reader<'a, T: _p::rpc::Table> = some_struct::Reader<'a, T>;
        type Builder<'a, T: _p::rpc::Table> = some_struct::Builder<'a, T>;
    }
    impl _p::ty::Struct for SomeStruct {
        const SIZE: _p::StructSize = _p::StructSize {
            data: 0u16,
            ptrs: 2u16,
        };
    }
    impl SomeStruct {
        const SOME_TEXT: _p::Descriptor<_p::Text> = _p::Descriptor::<_p::Text> {
            slot: 0u32,
            default: ::core::option::Option::None,
        };
        const MORE_TEXT: _p::Descriptor<_p::Text> = _p::Descriptor::<_p::Text> {
            slot: 1u32,
            default: ::core::option::Option::None,
        };
    }
    impl<'p, T: _p::rpc::Table + 'p> some_struct::Reader<'p, T> {
        #[inline]
        pub fn some_text(&self) -> _p::Accessor<'_, 'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::accessor(
                    &self.0,
                    &SomeStruct::SOME_TEXT,
                )
            }
        }
        #[inline]
        pub fn more_text(&self) -> _p::Accessor<'_, 'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::accessor(
                    &self.0,
                    &SomeStruct::MORE_TEXT,
                )
            }
        }
    }
    impl<'p, T: _p::rpc::Table + 'p> some_struct::Builder<'p, T> {
        #[inline]
        pub fn some_text(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::accessor(
                    &mut self.0,
                    &SomeStruct::SOME_TEXT,
                )
            }
        }
        #[inline]
        pub fn more_text(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::accessor(
                    &mut self.0,
                    &SomeStruct::MORE_TEXT,
                )
            }
        }
        #[inline]
        pub fn into_some_text(self) -> _p::AccessorOwned<'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::accessor(
                    self.0,
                    &SomeStruct::SOME_TEXT,
                )
            }
        }
        #[inline]
        pub fn into_more_text(self) -> _p::AccessorOwned<'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::accessor(
                    self.0,
                    &SomeStruct::MORE_TEXT,
                )
            }
        }
    }
    pub mod some_struct {
        use super::{__file, __imports, _p};
        pub type Reader<'a, T = _p::rpc::Empty> = super::SomeStruct<
            _p::StructReader<'a, T>,
        >;
        pub type Builder<'a, T = _p::rpc::Empty> = super::SomeStruct<
            _p::StructBuilder<'a, T>,
        >;
    }
    #[derive(Clone)]
    pub struct Un<T = _p::Family>(T);
    impl _p::ty::SchemaType for Un {
        const ID: u64 = 11038002073750690364u64;
    }
    impl<T> _p::IntoFamily for Un<T> {
        type Family = Un;
    }
    impl<T: _p::Capable> _p::Capable for Un<T> {
        type Table = T::Table;
        type Imbued = T::Imbued;
        type ImbuedWith<T2: _p::rpc::Table> = Un<T::ImbuedWith<T2>>;
        #[inline]
        fn imbued(&self) -> &Self::Imbued {
            self.0.imbued()
        }
        #[inline]
        fn imbue_release<T2: _p::rpc::Table>(
            self,
            new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
        ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
            let (imbued, old) = self.0.imbue_release(new_table);
            (Un(imbued), old)
        }
        #[inline]
        fn imbue_release_into<U>(
            &self,
            other: U,
        ) -> (U::ImbuedWith<Self::Table>, U::Imbued)
        where
            U: _p::Capable,
            U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
        {
            self.0.imbue_release_into(other)
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for un::Reader<'a, T> {
        type Ptr = _p::StructReader<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
    for un::Reader<'a, T> {
        #[inline]
        fn from(ptr: _p::StructReader<'a, T>) -> Self {
            Un(ptr)
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<un::Reader<'a, T>>
    for _p::StructReader<'a, T> {
        #[inline]
        fn from(reader: un::Reader<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
    for un::Reader<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructReader<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructReader for un::Reader<'a, T> {}
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for un::Builder<'a, T> {
        type Ptr = _p::StructBuilder<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<un::Builder<'a, T>>
    for _p::StructBuilder<'a, T> {
        #[inline]
        fn from(reader: un::Builder<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
    for un::Builder<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
    for un::Builder<'a, T> {
        #[inline]
        fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
            &mut self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for un::Builder<'a, T> {
        unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
            Self(ptr)
        }
    }
    impl _p::StructView for Un {
        type Reader<'a, T: _p::rpc::Table> = un::Reader<'a, T>;
        type Builder<'a, T: _p::rpc::Table> = un::Builder<'a, T>;
    }
    impl _p::FieldGroup for Un {
        unsafe fn clear<'a, 'b, T: _p::rpc::Table>(s: &'a mut _p::StructBuilder<'b, T>) {
            s.set_field_unchecked(0usize, 0);
            <_p::Struct<
                SomeStruct,
            > as _p::field::FieldType>::clear(s, &Un::STRUCT.field);
        }
    }
    impl Un {
        const STRUCT: _p::VariantDescriptor<_p::Struct<SomeStruct>> = _p::VariantDescriptor::<
            _p::Struct<SomeStruct>,
        > {
            variant: _p::VariantInfo {
                slot: 0u32,
                case: 0u16,
            },
            field: _p::Descriptor::<_p::Struct<SomeStruct>> {
                slot: 0u32,
                default: ::core::option::Option::None,
            },
        };
        const OBJECT: _p::VariantDescriptor<_p::Struct<super::TestAnyPointer>> = _p::VariantDescriptor::<
            _p::Struct<super::TestAnyPointer>,
        > {
            variant: _p::VariantInfo {
                slot: 0u32,
                case: 1u16,
            },
            field: _p::Descriptor::<_p::Struct<super::TestAnyPointer>> {
                slot: 0u32,
                default: ::core::option::Option::None,
            },
        };
    }
    impl<'p, T: _p::rpc::Table + 'p> un::Reader<'p, T> {
        #[inline]
        pub fn r#struct(&self) -> _p::Variant<'_, 'p, T, _p::Struct<SomeStruct>> {
            unsafe {
                <_p::Struct<
                    SomeStruct,
                > as _p::field::FieldType>::variant(&self.0, &Un::STRUCT)
            }
        }
        #[inline]
        pub fn object(
            &self,
        ) -> _p::Variant<'_, 'p, T, _p::Struct<super::TestAnyPointer>> {
            unsafe {
                <_p::Struct<
                    super::TestAnyPointer,
                > as _p::field::FieldType>::variant(&self.0, &Un::OBJECT)
            }
        }
        #[inline]
        pub fn which(&self) -> Result<un::Which<&Self>, _p::NotInSchema> {
            unsafe { <un::Which<_> as _p::UnionViewer<_>>::get(self) }
        }
    }
    impl<'p, T: _p::rpc::Table + 'p> un::Builder<'p, T> {
        #[inline]
        pub fn r#struct(&mut self) -> _p::VariantMut<'_, 'p, T, _p::Struct<SomeStruct>> {
            unsafe {
                <_p::Struct<
                    SomeStruct,
                > as _p::field::FieldType>::variant(&mut self.0, &Un::STRUCT)
            }
        }
        #[inline]
        pub fn object(
            &mut self,
        ) -> _p::VariantMut<'_, 'p, T, _p::Struct<super::TestAnyPointer>> {
            unsafe {
                <_p::Struct<
                    super::TestAnyPointer,
                > as _p::field::FieldType>::variant(&mut self.0, &Un::OBJECT)
            }
        }
        #[inline]
        pub fn into_struct(self) -> _p::VariantOwned<'p, T, _p::Struct<SomeStruct>> {
            unsafe {
                <_p::Struct<
                    SomeStruct,
                > as _p::field::FieldType>::variant(self.0, &Un::STRUCT)
            }
        }
        #[inline]
        pub fn into_object(
            self,
        ) -> _p::VariantOwned<'p, T, _p::Struct<super::TestAnyPointer>> {
            unsafe {
                <_p::Struct<
                    super::TestAnyPointer,
                > as _p::field::FieldType>::variant(self.0, &Un::OBJECT)
            }
        }
        #[inline]
        pub fn which(&mut self) -> Result<un::Which<&mut Self>, _p::NotInSchema> {
            unsafe { <un::Which<_> as _p::UnionViewer<_>>::get(self) }
        }
    }
    pub mod un {
        use super::{__file, __imports, _p};
        pub type Reader<'a, T = _p::rpc::Empty> = super::Un<_p::StructReader<'a, T>>;
        pub type Builder<'a, T = _p::rpc::Empty> = super::Un<_p::StructBuilder<'a, T>>;
        pub enum Which<T: _p::Viewable = _p::Family> {
            Struct(_p::ViewOf<T, _p::Struct<super::SomeStruct>>),
            Object(_p::ViewOf<T, _p::Struct<__file::TestAnyPointer>>),
        }
        impl<'b, 'p: 'b, T: _p::Table + 'p> _p::UnionViewer<&'b Reader<'p, T>>
        for Which {
            type View = Which<&'b Reader<'p, T>>;
            unsafe fn get(
                repr: &'b Reader<'p, T>,
            ) -> Result<Self::View, _p::NotInSchema> {
                let tag = repr.0.data_field::<u16>(0usize);
                match tag {
                    0u16 => {
                        Ok(
                            Which::Struct(
                                <_p::Struct<
                                    super::SomeStruct,
                                > as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Un::STRUCT.field,
                                ),
                            ),
                        )
                    }
                    1u16 => {
                        Ok(
                            Which::Object(
                                <_p::Struct<
                                    __file::TestAnyPointer,
                                > as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::Un::OBJECT.field,
                                ),
                            ),
                        )
                    }
                    unknown => Err(_p::NotInSchema(unknown)),
                }
            }
        }
        impl<'b, 'p: 'b, T: _p::Table + 'p> _p::UnionViewer<&'b mut Builder<'p, T>>
        for Which {
            type View = Which<&'b mut Builder<'p, T>>;
            unsafe fn get(
                repr: &'b mut Builder<'p, T>,
            ) -> Result<Self::View, _p::NotInSchema> {
                let tag = repr.0.data_field::<u16>(0usize);
                match tag {
                    0u16 => {
                        Ok(
                            Which::Struct(
                                <_p::Struct<
                                    super::SomeStruct,
                                > as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Un::STRUCT.field,
                                ),
                            ),
                        )
                    }
                    1u16 => {
                        Ok(
                            Which::Object(
                                <_p::Struct<
                                    __file::TestAnyPointer,
                                > as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::Un::OBJECT.field,
                                ),
                            ),
                        )
                    }
                    unknown => Err(_p::NotInSchema(unknown)),
                }
            }
        }
    }
}
#[derive(Clone)]
pub struct TestPrintInlineStructs<T = _p::Family>(T);
impl _p::ty::SchemaType for TestPrintInlineStructs {
    const ID: u64 = 16052121554796510268u64;
}
impl<T> _p::IntoFamily for TestPrintInlineStructs<T> {
    type Family = TestPrintInlineStructs;
}
impl<T: _p::Capable> _p::Capable for TestPrintInlineStructs<T> {
    type Table = T::Table;
    type Imbued = T::Imbued;
    type ImbuedWith<T2: _p::rpc::Table> = TestPrintInlineStructs<T::ImbuedWith<T2>>;
    #[inline]
    fn imbued(&self) -> &Self::Imbued {
        self.0.imbued()
    }
    #[inline]
    fn imbue_release<T2: _p::rpc::Table>(
        self,
        new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
    ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
        let (imbued, old) = self.0.imbue_release(new_table);
        (TestPrintInlineStructs(imbued), old)
    }
    #[inline]
    fn imbue_release_into<U>(&self, other: U) -> (U::ImbuedWith<Self::Table>, U::Imbued)
    where
        U: _p::Capable,
        U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
    {
        self.0.imbue_release_into(other)
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr
for test_print_inline_structs::Reader<'a, T> {
    type Ptr = _p::StructReader<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
for test_print_inline_structs::Reader<'a, T> {
    #[inline]
    fn from(ptr: _p::StructReader<'a, T>) -> Self {
        TestPrintInlineStructs(ptr)
    }
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_print_inline_structs::Reader<'a, T>>
for _p::StructReader<'a, T> {
    #[inline]
    fn from(reader: test_print_inline_structs::Reader<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
for test_print_inline_structs::Reader<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructReader<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructReader
for test_print_inline_structs::Reader<'a, T> {}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr
for test_print_inline_structs::Builder<'a, T> {
    type Ptr = _p::StructBuilder<'a, T>;
}
impl<
    'a,
    T: _p::rpc::Table,
> core::convert::From<test_print_inline_structs::Builder<'a, T>>
for _p::StructBuilder<'a, T> {
    #[inline]
    fn from(reader: test_print_inline_structs::Builder<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
for test_print_inline_structs::Builder<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
for test_print_inline_structs::Builder<'a, T> {
    #[inline]
    fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
        &mut self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder
for test_print_inline_structs::Builder<'a, T> {
    unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
        Self(ptr)
    }
}
impl _p::StructView for TestPrintInlineStructs {
    type Reader<'a, T: _p::rpc::Table> = test_print_inline_structs::Reader<'a, T>;
    type Builder<'a, T: _p::rpc::Table> = test_print_inline_structs::Builder<'a, T>;
}
impl _p::ty::Struct for TestPrintInlineStructs {
    const SIZE: _p::StructSize = _p::StructSize {
        data: 0u16,
        ptrs: 2u16,
    };
}
impl TestPrintInlineStructs {
    const SOME_TEXT: _p::Descriptor<_p::Text> = _p::Descriptor::<_p::Text> {
        slot: 0u32,
        default: ::core::option::Option::None,
    };
    const STRUCT_LIST: _p::Descriptor<
        _p::List<_p::Struct<test_print_inline_structs::InlineStruct>>,
    > = _p::Descriptor::<_p::List<_p::Struct<test_print_inline_structs::InlineStruct>>> {
        slot: 1u32,
        default: ::core::option::Option::None,
    };
}
impl<'p, T: _p::rpc::Table + 'p> test_print_inline_structs::Reader<'p, T> {
    #[inline]
    pub fn some_text(&self) -> _p::Accessor<'_, 'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(
                &self.0,
                &TestPrintInlineStructs::SOME_TEXT,
            )
        }
    }
    #[inline]
    pub fn struct_list(
        &self,
    ) -> _p::Accessor<
        '_,
        'p,
        T,
        _p::List<_p::Struct<test_print_inline_structs::InlineStruct>>,
    > {
        unsafe {
            <_p::List<
                _p::Struct<test_print_inline_structs::InlineStruct>,
            > as _p::field::FieldType>::accessor(
                &self.0,
                &TestPrintInlineStructs::STRUCT_LIST,
            )
        }
    }
}
impl<'p, T: _p::rpc::Table + 'p> test_print_inline_structs::Builder<'p, T> {
    #[inline]
    pub fn some_text(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestPrintInlineStructs::SOME_TEXT,
            )
        }
    }
    #[inline]
    pub fn struct_list(
        &mut self,
    ) -> _p::AccessorMut<
        '_,
        'p,
        T,
        _p::List<_p::Struct<test_print_inline_structs::InlineStruct>>,
    > {
        unsafe {
            <_p::List<
                _p::Struct<test_print_inline_structs::InlineStruct>,
            > as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestPrintInlineStructs::STRUCT_LIST,
            )
        }
    }
    #[inline]
    pub fn into_some_text(self) -> _p::AccessorOwned<'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(
                self.0,
                &TestPrintInlineStructs::SOME_TEXT,
            )
        }
    }
    #[inline]
    pub fn into_struct_list(
        self,
    ) -> _p::AccessorOwned<
        'p,
        T,
        _p::List<_p::Struct<test_print_inline_structs::InlineStruct>>,
    > {
        unsafe {
            <_p::List<
                _p::Struct<test_print_inline_structs::InlineStruct>,
            > as _p::field::FieldType>::accessor(
                self.0,
                &TestPrintInlineStructs::STRUCT_LIST,
            )
        }
    }
}
pub mod test_print_inline_structs {
    use super::{__file, __imports, _p};
    pub type Reader<'a, T = _p::rpc::Empty> = super::TestPrintInlineStructs<
        _p::StructReader<'a, T>,
    >;
    pub type Builder<'a, T = _p::rpc::Empty> = super::TestPrintInlineStructs<
        _p::StructBuilder<'a, T>,
    >;
    #[derive(Clone)]
    pub struct InlineStruct<T = _p::Family>(T);
    impl _p::ty::SchemaType for InlineStruct {
        const ID: u64 = 10252785401236871874u64;
    }
    impl<T> _p::IntoFamily for InlineStruct<T> {
        type Family = InlineStruct;
    }
    impl<T: _p::Capable> _p::Capable for InlineStruct<T> {
        type Table = T::Table;
        type Imbued = T::Imbued;
        type ImbuedWith<T2: _p::rpc::Table> = InlineStruct<T::ImbuedWith<T2>>;
        #[inline]
        fn imbued(&self) -> &Self::Imbued {
            self.0.imbued()
        }
        #[inline]
        fn imbue_release<T2: _p::rpc::Table>(
            self,
            new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
        ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
            let (imbued, old) = self.0.imbue_release(new_table);
            (InlineStruct(imbued), old)
        }
        #[inline]
        fn imbue_release_into<U>(
            &self,
            other: U,
        ) -> (U::ImbuedWith<Self::Table>, U::Imbued)
        where
            U: _p::Capable,
            U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
        {
            self.0.imbue_release_into(other)
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for inline_struct::Reader<'a, T> {
        type Ptr = _p::StructReader<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
    for inline_struct::Reader<'a, T> {
        #[inline]
        fn from(ptr: _p::StructReader<'a, T>) -> Self {
            InlineStruct(ptr)
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<inline_struct::Reader<'a, T>>
    for _p::StructReader<'a, T> {
        #[inline]
        fn from(reader: inline_struct::Reader<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
    for inline_struct::Reader<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructReader<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructReader for inline_struct::Reader<'a, T> {}
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for inline_struct::Builder<'a, T> {
        type Ptr = _p::StructBuilder<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<inline_struct::Builder<'a, T>>
    for _p::StructBuilder<'a, T> {
        #[inline]
        fn from(reader: inline_struct::Builder<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
    for inline_struct::Builder<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
    for inline_struct::Builder<'a, T> {
        #[inline]
        fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
            &mut self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for inline_struct::Builder<'a, T> {
        unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
            Self(ptr)
        }
    }
    impl _p::StructView for InlineStruct {
        type Reader<'a, T: _p::rpc::Table> = inline_struct::Reader<'a, T>;
        type Builder<'a, T: _p::rpc::Table> = inline_struct::Builder<'a, T>;
    }
    impl _p::ty::Struct for InlineStruct {
        const SIZE: _p::StructSize = _p::StructSize {
            data: 1u16,
            ptrs: 1u16,
        };
    }
    impl InlineStruct {
        const INT32_FIELD: _p::Descriptor<i32> = _p::Descriptor::<i32> {
            slot: 0u32,
            default: 0i32,
        };
        const TEXT_FIELD: _p::Descriptor<_p::Text> = _p::Descriptor::<_p::Text> {
            slot: 0u32,
            default: ::core::option::Option::None,
        };
    }
    impl<'p, T: _p::rpc::Table + 'p> inline_struct::Reader<'p, T> {
        #[inline]
        pub fn int32_field(&self) -> _p::Accessor<'_, 'p, T, i32> {
            unsafe {
                <i32 as _p::field::FieldType>::accessor(
                    &self.0,
                    &InlineStruct::INT32_FIELD,
                )
            }
        }
        #[inline]
        pub fn text_field(&self) -> _p::Accessor<'_, 'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::accessor(
                    &self.0,
                    &InlineStruct::TEXT_FIELD,
                )
            }
        }
    }
    impl<'p, T: _p::rpc::Table + 'p> inline_struct::Builder<'p, T> {
        #[inline]
        pub fn int32_field(&mut self) -> _p::AccessorMut<'_, 'p, T, i32> {
            unsafe {
                <i32 as _p::field::FieldType>::accessor(
                    &mut self.0,
                    &InlineStruct::INT32_FIELD,
                )
            }
        }
        #[inline]
        pub fn text_field(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::accessor(
                    &mut self.0,
                    &InlineStruct::TEXT_FIELD,
                )
            }
        }
        #[inline]
        pub fn into_text_field(self) -> _p::AccessorOwned<'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::accessor(
                    self.0,
                    &InlineStruct::TEXT_FIELD,
                )
            }
        }
    }
    pub mod inline_struct {
        use super::{__file, __imports, _p};
        pub type Reader<'a, T = _p::rpc::Empty> = super::InlineStruct<
            _p::StructReader<'a, T>,
        >;
        pub type Builder<'a, T = _p::rpc::Empty> = super::InlineStruct<
            _p::StructBuilder<'a, T>,
        >;
    }
}
#[derive(Clone)]
pub struct TestWholeFloatDefault<T = _p::Family>(T);
impl _p::ty::SchemaType for TestWholeFloatDefault {
    const ID: u64 = 10497843076135628848u64;
}
impl<T> _p::IntoFamily for TestWholeFloatDefault<T> {
    type Family = TestWholeFloatDefault;
}
impl<T: _p::Capable> _p::Capable for TestWholeFloatDefault<T> {
    type Table = T::Table;
    type Imbued = T::Imbued;
    type ImbuedWith<T2: _p::rpc::Table> = TestWholeFloatDefault<T::ImbuedWith<T2>>;
    #[inline]
    fn imbued(&self) -> &Self::Imbued {
        self.0.imbued()
    }
    #[inline]
    fn imbue_release<T2: _p::rpc::Table>(
        self,
        new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
    ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
        let (imbued, old) = self.0.imbue_release(new_table);
        (TestWholeFloatDefault(imbued), old)
    }
    #[inline]
    fn imbue_release_into<U>(&self, other: U) -> (U::ImbuedWith<Self::Table>, U::Imbued)
    where
        U: _p::Capable,
        U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
    {
        self.0.imbue_release_into(other)
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr
for test_whole_float_default::Reader<'a, T> {
    type Ptr = _p::StructReader<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
for test_whole_float_default::Reader<'a, T> {
    #[inline]
    fn from(ptr: _p::StructReader<'a, T>) -> Self {
        TestWholeFloatDefault(ptr)
    }
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_whole_float_default::Reader<'a, T>>
for _p::StructReader<'a, T> {
    #[inline]
    fn from(reader: test_whole_float_default::Reader<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
for test_whole_float_default::Reader<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructReader<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructReader
for test_whole_float_default::Reader<'a, T> {}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr
for test_whole_float_default::Builder<'a, T> {
    type Ptr = _p::StructBuilder<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_whole_float_default::Builder<'a, T>>
for _p::StructBuilder<'a, T> {
    #[inline]
    fn from(reader: test_whole_float_default::Builder<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
for test_whole_float_default::Builder<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
for test_whole_float_default::Builder<'a, T> {
    #[inline]
    fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
        &mut self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder
for test_whole_float_default::Builder<'a, T> {
    unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
        Self(ptr)
    }
}
impl _p::StructView for TestWholeFloatDefault {
    type Reader<'a, T: _p::rpc::Table> = test_whole_float_default::Reader<'a, T>;
    type Builder<'a, T: _p::rpc::Table> = test_whole_float_default::Builder<'a, T>;
}
impl _p::ty::Struct for TestWholeFloatDefault {
    const SIZE: _p::StructSize = _p::StructSize {
        data: 1u16,
        ptrs: 0u16,
    };
}
impl TestWholeFloatDefault {
    const FIELD: _p::Descriptor<f32> = _p::Descriptor::<f32> {
        slot: 0u32,
        default: 123f32,
    };
    const BIG_FIELD: _p::Descriptor<f32> = _p::Descriptor::<f32> {
        slot: 1u32,
        default: 2000000000000000000000000000000f32,
    };
}
impl<'p, T: _p::rpc::Table + 'p> test_whole_float_default::Reader<'p, T> {
    #[inline]
    pub fn field(&self) -> _p::Accessor<'_, 'p, T, f32> {
        unsafe {
            <f32 as _p::field::FieldType>::accessor(
                &self.0,
                &TestWholeFloatDefault::FIELD,
            )
        }
    }
    #[inline]
    pub fn big_field(&self) -> _p::Accessor<'_, 'p, T, f32> {
        unsafe {
            <f32 as _p::field::FieldType>::accessor(
                &self.0,
                &TestWholeFloatDefault::BIG_FIELD,
            )
        }
    }
}
impl<'p, T: _p::rpc::Table + 'p> test_whole_float_default::Builder<'p, T> {
    #[inline]
    pub fn field(&mut self) -> _p::AccessorMut<'_, 'p, T, f32> {
        unsafe {
            <f32 as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestWholeFloatDefault::FIELD,
            )
        }
    }
    #[inline]
    pub fn big_field(&mut self) -> _p::AccessorMut<'_, 'p, T, f32> {
        unsafe {
            <f32 as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestWholeFloatDefault::BIG_FIELD,
            )
        }
    }
}
pub mod test_whole_float_default {
    use super::{__file, __imports, _p};
    pub type Reader<'a, T = _p::rpc::Empty> = super::TestWholeFloatDefault<
        _p::StructReader<'a, T>,
    >;
    pub type Builder<'a, T = _p::rpc::Empty> = super::TestWholeFloatDefault<
        _p::StructBuilder<'a, T>,
    >;
    pub const CONSTANT: f32 = 456f32;
    pub const BIG_CONSTANT: f32 = 4000000000000000000000000000000f32;
}
#[derive(Clone)]
pub struct TestGenerics<T = _p::Family>(T);
impl _p::ty::SchemaType for TestGenerics {
    const ID: u64 = 11338811349910758123u64;
}
impl<T> _p::IntoFamily for TestGenerics<T> {
    type Family = TestGenerics;
}
impl<T: _p::Capable> _p::Capable for TestGenerics<T> {
    type Table = T::Table;
    type Imbued = T::Imbued;
    type ImbuedWith<T2: _p::rpc::Table> = TestGenerics<T::ImbuedWith<T2>>;
    #[inline]
    fn imbued(&self) -> &Self::Imbued {
        self.0.imbued()
    }
    #[inline]
    fn imbue_release<T2: _p::rpc::Table>(
        self,
        new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
    ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
        let (imbued, old) = self.0.imbue_release(new_table);
        (TestGenerics(imbued), old)
    }
    #[inline]
    fn imbue_release_into<U>(&self, other: U) -> (U::ImbuedWith<Self::Table>, U::Imbued)
    where
        U: _p::Capable,
        U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
    {
        self.0.imbue_release_into(other)
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_generics::Reader<'a, T> {
    type Ptr = _p::StructReader<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
for test_generics::Reader<'a, T> {
    #[inline]
    fn from(ptr: _p::StructReader<'a, T>) -> Self {
        TestGenerics(ptr)
    }
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_generics::Reader<'a, T>>
for _p::StructReader<'a, T> {
    #[inline]
    fn from(reader: test_generics::Reader<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
for test_generics::Reader<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructReader<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructReader for test_generics::Reader<'a, T> {}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_generics::Builder<'a, T> {
    type Ptr = _p::StructBuilder<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_generics::Builder<'a, T>>
for _p::StructBuilder<'a, T> {
    #[inline]
    fn from(reader: test_generics::Builder<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
for test_generics::Builder<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
for test_generics::Builder<'a, T> {
    #[inline]
    fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
        &mut self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for test_generics::Builder<'a, T> {
    unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
        Self(ptr)
    }
}
impl _p::StructView for TestGenerics {
    type Reader<'a, T: _p::rpc::Table> = test_generics::Reader<'a, T>;
    type Builder<'a, T: _p::rpc::Table> = test_generics::Builder<'a, T>;
}
impl _p::ty::Struct for TestGenerics {
    const SIZE: _p::StructSize = _p::StructSize {
        data: 1u16,
        ptrs: 3u16,
    };
}
impl TestGenerics {
    const FOO: _p::Descriptor<_p::AnyPtr> = _p::Descriptor::<_p::AnyPtr> {
        slot: 0u32,
        default: ::core::option::Option::None,
    };
    const REV: _p::Descriptor<_p::Struct<TestGenerics>> = _p::Descriptor::<
        _p::Struct<TestGenerics>,
    > {
        slot: 1u32,
        default: ::core::option::Option::None,
    };
    const LIST: _p::Descriptor<_p::List<_p::Struct<test_generics::Inner>>> = _p::Descriptor::<
        _p::List<_p::Struct<test_generics::Inner>>,
    > {
        slot: 2u32,
        default: ::core::option::Option::None,
    };
    const UV: _p::VariantDescriptor<()> = _p::VariantDescriptor::<()> {
        variant: _p::VariantInfo {
            slot: 0u32,
            case: 0u16,
        },
        field: (),
    };
    const UG: _p::VariantDescriptor<_p::Group<test_generics::Ug>> = _p::VariantDescriptor::<
        _p::Group<test_generics::Ug>,
    > {
        variant: _p::VariantInfo {
            slot: 0u32,
            case: 1u16,
        },
        field: (),
    };
}
impl<'p, T: _p::rpc::Table + 'p> test_generics::Reader<'p, T> {
    #[inline]
    pub fn foo(&self) -> _p::Accessor<'_, 'p, T, _p::AnyPtr> {
        unsafe {
            <_p::AnyPtr as _p::field::FieldType>::accessor(&self.0, &TestGenerics::FOO)
        }
    }
    #[inline]
    pub fn rev(&self) -> _p::Accessor<'_, 'p, T, _p::Struct<TestGenerics>> {
        unsafe {
            <_p::Struct<
                TestGenerics,
            > as _p::field::FieldType>::accessor(&self.0, &TestGenerics::REV)
        }
    }
    #[inline]
    pub fn list(
        &self,
    ) -> _p::Accessor<'_, 'p, T, _p::List<_p::Struct<test_generics::Inner>>> {
        unsafe {
            <_p::List<
                _p::Struct<test_generics::Inner>,
            > as _p::field::FieldType>::accessor(&self.0, &TestGenerics::LIST)
        }
    }
    #[inline]
    pub fn uv(&self) -> _p::Variant<'_, 'p, T, ()> {
        unsafe { <() as _p::field::FieldType>::variant(&self.0, &TestGenerics::UV) }
    }
    #[inline]
    pub fn ug(&self) -> _p::Variant<'_, 'p, T, _p::Group<test_generics::Ug>> {
        unsafe {
            <_p::Group<
                test_generics::Ug,
            > as _p::field::FieldType>::variant(&self.0, &TestGenerics::UG)
        }
    }
    #[inline]
    pub fn which(&self) -> Result<test_generics::Which<&Self>, _p::NotInSchema> {
        unsafe { <test_generics::Which<_> as _p::UnionViewer<_>>::get(self) }
    }
}
impl<'p, T: _p::rpc::Table + 'p> test_generics::Builder<'p, T> {
    #[inline]
    pub fn foo(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::AnyPtr> {
        unsafe {
            <_p::AnyPtr as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestGenerics::FOO,
            )
        }
    }
    #[inline]
    pub fn rev(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Struct<TestGenerics>> {
        unsafe {
            <_p::Struct<
                TestGenerics,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestGenerics::REV)
        }
    }
    #[inline]
    pub fn list(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::List<_p::Struct<test_generics::Inner>>> {
        unsafe {
            <_p::List<
                _p::Struct<test_generics::Inner>,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestGenerics::LIST)
        }
    }
    #[inline]
    pub fn uv(&mut self) -> _p::VariantMut<'_, 'p, T, ()> {
        unsafe { <() as _p::field::FieldType>::variant(&mut self.0, &TestGenerics::UV) }
    }
    #[inline]
    pub fn ug(&mut self) -> _p::VariantMut<'_, 'p, T, _p::Group<test_generics::Ug>> {
        unsafe {
            <_p::Group<
                test_generics::Ug,
            > as _p::field::FieldType>::variant(&mut self.0, &TestGenerics::UG)
        }
    }
    #[inline]
    pub fn into_foo(self) -> _p::AccessorOwned<'p, T, _p::AnyPtr> {
        unsafe {
            <_p::AnyPtr as _p::field::FieldType>::accessor(self.0, &TestGenerics::FOO)
        }
    }
    #[inline]
    pub fn into_rev(self) -> _p::AccessorOwned<'p, T, _p::Struct<TestGenerics>> {
        unsafe {
            <_p::Struct<
                TestGenerics,
            > as _p::field::FieldType>::accessor(self.0, &TestGenerics::REV)
        }
    }
    #[inline]
    pub fn into_list(
        self,
    ) -> _p::AccessorOwned<'p, T, _p::List<_p::Struct<test_generics::Inner>>> {
        unsafe {
            <_p::List<
                _p::Struct<test_generics::Inner>,
            > as _p::field::FieldType>::accessor(self.0, &TestGenerics::LIST)
        }
    }
    #[inline]
    pub fn into_ug(self) -> _p::VariantOwned<'p, T, _p::Group<test_generics::Ug>> {
        unsafe {
            <_p::Group<
                test_generics::Ug,
            > as _p::field::FieldType>::variant(self.0, &TestGenerics::UG)
        }
    }
    #[inline]
    pub fn which(&mut self) -> Result<test_generics::Which<&mut Self>, _p::NotInSchema> {
        unsafe { <test_generics::Which<_> as _p::UnionViewer<_>>::get(self) }
    }
}
pub mod test_generics {
    use super::{__file, __imports, _p};
    pub type Reader<'a, T = _p::rpc::Empty> = super::TestGenerics<
        _p::StructReader<'a, T>,
    >;
    pub type Builder<'a, T = _p::rpc::Empty> = super::TestGenerics<
        _p::StructBuilder<'a, T>,
    >;
    pub enum Which<T: _p::Viewable = _p::Family> {
        Uv(_p::ViewOf<T, ()>),
        Ug(_p::ViewOf<T, _p::Group<Ug>>),
    }
    impl<'b, 'p: 'b, T: _p::Table + 'p> _p::UnionViewer<&'b Reader<'p, T>> for Which {
        type View = Which<&'b Reader<'p, T>>;
        unsafe fn get(repr: &'b Reader<'p, T>) -> Result<Self::View, _p::NotInSchema> {
            let tag = repr.0.data_field::<u16>(0usize);
            match tag {
                0u16 => {
                    Ok(
                        Which::Uv(
                            <() as _p::field::FieldType>::accessor(
                                &repr.0,
                                &super::TestGenerics::UV.field,
                            ),
                        ),
                    )
                }
                1u16 => {
                    Ok(
                        Which::Ug(
                            <_p::Group<
                                Ug,
                            > as _p::field::FieldType>::accessor(
                                &repr.0,
                                &super::TestGenerics::UG.field,
                            ),
                        ),
                    )
                }
                unknown => Err(_p::NotInSchema(unknown)),
            }
        }
    }
    impl<'b, 'p: 'b, T: _p::Table + 'p> _p::UnionViewer<&'b mut Builder<'p, T>>
    for Which {
        type View = Which<&'b mut Builder<'p, T>>;
        unsafe fn get(
            repr: &'b mut Builder<'p, T>,
        ) -> Result<Self::View, _p::NotInSchema> {
            let tag = repr.0.data_field::<u16>(0usize);
            match tag {
                0u16 => {
                    Ok(
                        Which::Uv(
                            <() as _p::field::FieldType>::accessor(
                                &mut repr.0,
                                &super::TestGenerics::UV.field,
                            ),
                        ),
                    )
                }
                1u16 => {
                    Ok(
                        Which::Ug(
                            <_p::Group<
                                Ug,
                            > as _p::field::FieldType>::accessor(
                                &mut repr.0,
                                &super::TestGenerics::UG.field,
                            ),
                        ),
                    )
                }
                unknown => Err(_p::NotInSchema(unknown)),
            }
        }
    }
    #[derive(Clone)]
    pub struct Inner<T = _p::Family>(T);
    impl _p::ty::SchemaType for Inner {
        const ID: u64 = 17773527472803523699u64;
    }
    impl<T> _p::IntoFamily for Inner<T> {
        type Family = Inner;
    }
    impl<T: _p::Capable> _p::Capable for Inner<T> {
        type Table = T::Table;
        type Imbued = T::Imbued;
        type ImbuedWith<T2: _p::rpc::Table> = Inner<T::ImbuedWith<T2>>;
        #[inline]
        fn imbued(&self) -> &Self::Imbued {
            self.0.imbued()
        }
        #[inline]
        fn imbue_release<T2: _p::rpc::Table>(
            self,
            new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
        ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
            let (imbued, old) = self.0.imbue_release(new_table);
            (Inner(imbued), old)
        }
        #[inline]
        fn imbue_release_into<U>(
            &self,
            other: U,
        ) -> (U::ImbuedWith<Self::Table>, U::Imbued)
        where
            U: _p::Capable,
            U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
        {
            self.0.imbue_release_into(other)
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for inner::Reader<'a, T> {
        type Ptr = _p::StructReader<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
    for inner::Reader<'a, T> {
        #[inline]
        fn from(ptr: _p::StructReader<'a, T>) -> Self {
            Inner(ptr)
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<inner::Reader<'a, T>>
    for _p::StructReader<'a, T> {
        #[inline]
        fn from(reader: inner::Reader<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
    for inner::Reader<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructReader<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructReader for inner::Reader<'a, T> {}
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for inner::Builder<'a, T> {
        type Ptr = _p::StructBuilder<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<inner::Builder<'a, T>>
    for _p::StructBuilder<'a, T> {
        #[inline]
        fn from(reader: inner::Builder<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
    for inner::Builder<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
    for inner::Builder<'a, T> {
        #[inline]
        fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
            &mut self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for inner::Builder<'a, T> {
        unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
            Self(ptr)
        }
    }
    impl _p::StructView for Inner {
        type Reader<'a, T: _p::rpc::Table> = inner::Reader<'a, T>;
        type Builder<'a, T: _p::rpc::Table> = inner::Builder<'a, T>;
    }
    impl _p::ty::Struct for Inner {
        const SIZE: _p::StructSize = _p::StructSize {
            data: 0u16,
            ptrs: 2u16,
        };
    }
    impl Inner {
        const FOO: _p::Descriptor<_p::AnyPtr> = _p::Descriptor::<_p::AnyPtr> {
            slot: 0u32,
            default: ::core::option::Option::None,
        };
        const BAR: _p::Descriptor<_p::AnyPtr> = _p::Descriptor::<_p::AnyPtr> {
            slot: 1u32,
            default: ::core::option::Option::None,
        };
    }
    impl<'p, T: _p::rpc::Table + 'p> inner::Reader<'p, T> {
        #[inline]
        pub fn foo(&self) -> _p::Accessor<'_, 'p, T, _p::AnyPtr> {
            unsafe {
                <_p::AnyPtr as _p::field::FieldType>::accessor(&self.0, &Inner::FOO)
            }
        }
        #[inline]
        pub fn bar(&self) -> _p::Accessor<'_, 'p, T, _p::AnyPtr> {
            unsafe {
                <_p::AnyPtr as _p::field::FieldType>::accessor(&self.0, &Inner::BAR)
            }
        }
    }
    impl<'p, T: _p::rpc::Table + 'p> inner::Builder<'p, T> {
        #[inline]
        pub fn foo(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::AnyPtr> {
            unsafe {
                <_p::AnyPtr as _p::field::FieldType>::accessor(&mut self.0, &Inner::FOO)
            }
        }
        #[inline]
        pub fn bar(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::AnyPtr> {
            unsafe {
                <_p::AnyPtr as _p::field::FieldType>::accessor(&mut self.0, &Inner::BAR)
            }
        }
        #[inline]
        pub fn into_foo(self) -> _p::AccessorOwned<'p, T, _p::AnyPtr> {
            unsafe {
                <_p::AnyPtr as _p::field::FieldType>::accessor(self.0, &Inner::FOO)
            }
        }
        #[inline]
        pub fn into_bar(self) -> _p::AccessorOwned<'p, T, _p::AnyPtr> {
            unsafe {
                <_p::AnyPtr as _p::field::FieldType>::accessor(self.0, &Inner::BAR)
            }
        }
    }
    pub mod inner {
        use super::{__file, __imports, _p};
        pub type Reader<'a, T = _p::rpc::Empty> = super::Inner<_p::StructReader<'a, T>>;
        pub type Builder<'a, T = _p::rpc::Empty> = super::Inner<
            _p::StructBuilder<'a, T>,
        >;
    }
    #[derive(Clone)]
    pub struct Inner2<T = _p::Family>(T);
    impl _p::ty::SchemaType for Inner2 {
        const ID: u64 = 12225938941820720181u64;
    }
    impl<T> _p::IntoFamily for Inner2<T> {
        type Family = Inner2;
    }
    impl<T: _p::Capable> _p::Capable for Inner2<T> {
        type Table = T::Table;
        type Imbued = T::Imbued;
        type ImbuedWith<T2: _p::rpc::Table> = Inner2<T::ImbuedWith<T2>>;
        #[inline]
        fn imbued(&self) -> &Self::Imbued {
            self.0.imbued()
        }
        #[inline]
        fn imbue_release<T2: _p::rpc::Table>(
            self,
            new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
        ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
            let (imbued, old) = self.0.imbue_release(new_table);
            (Inner2(imbued), old)
        }
        #[inline]
        fn imbue_release_into<U>(
            &self,
            other: U,
        ) -> (U::ImbuedWith<Self::Table>, U::Imbued)
        where
            U: _p::Capable,
            U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
        {
            self.0.imbue_release_into(other)
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for inner2::Reader<'a, T> {
        type Ptr = _p::StructReader<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
    for inner2::Reader<'a, T> {
        #[inline]
        fn from(ptr: _p::StructReader<'a, T>) -> Self {
            Inner2(ptr)
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<inner2::Reader<'a, T>>
    for _p::StructReader<'a, T> {
        #[inline]
        fn from(reader: inner2::Reader<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
    for inner2::Reader<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructReader<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructReader for inner2::Reader<'a, T> {}
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for inner2::Builder<'a, T> {
        type Ptr = _p::StructBuilder<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<inner2::Builder<'a, T>>
    for _p::StructBuilder<'a, T> {
        #[inline]
        fn from(reader: inner2::Builder<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
    for inner2::Builder<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
    for inner2::Builder<'a, T> {
        #[inline]
        fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
            &mut self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for inner2::Builder<'a, T> {
        unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
            Self(ptr)
        }
    }
    impl _p::StructView for Inner2 {
        type Reader<'a, T: _p::rpc::Table> = inner2::Reader<'a, T>;
        type Builder<'a, T: _p::rpc::Table> = inner2::Builder<'a, T>;
    }
    impl _p::ty::Struct for Inner2 {
        const SIZE: _p::StructSize = _p::StructSize {
            data: 0u16,
            ptrs: 4u16,
        };
    }
    impl Inner2 {
        const BAR: _p::Descriptor<_p::AnyPtr> = _p::Descriptor::<_p::AnyPtr> {
            slot: 0u32,
            default: ::core::option::Option::None,
        };
        const BAZ: _p::Descriptor<_p::AnyPtr> = _p::Descriptor::<_p::AnyPtr> {
            slot: 1u32,
            default: ::core::option::Option::None,
        };
        const INNER_BOUND: _p::Descriptor<_p::Struct<Inner>> = _p::Descriptor::<
            _p::Struct<Inner>,
        > {
            slot: 2u32,
            default: ::core::option::Option::None,
        };
        const INNER_UNBOUND: _p::Descriptor<_p::Struct<Inner>> = _p::Descriptor::<
            _p::Struct<Inner>,
        > {
            slot: 3u32,
            default: ::core::option::Option::None,
        };
    }
    impl<'p, T: _p::rpc::Table + 'p> inner2::Reader<'p, T> {
        #[inline]
        pub fn bar(&self) -> _p::Accessor<'_, 'p, T, _p::AnyPtr> {
            unsafe {
                <_p::AnyPtr as _p::field::FieldType>::accessor(&self.0, &Inner2::BAR)
            }
        }
        #[inline]
        pub fn baz(&self) -> _p::Accessor<'_, 'p, T, _p::AnyPtr> {
            unsafe {
                <_p::AnyPtr as _p::field::FieldType>::accessor(&self.0, &Inner2::BAZ)
            }
        }
        #[inline]
        pub fn inner_bound(&self) -> _p::Accessor<'_, 'p, T, _p::Struct<Inner>> {
            unsafe {
                <_p::Struct<
                    Inner,
                > as _p::field::FieldType>::accessor(&self.0, &Inner2::INNER_BOUND)
            }
        }
        #[inline]
        pub fn inner_unbound(&self) -> _p::Accessor<'_, 'p, T, _p::Struct<Inner>> {
            unsafe {
                <_p::Struct<
                    Inner,
                > as _p::field::FieldType>::accessor(&self.0, &Inner2::INNER_UNBOUND)
            }
        }
    }
    impl<'p, T: _p::rpc::Table + 'p> inner2::Builder<'p, T> {
        #[inline]
        pub fn bar(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::AnyPtr> {
            unsafe {
                <_p::AnyPtr as _p::field::FieldType>::accessor(&mut self.0, &Inner2::BAR)
            }
        }
        #[inline]
        pub fn baz(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::AnyPtr> {
            unsafe {
                <_p::AnyPtr as _p::field::FieldType>::accessor(&mut self.0, &Inner2::BAZ)
            }
        }
        #[inline]
        pub fn inner_bound(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Struct<Inner>> {
            unsafe {
                <_p::Struct<
                    Inner,
                > as _p::field::FieldType>::accessor(&mut self.0, &Inner2::INNER_BOUND)
            }
        }
        #[inline]
        pub fn inner_unbound(
            &mut self,
        ) -> _p::AccessorMut<'_, 'p, T, _p::Struct<Inner>> {
            unsafe {
                <_p::Struct<
                    Inner,
                > as _p::field::FieldType>::accessor(&mut self.0, &Inner2::INNER_UNBOUND)
            }
        }
        #[inline]
        pub fn into_bar(self) -> _p::AccessorOwned<'p, T, _p::AnyPtr> {
            unsafe {
                <_p::AnyPtr as _p::field::FieldType>::accessor(self.0, &Inner2::BAR)
            }
        }
        #[inline]
        pub fn into_baz(self) -> _p::AccessorOwned<'p, T, _p::AnyPtr> {
            unsafe {
                <_p::AnyPtr as _p::field::FieldType>::accessor(self.0, &Inner2::BAZ)
            }
        }
        #[inline]
        pub fn into_inner_bound(self) -> _p::AccessorOwned<'p, T, _p::Struct<Inner>> {
            unsafe {
                <_p::Struct<
                    Inner,
                > as _p::field::FieldType>::accessor(self.0, &Inner2::INNER_BOUND)
            }
        }
        #[inline]
        pub fn into_inner_unbound(self) -> _p::AccessorOwned<'p, T, _p::Struct<Inner>> {
            unsafe {
                <_p::Struct<
                    Inner,
                > as _p::field::FieldType>::accessor(self.0, &Inner2::INNER_UNBOUND)
            }
        }
    }
    pub mod inner2 {
        use super::{__file, __imports, _p};
        pub type Reader<'a, T = _p::rpc::Empty> = super::Inner2<_p::StructReader<'a, T>>;
        pub type Builder<'a, T = _p::rpc::Empty> = super::Inner2<
            _p::StructBuilder<'a, T>,
        >;
        #[derive(Clone)]
        pub struct DeepNest<T = _p::Family>(T);
        impl _p::ty::SchemaType for DeepNest {
            const ID: u64 = 13159661719685629683u64;
        }
        impl<T> _p::IntoFamily for DeepNest<T> {
            type Family = DeepNest;
        }
        impl<T: _p::Capable> _p::Capable for DeepNest<T> {
            type Table = T::Table;
            type Imbued = T::Imbued;
            type ImbuedWith<T2: _p::rpc::Table> = DeepNest<T::ImbuedWith<T2>>;
            #[inline]
            fn imbued(&self) -> &Self::Imbued {
                self.0.imbued()
            }
            #[inline]
            fn imbue_release<T2: _p::rpc::Table>(
                self,
                new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
            ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
                let (imbued, old) = self.0.imbue_release(new_table);
                (DeepNest(imbued), old)
            }
            #[inline]
            fn imbue_release_into<U>(
                &self,
                other: U,
            ) -> (U::ImbuedWith<Self::Table>, U::Imbued)
            where
                U: _p::Capable,
                U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
            {
                self.0.imbue_release_into(other)
            }
        }
        impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for deep_nest::Reader<'a, T> {
            type Ptr = _p::StructReader<'a, T>;
        }
        impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
        for deep_nest::Reader<'a, T> {
            #[inline]
            fn from(ptr: _p::StructReader<'a, T>) -> Self {
                DeepNest(ptr)
            }
        }
        impl<'a, T: _p::rpc::Table> core::convert::From<deep_nest::Reader<'a, T>>
        for _p::StructReader<'a, T> {
            #[inline]
            fn from(reader: deep_nest::Reader<'a, T>) -> Self {
                reader.0
            }
        }
        impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
        for deep_nest::Reader<'a, T> {
            #[inline]
            fn as_ref(&self) -> &_p::StructReader<'a, T> {
                &self.0
            }
        }
        impl<'a, T: _p::rpc::Table> _p::ty::StructReader for deep_nest::Reader<'a, T> {}
        impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for deep_nest::Builder<'a, T> {
            type Ptr = _p::StructBuilder<'a, T>;
        }
        impl<'a, T: _p::rpc::Table> core::convert::From<deep_nest::Builder<'a, T>>
        for _p::StructBuilder<'a, T> {
            #[inline]
            fn from(reader: deep_nest::Builder<'a, T>) -> Self {
                reader.0
            }
        }
        impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
        for deep_nest::Builder<'a, T> {
            #[inline]
            fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
                &self.0
            }
        }
        impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
        for deep_nest::Builder<'a, T> {
            #[inline]
            fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
                &mut self.0
            }
        }
        impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for deep_nest::Builder<'a, T> {
            unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
                Self(ptr)
            }
        }
        impl _p::StructView for DeepNest {
            type Reader<'a, T: _p::rpc::Table> = deep_nest::Reader<'a, T>;
            type Builder<'a, T: _p::rpc::Table> = deep_nest::Builder<'a, T>;
        }
        impl _p::ty::Struct for DeepNest {
            const SIZE: _p::StructSize = _p::StructSize {
                data: 0u16,
                ptrs: 4u16,
            };
        }
        impl DeepNest {
            const FOO: _p::Descriptor<_p::AnyPtr> = _p::Descriptor::<_p::AnyPtr> {
                slot: 0u32,
                default: ::core::option::Option::None,
            };
            const BAR: _p::Descriptor<_p::AnyPtr> = _p::Descriptor::<_p::AnyPtr> {
                slot: 1u32,
                default: ::core::option::Option::None,
            };
            const BAZ: _p::Descriptor<_p::AnyPtr> = _p::Descriptor::<_p::AnyPtr> {
                slot: 2u32,
                default: ::core::option::Option::None,
            };
            const QUX: _p::Descriptor<_p::AnyPtr> = _p::Descriptor::<_p::AnyPtr> {
                slot: 3u32,
                default: ::core::option::Option::None,
            };
        }
        impl<'p, T: _p::rpc::Table + 'p> deep_nest::Reader<'p, T> {
            #[inline]
            pub fn foo(&self) -> _p::Accessor<'_, 'p, T, _p::AnyPtr> {
                unsafe {
                    <_p::AnyPtr as _p::field::FieldType>::accessor(
                        &self.0,
                        &DeepNest::FOO,
                    )
                }
            }
            #[inline]
            pub fn bar(&self) -> _p::Accessor<'_, 'p, T, _p::AnyPtr> {
                unsafe {
                    <_p::AnyPtr as _p::field::FieldType>::accessor(
                        &self.0,
                        &DeepNest::BAR,
                    )
                }
            }
            #[inline]
            pub fn baz(&self) -> _p::Accessor<'_, 'p, T, _p::AnyPtr> {
                unsafe {
                    <_p::AnyPtr as _p::field::FieldType>::accessor(
                        &self.0,
                        &DeepNest::BAZ,
                    )
                }
            }
            #[inline]
            pub fn qux(&self) -> _p::Accessor<'_, 'p, T, _p::AnyPtr> {
                unsafe {
                    <_p::AnyPtr as _p::field::FieldType>::accessor(
                        &self.0,
                        &DeepNest::QUX,
                    )
                }
            }
        }
        impl<'p, T: _p::rpc::Table + 'p> deep_nest::Builder<'p, T> {
            #[inline]
            pub fn foo(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::AnyPtr> {
                unsafe {
                    <_p::AnyPtr as _p::field::FieldType>::accessor(
                        &mut self.0,
                        &DeepNest::FOO,
                    )
                }
            }
            #[inline]
            pub fn bar(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::AnyPtr> {
                unsafe {
                    <_p::AnyPtr as _p::field::FieldType>::accessor(
                        &mut self.0,
                        &DeepNest::BAR,
                    )
                }
            }
            #[inline]
            pub fn baz(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::AnyPtr> {
                unsafe {
                    <_p::AnyPtr as _p::field::FieldType>::accessor(
                        &mut self.0,
                        &DeepNest::BAZ,
                    )
                }
            }
            #[inline]
            pub fn qux(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::AnyPtr> {
                unsafe {
                    <_p::AnyPtr as _p::field::FieldType>::accessor(
                        &mut self.0,
                        &DeepNest::QUX,
                    )
                }
            }
            #[inline]
            pub fn into_foo(self) -> _p::AccessorOwned<'p, T, _p::AnyPtr> {
                unsafe {
                    <_p::AnyPtr as _p::field::FieldType>::accessor(
                        self.0,
                        &DeepNest::FOO,
                    )
                }
            }
            #[inline]
            pub fn into_bar(self) -> _p::AccessorOwned<'p, T, _p::AnyPtr> {
                unsafe {
                    <_p::AnyPtr as _p::field::FieldType>::accessor(
                        self.0,
                        &DeepNest::BAR,
                    )
                }
            }
            #[inline]
            pub fn into_baz(self) -> _p::AccessorOwned<'p, T, _p::AnyPtr> {
                unsafe {
                    <_p::AnyPtr as _p::field::FieldType>::accessor(
                        self.0,
                        &DeepNest::BAZ,
                    )
                }
            }
            #[inline]
            pub fn into_qux(self) -> _p::AccessorOwned<'p, T, _p::AnyPtr> {
                unsafe {
                    <_p::AnyPtr as _p::field::FieldType>::accessor(
                        self.0,
                        &DeepNest::QUX,
                    )
                }
            }
        }
        pub mod deep_nest {
            use super::{__file, __imports, _p};
            pub type Reader<'a, T = _p::rpc::Empty> = super::DeepNest<
                _p::StructReader<'a, T>,
            >;
            pub type Builder<'a, T = _p::rpc::Empty> = super::DeepNest<
                _p::StructBuilder<'a, T>,
            >;
        }
    }
    #[derive(Clone)]
    pub struct UseAliases<T = _p::Family>(T);
    impl _p::ty::SchemaType for UseAliases {
        const ID: u64 = 10260729233116210895u64;
    }
    impl<T> _p::IntoFamily for UseAliases<T> {
        type Family = UseAliases;
    }
    impl<T: _p::Capable> _p::Capable for UseAliases<T> {
        type Table = T::Table;
        type Imbued = T::Imbued;
        type ImbuedWith<T2: _p::rpc::Table> = UseAliases<T::ImbuedWith<T2>>;
        #[inline]
        fn imbued(&self) -> &Self::Imbued {
            self.0.imbued()
        }
        #[inline]
        fn imbue_release<T2: _p::rpc::Table>(
            self,
            new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
        ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
            let (imbued, old) = self.0.imbue_release(new_table);
            (UseAliases(imbued), old)
        }
        #[inline]
        fn imbue_release_into<U>(
            &self,
            other: U,
        ) -> (U::ImbuedWith<Self::Table>, U::Imbued)
        where
            U: _p::Capable,
            U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
        {
            self.0.imbue_release_into(other)
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for use_aliases::Reader<'a, T> {
        type Ptr = _p::StructReader<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
    for use_aliases::Reader<'a, T> {
        #[inline]
        fn from(ptr: _p::StructReader<'a, T>) -> Self {
            UseAliases(ptr)
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<use_aliases::Reader<'a, T>>
    for _p::StructReader<'a, T> {
        #[inline]
        fn from(reader: use_aliases::Reader<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
    for use_aliases::Reader<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructReader<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructReader for use_aliases::Reader<'a, T> {}
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for use_aliases::Builder<'a, T> {
        type Ptr = _p::StructBuilder<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<use_aliases::Builder<'a, T>>
    for _p::StructBuilder<'a, T> {
        #[inline]
        fn from(reader: use_aliases::Builder<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
    for use_aliases::Builder<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
    for use_aliases::Builder<'a, T> {
        #[inline]
        fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
            &mut self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for use_aliases::Builder<'a, T> {
        unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
            Self(ptr)
        }
    }
    impl _p::StructView for UseAliases {
        type Reader<'a, T: _p::rpc::Table> = use_aliases::Reader<'a, T>;
        type Builder<'a, T: _p::rpc::Table> = use_aliases::Builder<'a, T>;
    }
    impl _p::ty::Struct for UseAliases {
        const SIZE: _p::StructSize = _p::StructSize {
            data: 0u16,
            ptrs: 6u16,
        };
    }
    impl UseAliases {
        const FOO: _p::Descriptor<_p::AnyPtr> = _p::Descriptor::<_p::AnyPtr> {
            slot: 0u32,
            default: ::core::option::Option::None,
        };
        const INNER: _p::Descriptor<_p::Struct<Inner>> = _p::Descriptor::<
            _p::Struct<Inner>,
        > {
            slot: 1u32,
            default: ::core::option::Option::None,
        };
        const INNER2: _p::Descriptor<_p::Struct<Inner2>> = _p::Descriptor::<
            _p::Struct<Inner2>,
        > {
            slot: 2u32,
            default: ::core::option::Option::None,
        };
        const INNER2_BIND: _p::Descriptor<_p::Struct<Inner2>> = _p::Descriptor::<
            _p::Struct<Inner2>,
        > {
            slot: 3u32,
            default: ::core::option::Option::None,
        };
        const INNER2_TEXT: _p::Descriptor<_p::Struct<Inner2>> = _p::Descriptor::<
            _p::Struct<Inner2>,
        > {
            slot: 4u32,
            default: ::core::option::Option::None,
        };
        const REV_FOO: _p::Descriptor<_p::AnyPtr> = _p::Descriptor::<_p::AnyPtr> {
            slot: 5u32,
            default: ::core::option::Option::None,
        };
    }
    impl<'p, T: _p::rpc::Table + 'p> use_aliases::Reader<'p, T> {
        #[inline]
        pub fn foo(&self) -> _p::Accessor<'_, 'p, T, _p::AnyPtr> {
            unsafe {
                <_p::AnyPtr as _p::field::FieldType>::accessor(&self.0, &UseAliases::FOO)
            }
        }
        #[inline]
        pub fn inner(&self) -> _p::Accessor<'_, 'p, T, _p::Struct<Inner>> {
            unsafe {
                <_p::Struct<
                    Inner,
                > as _p::field::FieldType>::accessor(&self.0, &UseAliases::INNER)
            }
        }
        #[inline]
        pub fn inner2(&self) -> _p::Accessor<'_, 'p, T, _p::Struct<Inner2>> {
            unsafe {
                <_p::Struct<
                    Inner2,
                > as _p::field::FieldType>::accessor(&self.0, &UseAliases::INNER2)
            }
        }
        #[inline]
        pub fn inner2_bind(&self) -> _p::Accessor<'_, 'p, T, _p::Struct<Inner2>> {
            unsafe {
                <_p::Struct<
                    Inner2,
                > as _p::field::FieldType>::accessor(&self.0, &UseAliases::INNER2_BIND)
            }
        }
        #[inline]
        pub fn inner2_text(&self) -> _p::Accessor<'_, 'p, T, _p::Struct<Inner2>> {
            unsafe {
                <_p::Struct<
                    Inner2,
                > as _p::field::FieldType>::accessor(&self.0, &UseAliases::INNER2_TEXT)
            }
        }
        #[inline]
        pub fn rev_foo(&self) -> _p::Accessor<'_, 'p, T, _p::AnyPtr> {
            unsafe {
                <_p::AnyPtr as _p::field::FieldType>::accessor(
                    &self.0,
                    &UseAliases::REV_FOO,
                )
            }
        }
    }
    impl<'p, T: _p::rpc::Table + 'p> use_aliases::Builder<'p, T> {
        #[inline]
        pub fn foo(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::AnyPtr> {
            unsafe {
                <_p::AnyPtr as _p::field::FieldType>::accessor(
                    &mut self.0,
                    &UseAliases::FOO,
                )
            }
        }
        #[inline]
        pub fn inner(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Struct<Inner>> {
            unsafe {
                <_p::Struct<
                    Inner,
                > as _p::field::FieldType>::accessor(&mut self.0, &UseAliases::INNER)
            }
        }
        #[inline]
        pub fn inner2(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Struct<Inner2>> {
            unsafe {
                <_p::Struct<
                    Inner2,
                > as _p::field::FieldType>::accessor(&mut self.0, &UseAliases::INNER2)
            }
        }
        #[inline]
        pub fn inner2_bind(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Struct<Inner2>> {
            unsafe {
                <_p::Struct<
                    Inner2,
                > as _p::field::FieldType>::accessor(
                    &mut self.0,
                    &UseAliases::INNER2_BIND,
                )
            }
        }
        #[inline]
        pub fn inner2_text(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Struct<Inner2>> {
            unsafe {
                <_p::Struct<
                    Inner2,
                > as _p::field::FieldType>::accessor(
                    &mut self.0,
                    &UseAliases::INNER2_TEXT,
                )
            }
        }
        #[inline]
        pub fn rev_foo(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::AnyPtr> {
            unsafe {
                <_p::AnyPtr as _p::field::FieldType>::accessor(
                    &mut self.0,
                    &UseAliases::REV_FOO,
                )
            }
        }
        #[inline]
        pub fn into_foo(self) -> _p::AccessorOwned<'p, T, _p::AnyPtr> {
            unsafe {
                <_p::AnyPtr as _p::field::FieldType>::accessor(self.0, &UseAliases::FOO)
            }
        }
        #[inline]
        pub fn into_inner(self) -> _p::AccessorOwned<'p, T, _p::Struct<Inner>> {
            unsafe {
                <_p::Struct<
                    Inner,
                > as _p::field::FieldType>::accessor(self.0, &UseAliases::INNER)
            }
        }
        #[inline]
        pub fn into_inner2(self) -> _p::AccessorOwned<'p, T, _p::Struct<Inner2>> {
            unsafe {
                <_p::Struct<
                    Inner2,
                > as _p::field::FieldType>::accessor(self.0, &UseAliases::INNER2)
            }
        }
        #[inline]
        pub fn into_inner2_bind(self) -> _p::AccessorOwned<'p, T, _p::Struct<Inner2>> {
            unsafe {
                <_p::Struct<
                    Inner2,
                > as _p::field::FieldType>::accessor(self.0, &UseAliases::INNER2_BIND)
            }
        }
        #[inline]
        pub fn into_inner2_text(self) -> _p::AccessorOwned<'p, T, _p::Struct<Inner2>> {
            unsafe {
                <_p::Struct<
                    Inner2,
                > as _p::field::FieldType>::accessor(self.0, &UseAliases::INNER2_TEXT)
            }
        }
        #[inline]
        pub fn into_rev_foo(self) -> _p::AccessorOwned<'p, T, _p::AnyPtr> {
            unsafe {
                <_p::AnyPtr as _p::field::FieldType>::accessor(
                    self.0,
                    &UseAliases::REV_FOO,
                )
            }
        }
    }
    pub mod use_aliases {
        use super::{__file, __imports, _p};
        pub type Reader<'a, T = _p::rpc::Empty> = super::UseAliases<
            _p::StructReader<'a, T>,
        >;
        pub type Builder<'a, T = _p::rpc::Empty> = super::UseAliases<
            _p::StructBuilder<'a, T>,
        >;
    }
    #[derive(Clone)]
    pub struct Ug<T = _p::Family>(T);
    impl _p::ty::SchemaType for Ug {
        const ID: u64 = 13000334785903802446u64;
    }
    impl<T> _p::IntoFamily for Ug<T> {
        type Family = Ug;
    }
    impl<T: _p::Capable> _p::Capable for Ug<T> {
        type Table = T::Table;
        type Imbued = T::Imbued;
        type ImbuedWith<T2: _p::rpc::Table> = Ug<T::ImbuedWith<T2>>;
        #[inline]
        fn imbued(&self) -> &Self::Imbued {
            self.0.imbued()
        }
        #[inline]
        fn imbue_release<T2: _p::rpc::Table>(
            self,
            new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
        ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
            let (imbued, old) = self.0.imbue_release(new_table);
            (Ug(imbued), old)
        }
        #[inline]
        fn imbue_release_into<U>(
            &self,
            other: U,
        ) -> (U::ImbuedWith<Self::Table>, U::Imbued)
        where
            U: _p::Capable,
            U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
        {
            self.0.imbue_release_into(other)
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for ug::Reader<'a, T> {
        type Ptr = _p::StructReader<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
    for ug::Reader<'a, T> {
        #[inline]
        fn from(ptr: _p::StructReader<'a, T>) -> Self {
            Ug(ptr)
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<ug::Reader<'a, T>>
    for _p::StructReader<'a, T> {
        #[inline]
        fn from(reader: ug::Reader<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
    for ug::Reader<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructReader<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructReader for ug::Reader<'a, T> {}
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for ug::Builder<'a, T> {
        type Ptr = _p::StructBuilder<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<ug::Builder<'a, T>>
    for _p::StructBuilder<'a, T> {
        #[inline]
        fn from(reader: ug::Builder<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
    for ug::Builder<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
    for ug::Builder<'a, T> {
        #[inline]
        fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
            &mut self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for ug::Builder<'a, T> {
        unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
            Self(ptr)
        }
    }
    impl _p::StructView for Ug {
        type Reader<'a, T: _p::rpc::Table> = ug::Reader<'a, T>;
        type Builder<'a, T: _p::rpc::Table> = ug::Builder<'a, T>;
    }
    impl _p::FieldGroup for Ug {
        unsafe fn clear<'a, 'b, T: _p::rpc::Table>(s: &'a mut _p::StructBuilder<'b, T>) {
            <i32 as _p::field::FieldType>::clear(s, &Ug::UGFOO);
        }
    }
    impl Ug {
        const UGFOO: _p::Descriptor<i32> = _p::Descriptor::<i32> {
            slot: 1u32,
            default: 0i32,
        };
    }
    impl<'p, T: _p::rpc::Table + 'p> ug::Reader<'p, T> {
        #[inline]
        pub fn ugfoo(&self) -> _p::Accessor<'_, 'p, T, i32> {
            unsafe { <i32 as _p::field::FieldType>::accessor(&self.0, &Ug::UGFOO) }
        }
    }
    impl<'p, T: _p::rpc::Table + 'p> ug::Builder<'p, T> {
        #[inline]
        pub fn ugfoo(&mut self) -> _p::AccessorMut<'_, 'p, T, i32> {
            unsafe { <i32 as _p::field::FieldType>::accessor(&mut self.0, &Ug::UGFOO) }
        }
    }
    pub mod ug {
        use super::{__file, __imports, _p};
        pub type Reader<'a, T = _p::rpc::Empty> = super::Ug<_p::StructReader<'a, T>>;
        pub type Builder<'a, T = _p::rpc::Empty> = super::Ug<_p::StructBuilder<'a, T>>;
    }
}
#[derive(Clone)]
pub struct BoxedText<T = _p::Family>(T);
impl _p::ty::SchemaType for BoxedText {
    const ID: u64 = 11210786258299153994u64;
}
impl<T> _p::IntoFamily for BoxedText<T> {
    type Family = BoxedText;
}
impl<T: _p::Capable> _p::Capable for BoxedText<T> {
    type Table = T::Table;
    type Imbued = T::Imbued;
    type ImbuedWith<T2: _p::rpc::Table> = BoxedText<T::ImbuedWith<T2>>;
    #[inline]
    fn imbued(&self) -> &Self::Imbued {
        self.0.imbued()
    }
    #[inline]
    fn imbue_release<T2: _p::rpc::Table>(
        self,
        new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
    ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
        let (imbued, old) = self.0.imbue_release(new_table);
        (BoxedText(imbued), old)
    }
    #[inline]
    fn imbue_release_into<U>(&self, other: U) -> (U::ImbuedWith<Self::Table>, U::Imbued)
    where
        U: _p::Capable,
        U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
    {
        self.0.imbue_release_into(other)
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for boxed_text::Reader<'a, T> {
    type Ptr = _p::StructReader<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
for boxed_text::Reader<'a, T> {
    #[inline]
    fn from(ptr: _p::StructReader<'a, T>) -> Self {
        BoxedText(ptr)
    }
}
impl<'a, T: _p::rpc::Table> core::convert::From<boxed_text::Reader<'a, T>>
for _p::StructReader<'a, T> {
    #[inline]
    fn from(reader: boxed_text::Reader<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
for boxed_text::Reader<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructReader<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructReader for boxed_text::Reader<'a, T> {}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for boxed_text::Builder<'a, T> {
    type Ptr = _p::StructBuilder<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<boxed_text::Builder<'a, T>>
for _p::StructBuilder<'a, T> {
    #[inline]
    fn from(reader: boxed_text::Builder<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
for boxed_text::Builder<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
for boxed_text::Builder<'a, T> {
    #[inline]
    fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
        &mut self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for boxed_text::Builder<'a, T> {
    unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
        Self(ptr)
    }
}
impl _p::StructView for BoxedText {
    type Reader<'a, T: _p::rpc::Table> = boxed_text::Reader<'a, T>;
    type Builder<'a, T: _p::rpc::Table> = boxed_text::Builder<'a, T>;
}
impl _p::ty::Struct for BoxedText {
    const SIZE: _p::StructSize = _p::StructSize {
        data: 0u16,
        ptrs: 1u16,
    };
}
impl BoxedText {
    const TEXT: _p::Descriptor<_p::Text> = _p::Descriptor::<_p::Text> {
        slot: 0u32,
        default: ::core::option::Option::None,
    };
}
impl<'p, T: _p::rpc::Table + 'p> boxed_text::Reader<'p, T> {
    #[inline]
    pub fn text(&self) -> _p::Accessor<'_, 'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(&self.0, &BoxedText::TEXT)
        }
    }
}
impl<'p, T: _p::rpc::Table + 'p> boxed_text::Builder<'p, T> {
    #[inline]
    pub fn text(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(&mut self.0, &BoxedText::TEXT)
        }
    }
    #[inline]
    pub fn into_text(self) -> _p::AccessorOwned<'p, T, _p::Text> {
        unsafe { <_p::Text as _p::field::FieldType>::accessor(self.0, &BoxedText::TEXT) }
    }
}
pub mod boxed_text {
    use super::{__file, __imports, _p};
    pub type Reader<'a, T = _p::rpc::Empty> = super::BoxedText<_p::StructReader<'a, T>>;
    pub type Builder<'a, T = _p::rpc::Empty> = super::BoxedText<
        _p::StructBuilder<'a, T>,
    >;
}
#[derive(Clone)]
pub struct TestGenericsWrapper<T = _p::Family>(T);
impl _p::ty::SchemaType for TestGenericsWrapper {
    const ID: u64 = 12228031604858979421u64;
}
impl<T> _p::IntoFamily for TestGenericsWrapper<T> {
    type Family = TestGenericsWrapper;
}
impl<T: _p::Capable> _p::Capable for TestGenericsWrapper<T> {
    type Table = T::Table;
    type Imbued = T::Imbued;
    type ImbuedWith<T2: _p::rpc::Table> = TestGenericsWrapper<T::ImbuedWith<T2>>;
    #[inline]
    fn imbued(&self) -> &Self::Imbued {
        self.0.imbued()
    }
    #[inline]
    fn imbue_release<T2: _p::rpc::Table>(
        self,
        new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
    ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
        let (imbued, old) = self.0.imbue_release(new_table);
        (TestGenericsWrapper(imbued), old)
    }
    #[inline]
    fn imbue_release_into<U>(&self, other: U) -> (U::ImbuedWith<Self::Table>, U::Imbued)
    where
        U: _p::Capable,
        U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
    {
        self.0.imbue_release_into(other)
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_generics_wrapper::Reader<'a, T> {
    type Ptr = _p::StructReader<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
for test_generics_wrapper::Reader<'a, T> {
    #[inline]
    fn from(ptr: _p::StructReader<'a, T>) -> Self {
        TestGenericsWrapper(ptr)
    }
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_generics_wrapper::Reader<'a, T>>
for _p::StructReader<'a, T> {
    #[inline]
    fn from(reader: test_generics_wrapper::Reader<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
for test_generics_wrapper::Reader<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructReader<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructReader
for test_generics_wrapper::Reader<'a, T> {}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_generics_wrapper::Builder<'a, T> {
    type Ptr = _p::StructBuilder<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_generics_wrapper::Builder<'a, T>>
for _p::StructBuilder<'a, T> {
    #[inline]
    fn from(reader: test_generics_wrapper::Builder<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
for test_generics_wrapper::Builder<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
for test_generics_wrapper::Builder<'a, T> {
    #[inline]
    fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
        &mut self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder
for test_generics_wrapper::Builder<'a, T> {
    unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
        Self(ptr)
    }
}
impl _p::StructView for TestGenericsWrapper {
    type Reader<'a, T: _p::rpc::Table> = test_generics_wrapper::Reader<'a, T>;
    type Builder<'a, T: _p::rpc::Table> = test_generics_wrapper::Builder<'a, T>;
}
impl _p::ty::Struct for TestGenericsWrapper {
    const SIZE: _p::StructSize = _p::StructSize {
        data: 0u16,
        ptrs: 1u16,
    };
}
impl TestGenericsWrapper {
    const VALUE: _p::Descriptor<_p::Struct<TestGenerics>> = _p::Descriptor::<
        _p::Struct<TestGenerics>,
    > {
        slot: 0u32,
        default: ::core::option::Option::None,
    };
}
impl<'p, T: _p::rpc::Table + 'p> test_generics_wrapper::Reader<'p, T> {
    #[inline]
    pub fn value(&self) -> _p::Accessor<'_, 'p, T, _p::Struct<TestGenerics>> {
        unsafe {
            <_p::Struct<
                TestGenerics,
            > as _p::field::FieldType>::accessor(&self.0, &TestGenericsWrapper::VALUE)
        }
    }
}
impl<'p, T: _p::rpc::Table + 'p> test_generics_wrapper::Builder<'p, T> {
    #[inline]
    pub fn value(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Struct<TestGenerics>> {
        unsafe {
            <_p::Struct<
                TestGenerics,
            > as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestGenericsWrapper::VALUE,
            )
        }
    }
    #[inline]
    pub fn into_value(self) -> _p::AccessorOwned<'p, T, _p::Struct<TestGenerics>> {
        unsafe {
            <_p::Struct<
                TestGenerics,
            > as _p::field::FieldType>::accessor(self.0, &TestGenericsWrapper::VALUE)
        }
    }
}
pub mod test_generics_wrapper {
    use super::{__file, __imports, _p};
    pub type Reader<'a, T = _p::rpc::Empty> = super::TestGenericsWrapper<
        _p::StructReader<'a, T>,
    >;
    pub type Builder<'a, T = _p::rpc::Empty> = super::TestGenericsWrapper<
        _p::StructBuilder<'a, T>,
    >;
}
#[derive(Clone)]
pub struct TestGenericsWrapper2<T = _p::Family>(T);
impl _p::ty::SchemaType for TestGenericsWrapper2 {
    const ID: u64 = 17478333155010509316u64;
}
impl<T> _p::IntoFamily for TestGenericsWrapper2<T> {
    type Family = TestGenericsWrapper2;
}
impl<T: _p::Capable> _p::Capable for TestGenericsWrapper2<T> {
    type Table = T::Table;
    type Imbued = T::Imbued;
    type ImbuedWith<T2: _p::rpc::Table> = TestGenericsWrapper2<T::ImbuedWith<T2>>;
    #[inline]
    fn imbued(&self) -> &Self::Imbued {
        self.0.imbued()
    }
    #[inline]
    fn imbue_release<T2: _p::rpc::Table>(
        self,
        new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
    ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
        let (imbued, old) = self.0.imbue_release(new_table);
        (TestGenericsWrapper2(imbued), old)
    }
    #[inline]
    fn imbue_release_into<U>(&self, other: U) -> (U::ImbuedWith<Self::Table>, U::Imbued)
    where
        U: _p::Capable,
        U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
    {
        self.0.imbue_release_into(other)
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_generics_wrapper2::Reader<'a, T> {
    type Ptr = _p::StructReader<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
for test_generics_wrapper2::Reader<'a, T> {
    #[inline]
    fn from(ptr: _p::StructReader<'a, T>) -> Self {
        TestGenericsWrapper2(ptr)
    }
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_generics_wrapper2::Reader<'a, T>>
for _p::StructReader<'a, T> {
    #[inline]
    fn from(reader: test_generics_wrapper2::Reader<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
for test_generics_wrapper2::Reader<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructReader<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructReader
for test_generics_wrapper2::Reader<'a, T> {}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_generics_wrapper2::Builder<'a, T> {
    type Ptr = _p::StructBuilder<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_generics_wrapper2::Builder<'a, T>>
for _p::StructBuilder<'a, T> {
    #[inline]
    fn from(reader: test_generics_wrapper2::Builder<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
for test_generics_wrapper2::Builder<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
for test_generics_wrapper2::Builder<'a, T> {
    #[inline]
    fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
        &mut self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder
for test_generics_wrapper2::Builder<'a, T> {
    unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
        Self(ptr)
    }
}
impl _p::StructView for TestGenericsWrapper2 {
    type Reader<'a, T: _p::rpc::Table> = test_generics_wrapper2::Reader<'a, T>;
    type Builder<'a, T: _p::rpc::Table> = test_generics_wrapper2::Builder<'a, T>;
}
impl _p::ty::Struct for TestGenericsWrapper2 {
    const SIZE: _p::StructSize = _p::StructSize {
        data: 0u16,
        ptrs: 1u16,
    };
}
impl TestGenericsWrapper2 {
    const VALUE: _p::Descriptor<_p::Struct<TestGenericsWrapper>> = _p::Descriptor::<
        _p::Struct<TestGenericsWrapper>,
    > {
        slot: 0u32,
        default: ::core::option::Option::None,
    };
}
impl<'p, T: _p::rpc::Table + 'p> test_generics_wrapper2::Reader<'p, T> {
    #[inline]
    pub fn value(&self) -> _p::Accessor<'_, 'p, T, _p::Struct<TestGenericsWrapper>> {
        unsafe {
            <_p::Struct<
                TestGenericsWrapper,
            > as _p::field::FieldType>::accessor(&self.0, &TestGenericsWrapper2::VALUE)
        }
    }
}
impl<'p, T: _p::rpc::Table + 'p> test_generics_wrapper2::Builder<'p, T> {
    #[inline]
    pub fn value(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::Struct<TestGenericsWrapper>> {
        unsafe {
            <_p::Struct<
                TestGenericsWrapper,
            > as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestGenericsWrapper2::VALUE,
            )
        }
    }
    #[inline]
    pub fn into_value(
        self,
    ) -> _p::AccessorOwned<'p, T, _p::Struct<TestGenericsWrapper>> {
        unsafe {
            <_p::Struct<
                TestGenericsWrapper,
            > as _p::field::FieldType>::accessor(self.0, &TestGenericsWrapper2::VALUE)
        }
    }
}
pub mod test_generics_wrapper2 {
    use super::{__file, __imports, _p};
    pub type Reader<'a, T = _p::rpc::Empty> = super::TestGenericsWrapper2<
        _p::StructReader<'a, T>,
    >;
    pub type Builder<'a, T = _p::rpc::Empty> = super::TestGenericsWrapper2<
        _p::StructBuilder<'a, T>,
    >;
}
#[derive(Clone)]
pub struct TestGenericsUnion<T = _p::Family>(T);
impl _p::ty::SchemaType for TestGenericsUnion {
    const ID: u64 = 11909892652185784419u64;
}
impl<T> _p::IntoFamily for TestGenericsUnion<T> {
    type Family = TestGenericsUnion;
}
impl<T: _p::Capable> _p::Capable for TestGenericsUnion<T> {
    type Table = T::Table;
    type Imbued = T::Imbued;
    type ImbuedWith<T2: _p::rpc::Table> = TestGenericsUnion<T::ImbuedWith<T2>>;
    #[inline]
    fn imbued(&self) -> &Self::Imbued {
        self.0.imbued()
    }
    #[inline]
    fn imbue_release<T2: _p::rpc::Table>(
        self,
        new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
    ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
        let (imbued, old) = self.0.imbue_release(new_table);
        (TestGenericsUnion(imbued), old)
    }
    #[inline]
    fn imbue_release_into<U>(&self, other: U) -> (U::ImbuedWith<Self::Table>, U::Imbued)
    where
        U: _p::Capable,
        U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
    {
        self.0.imbue_release_into(other)
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_generics_union::Reader<'a, T> {
    type Ptr = _p::StructReader<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
for test_generics_union::Reader<'a, T> {
    #[inline]
    fn from(ptr: _p::StructReader<'a, T>) -> Self {
        TestGenericsUnion(ptr)
    }
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_generics_union::Reader<'a, T>>
for _p::StructReader<'a, T> {
    #[inline]
    fn from(reader: test_generics_union::Reader<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
for test_generics_union::Reader<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructReader<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructReader for test_generics_union::Reader<'a, T> {}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_generics_union::Builder<'a, T> {
    type Ptr = _p::StructBuilder<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_generics_union::Builder<'a, T>>
for _p::StructBuilder<'a, T> {
    #[inline]
    fn from(reader: test_generics_union::Builder<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
for test_generics_union::Builder<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
for test_generics_union::Builder<'a, T> {
    #[inline]
    fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
        &mut self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder
for test_generics_union::Builder<'a, T> {
    unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
        Self(ptr)
    }
}
impl _p::StructView for TestGenericsUnion {
    type Reader<'a, T: _p::rpc::Table> = test_generics_union::Reader<'a, T>;
    type Builder<'a, T: _p::rpc::Table> = test_generics_union::Builder<'a, T>;
}
impl _p::ty::Struct for TestGenericsUnion {
    const SIZE: _p::StructSize = _p::StructSize {
        data: 1u16,
        ptrs: 1u16,
    };
}
impl TestGenericsUnion {
    const FOO: _p::VariantDescriptor<_p::AnyPtr> = _p::VariantDescriptor::<_p::AnyPtr> {
        variant: _p::VariantInfo {
            slot: 0u32,
            case: 0u16,
        },
        field: _p::Descriptor::<_p::AnyPtr> {
            slot: 0u32,
            default: ::core::option::Option::None,
        },
    };
    const BAR: _p::VariantDescriptor<_p::AnyPtr> = _p::VariantDescriptor::<_p::AnyPtr> {
        variant: _p::VariantInfo {
            slot: 0u32,
            case: 1u16,
        },
        field: _p::Descriptor::<_p::AnyPtr> {
            slot: 0u32,
            default: ::core::option::Option::None,
        },
    };
}
impl<'p, T: _p::rpc::Table + 'p> test_generics_union::Reader<'p, T> {
    #[inline]
    pub fn foo(&self) -> _p::Variant<'_, 'p, T, _p::AnyPtr> {
        unsafe {
            <_p::AnyPtr as _p::field::FieldType>::variant(
                &self.0,
                &TestGenericsUnion::FOO,
            )
        }
    }
    #[inline]
    pub fn bar(&self) -> _p::Variant<'_, 'p, T, _p::AnyPtr> {
        unsafe {
            <_p::AnyPtr as _p::field::FieldType>::variant(
                &self.0,
                &TestGenericsUnion::BAR,
            )
        }
    }
    #[inline]
    pub fn which(&self) -> Result<test_generics_union::Which<&Self>, _p::NotInSchema> {
        unsafe { <test_generics_union::Which<_> as _p::UnionViewer<_>>::get(self) }
    }
}
impl<'p, T: _p::rpc::Table + 'p> test_generics_union::Builder<'p, T> {
    #[inline]
    pub fn foo(&mut self) -> _p::VariantMut<'_, 'p, T, _p::AnyPtr> {
        unsafe {
            <_p::AnyPtr as _p::field::FieldType>::variant(
                &mut self.0,
                &TestGenericsUnion::FOO,
            )
        }
    }
    #[inline]
    pub fn bar(&mut self) -> _p::VariantMut<'_, 'p, T, _p::AnyPtr> {
        unsafe {
            <_p::AnyPtr as _p::field::FieldType>::variant(
                &mut self.0,
                &TestGenericsUnion::BAR,
            )
        }
    }
    #[inline]
    pub fn into_foo(self) -> _p::VariantOwned<'p, T, _p::AnyPtr> {
        unsafe {
            <_p::AnyPtr as _p::field::FieldType>::variant(
                self.0,
                &TestGenericsUnion::FOO,
            )
        }
    }
    #[inline]
    pub fn into_bar(self) -> _p::VariantOwned<'p, T, _p::AnyPtr> {
        unsafe {
            <_p::AnyPtr as _p::field::FieldType>::variant(
                self.0,
                &TestGenericsUnion::BAR,
            )
        }
    }
    #[inline]
    pub fn which(
        &mut self,
    ) -> Result<test_generics_union::Which<&mut Self>, _p::NotInSchema> {
        unsafe { <test_generics_union::Which<_> as _p::UnionViewer<_>>::get(self) }
    }
}
pub mod test_generics_union {
    use super::{__file, __imports, _p};
    pub type Reader<'a, T = _p::rpc::Empty> = super::TestGenericsUnion<
        _p::StructReader<'a, T>,
    >;
    pub type Builder<'a, T = _p::rpc::Empty> = super::TestGenericsUnion<
        _p::StructBuilder<'a, T>,
    >;
    pub enum Which<T: _p::Viewable = _p::Family> {
        Foo(_p::ViewOf<T, _p::AnyPtr>),
        Bar(_p::ViewOf<T, _p::AnyPtr>),
    }
    impl<'b, 'p: 'b, T: _p::Table + 'p> _p::UnionViewer<&'b Reader<'p, T>> for Which {
        type View = Which<&'b Reader<'p, T>>;
        unsafe fn get(repr: &'b Reader<'p, T>) -> Result<Self::View, _p::NotInSchema> {
            let tag = repr.0.data_field::<u16>(0usize);
            match tag {
                0u16 => {
                    Ok(
                        Which::Foo(
                            <_p::AnyPtr as _p::field::FieldType>::accessor(
                                &repr.0,
                                &super::TestGenericsUnion::FOO.field,
                            ),
                        ),
                    )
                }
                1u16 => {
                    Ok(
                        Which::Bar(
                            <_p::AnyPtr as _p::field::FieldType>::accessor(
                                &repr.0,
                                &super::TestGenericsUnion::BAR.field,
                            ),
                        ),
                    )
                }
                unknown => Err(_p::NotInSchema(unknown)),
            }
        }
    }
    impl<'b, 'p: 'b, T: _p::Table + 'p> _p::UnionViewer<&'b mut Builder<'p, T>>
    for Which {
        type View = Which<&'b mut Builder<'p, T>>;
        unsafe fn get(
            repr: &'b mut Builder<'p, T>,
        ) -> Result<Self::View, _p::NotInSchema> {
            let tag = repr.0.data_field::<u16>(0usize);
            match tag {
                0u16 => {
                    Ok(
                        Which::Foo(
                            <_p::AnyPtr as _p::field::FieldType>::accessor(
                                &mut repr.0,
                                &super::TestGenericsUnion::FOO.field,
                            ),
                        ),
                    )
                }
                1u16 => {
                    Ok(
                        Which::Bar(
                            <_p::AnyPtr as _p::field::FieldType>::accessor(
                                &mut repr.0,
                                &super::TestGenericsUnion::BAR.field,
                            ),
                        ),
                    )
                }
                unknown => Err(_p::NotInSchema(unknown)),
            }
        }
    }
}
#[derive(Clone)]
pub struct TestUseGenerics<T = _p::Family>(T);
impl _p::ty::SchemaType for TestUseGenerics {
    const ID: u64 = 10675697872305927055u64;
}
impl<T> _p::IntoFamily for TestUseGenerics<T> {
    type Family = TestUseGenerics;
}
impl<T: _p::Capable> _p::Capable for TestUseGenerics<T> {
    type Table = T::Table;
    type Imbued = T::Imbued;
    type ImbuedWith<T2: _p::rpc::Table> = TestUseGenerics<T::ImbuedWith<T2>>;
    #[inline]
    fn imbued(&self) -> &Self::Imbued {
        self.0.imbued()
    }
    #[inline]
    fn imbue_release<T2: _p::rpc::Table>(
        self,
        new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
    ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
        let (imbued, old) = self.0.imbue_release(new_table);
        (TestUseGenerics(imbued), old)
    }
    #[inline]
    fn imbue_release_into<U>(&self, other: U) -> (U::ImbuedWith<Self::Table>, U::Imbued)
    where
        U: _p::Capable,
        U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
    {
        self.0.imbue_release_into(other)
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_use_generics::Reader<'a, T> {
    type Ptr = _p::StructReader<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
for test_use_generics::Reader<'a, T> {
    #[inline]
    fn from(ptr: _p::StructReader<'a, T>) -> Self {
        TestUseGenerics(ptr)
    }
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_use_generics::Reader<'a, T>>
for _p::StructReader<'a, T> {
    #[inline]
    fn from(reader: test_use_generics::Reader<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
for test_use_generics::Reader<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructReader<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructReader for test_use_generics::Reader<'a, T> {}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_use_generics::Builder<'a, T> {
    type Ptr = _p::StructBuilder<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_use_generics::Builder<'a, T>>
for _p::StructBuilder<'a, T> {
    #[inline]
    fn from(reader: test_use_generics::Builder<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
for test_use_generics::Builder<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
for test_use_generics::Builder<'a, T> {
    #[inline]
    fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
        &mut self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for test_use_generics::Builder<'a, T> {
    unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
        Self(ptr)
    }
}
impl _p::StructView for TestUseGenerics {
    type Reader<'a, T: _p::rpc::Table> = test_use_generics::Reader<'a, T>;
    type Builder<'a, T: _p::rpc::Table> = test_use_generics::Builder<'a, T>;
}
impl _p::ty::Struct for TestUseGenerics {
    const SIZE: _p::StructSize = _p::StructSize {
        data: 0u16,
        ptrs: 20u16,
    };
}
impl TestUseGenerics {
    const BASIC: _p::Descriptor<_p::Struct<TestGenerics>> = _p::Descriptor::<
        _p::Struct<TestGenerics>,
    > {
        slot: 0u32,
        default: ::core::option::Option::None,
    };
    const INNER: _p::Descriptor<_p::Struct<test_generics::Inner>> = _p::Descriptor::<
        _p::Struct<test_generics::Inner>,
    > {
        slot: 1u32,
        default: ::core::option::Option::None,
    };
    const INNER2: _p::Descriptor<_p::Struct<test_generics::Inner2>> = _p::Descriptor::<
        _p::Struct<test_generics::Inner2>,
    > {
        slot: 2u32,
        default: ::core::option::Option::None,
    };
    const UNSPECIFIED: _p::Descriptor<_p::Struct<TestGenerics>> = _p::Descriptor::<
        _p::Struct<TestGenerics>,
    > {
        slot: 3u32,
        default: ::core::option::Option::None,
    };
    const UNSPECIFIED_INNER: _p::Descriptor<_p::Struct<test_generics::Inner2>> = _p::Descriptor::<
        _p::Struct<test_generics::Inner2>,
    > {
        slot: 4u32,
        default: ::core::option::Option::None,
    };
    const DEFAULT: _p::Descriptor<_p::Struct<TestGenerics>> = _p::Descriptor::<
        _p::Struct<TestGenerics>,
    > {
        slot: 5u32,
        default: ::core::option::Option::Some(unsafe {
            _p::StructReader::slice_unchecked(
                &[
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([8u8, 0u8, 0u8, 0u8, 6u8, 0u8, 20u8, 0u8]),
                    _p::Word([108u8, 0u8, 0u8, 0u8, 1u8, 0u8, 3u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 123u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([9u8, 0u8, 0u8, 0u8, 42u8, 0u8, 0u8, 0u8]),
                    _p::Word([8u8, 0u8, 0u8, 0u8, 1u8, 0u8, 3u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([116u8, 101u8, 120u8, 116u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([8u8, 0u8, 0u8, 0u8, 6u8, 0u8, 20u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 65u8, 1u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                ],
                _p::StructSize {
                    data: 1u16,
                    ptrs: 3u16,
                },
            )
        }),
    };
    const DEFAULT_INNER: _p::Descriptor<_p::Struct<test_generics::Inner>> = _p::Descriptor::<
        _p::Struct<test_generics::Inner>,
    > {
        slot: 6u32,
        default: ::core::option::Option::Some(unsafe {
            _p::StructReader::slice_unchecked(
                &[
                    _p::Word([4u8, 0u8, 0u8, 0u8, 6u8, 0u8, 20u8, 0u8]),
                    _p::Word([105u8, 0u8, 0u8, 0u8, 42u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 123u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([116u8, 101u8, 120u8, 116u8, 0u8, 0u8, 0u8, 0u8]),
                ],
                _p::StructSize {
                    data: 0u16,
                    ptrs: 2u16,
                },
            )
        }),
    };
    const DEFAULT_USER: _p::Descriptor<_p::Struct<TestUseGenerics>> = _p::Descriptor::<
        _p::Struct<TestUseGenerics>,
    > {
        slot: 7u32,
        default: ::core::option::Option::Some(unsafe {
            _p::StructReader::slice_unchecked(
                &[
                    _p::Word([76u8, 0u8, 0u8, 0u8, 1u8, 0u8, 3u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([8u8, 0u8, 0u8, 0u8, 6u8, 0u8, 20u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 123u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                ],
                _p::StructSize {
                    data: 0u16,
                    ptrs: 20u16,
                },
            )
        }),
    };
    const WRAPPER: _p::Descriptor<_p::Struct<TestGenericsWrapper>> = _p::Descriptor::<
        _p::Struct<TestGenericsWrapper>,
    > {
        slot: 8u32,
        default: ::core::option::Option::None,
    };
    const DEFAULT_WRAPPER: _p::Descriptor<_p::Struct<TestGenericsWrapper>> = _p::Descriptor::<
        _p::Struct<TestGenericsWrapper>,
    > {
        slot: 9u32,
        default: ::core::option::Option::Some(unsafe {
            _p::StructReader::slice_unchecked(
                &[
                    _p::Word([0u8, 0u8, 0u8, 0u8, 1u8, 0u8, 3u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([9u8, 0u8, 0u8, 0u8, 42u8, 0u8, 0u8, 0u8]),
                    _p::Word([8u8, 0u8, 0u8, 0u8, 1u8, 0u8, 3u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([116u8, 101u8, 120u8, 116u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([8u8, 0u8, 0u8, 0u8, 6u8, 0u8, 20u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 65u8, 1u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                ],
                _p::StructSize {
                    data: 0u16,
                    ptrs: 1u16,
                },
            )
        }),
    };
    const DEFAULT_WRAPPER2: _p::Descriptor<_p::Struct<TestGenericsWrapper2>> = _p::Descriptor::<
        _p::Struct<TestGenericsWrapper2>,
    > {
        slot: 10u32,
        default: ::core::option::Option::Some(unsafe {
            _p::StructReader::slice_unchecked(
                &[
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 1u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 1u8, 0u8, 3u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([9u8, 0u8, 0u8, 0u8, 42u8, 0u8, 0u8, 0u8]),
                    _p::Word([8u8, 0u8, 0u8, 0u8, 1u8, 0u8, 3u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([116u8, 101u8, 120u8, 116u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([8u8, 0u8, 0u8, 0u8, 6u8, 0u8, 20u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 65u8, 1u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                ],
                _p::StructSize {
                    data: 0u16,
                    ptrs: 1u16,
                },
            )
        }),
    };
    const ALIAS_FOO: _p::Descriptor<_p::Struct<TestAllTypes>> = _p::Descriptor::<
        _p::Struct<TestAllTypes>,
    > {
        slot: 11u32,
        default: ::core::option::Option::Some(unsafe {
            _p::StructReader::slice_unchecked(
                &[
                    _p::Word([0u8, 0u8, 123u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                ],
                _p::StructSize {
                    data: 6u16,
                    ptrs: 20u16,
                },
            )
        }),
    };
    const ALIAS_INNER: _p::Descriptor<_p::Struct<test_generics::Inner>> = _p::Descriptor::<
        _p::Struct<test_generics::Inner>,
    > {
        slot: 12u32,
        default: ::core::option::Option::Some(unsafe {
            _p::StructReader::slice_unchecked(
                &[
                    _p::Word([4u8, 0u8, 0u8, 0u8, 6u8, 0u8, 20u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 123u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                ],
                _p::StructSize {
                    data: 0u16,
                    ptrs: 2u16,
                },
            )
        }),
    };
    const ALIAS_INNER2: _p::Descriptor<_p::Struct<test_generics::Inner2>> = _p::Descriptor::<
        _p::Struct<test_generics::Inner2>,
    > {
        slot: 13u32,
        default: ::core::option::Option::Some(unsafe {
            _p::StructReader::slice_unchecked(
                &[
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([4u8, 0u8, 0u8, 0u8, 0u8, 0u8, 2u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([4u8, 0u8, 0u8, 0u8, 6u8, 0u8, 20u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 123u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                ],
                _p::StructSize {
                    data: 0u16,
                    ptrs: 4u16,
                },
            )
        }),
    };
    const ALIAS_INNER2_BIND: _p::Descriptor<_p::Struct<test_generics::Inner2>> = _p::Descriptor::<
        _p::Struct<test_generics::Inner2>,
    > {
        slot: 14u32,
        default: ::core::option::Option::Some(unsafe {
            _p::StructReader::slice_unchecked(
                &[
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([9u8, 0u8, 0u8, 0u8, 20u8, 0u8, 0u8, 0u8]),
                    _p::Word([8u8, 0u8, 0u8, 0u8, 0u8, 0u8, 2u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([12u8, 0u8, 0u8, 0u8, 34u8, 0u8, 0u8, 0u8]),
                    _p::Word([4u8, 0u8, 0u8, 0u8, 6u8, 0u8, 20u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 123u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                ],
                _p::StructSize {
                    data: 0u16,
                    ptrs: 4u16,
                },
            )
        }),
    };
    const ALIAS_INNER2_TEXT: _p::Descriptor<_p::Struct<test_generics::Inner2>> = _p::Descriptor::<
        _p::Struct<test_generics::Inner2>,
    > {
        slot: 15u32,
        default: ::core::option::Option::Some(unsafe {
            _p::StructReader::slice_unchecked(
                &[
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([9u8, 0u8, 0u8, 0u8, 42u8, 0u8, 0u8, 0u8]),
                    _p::Word([8u8, 0u8, 0u8, 0u8, 0u8, 0u8, 2u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([116u8, 101u8, 120u8, 116u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([4u8, 0u8, 0u8, 0u8, 6u8, 0u8, 20u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 123u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                ],
                _p::StructSize {
                    data: 0u16,
                    ptrs: 4u16,
                },
            )
        }),
    };
    const ALIAS_REV: _p::Descriptor<_p::Text> = _p::Descriptor::<_p::Text> {
        slot: 16u32,
        default: ::core::option::Option::Some(_p::text::Reader::from_slice(b"text\0")),
    };
    const USE_ALIASES: _p::Descriptor<_p::Struct<test_generics::UseAliases>> = _p::Descriptor::<
        _p::Struct<test_generics::UseAliases>,
    > {
        slot: 17u32,
        default: ::core::option::Option::Some(unsafe {
            _p::StructReader::slice_unchecked(
                &[
                    _p::Word([20u8, 0u8, 0u8, 0u8, 6u8, 0u8, 20u8, 0u8]),
                    _p::Word([120u8, 0u8, 0u8, 0u8, 0u8, 0u8, 2u8, 0u8]),
                    _p::Word([228u8, 0u8, 0u8, 0u8, 0u8, 0u8, 4u8, 0u8]),
                    _p::Word([96u8, 1u8, 0u8, 0u8, 0u8, 0u8, 4u8, 0u8]),
                    _p::Word([224u8, 1u8, 0u8, 0u8, 0u8, 0u8, 4u8, 0u8]),
                    _p::Word([97u8, 2u8, 0u8, 0u8, 28u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 123u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([4u8, 0u8, 0u8, 0u8, 6u8, 0u8, 20u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 123u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([4u8, 0u8, 0u8, 0u8, 0u8, 0u8, 2u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([4u8, 0u8, 0u8, 0u8, 6u8, 0u8, 20u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 123u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([9u8, 0u8, 0u8, 0u8, 42u8, 0u8, 0u8, 0u8]),
                    _p::Word([8u8, 0u8, 0u8, 0u8, 0u8, 0u8, 2u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([116u8, 101u8, 120u8, 116u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([4u8, 0u8, 0u8, 0u8, 6u8, 0u8, 20u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 123u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([9u8, 0u8, 0u8, 0u8, 42u8, 0u8, 0u8, 0u8]),
                    _p::Word([8u8, 0u8, 0u8, 0u8, 0u8, 0u8, 2u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([116u8, 101u8, 120u8, 116u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([4u8, 0u8, 0u8, 0u8, 6u8, 0u8, 20u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 123u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([12u8, 0u8, 0u8, 0u8, 34u8, 0u8, 0u8, 0u8]),
                    _p::Word([56u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                ],
                _p::StructSize {
                    data: 0u16,
                    ptrs: 6u16,
                },
            )
        }),
    };
    const CAP: _p::Descriptor<_p::Struct<TestGenerics>> = _p::Descriptor::<
        _p::Struct<TestGenerics>,
    > {
        slot: 18u32,
        default: ::core::option::Option::None,
    };
    const GENERIC_CAP: _p::Descriptor<_p::AnyPtr> = _p::Descriptor::<_p::AnyPtr> {
        slot: 19u32,
        default: ::core::option::Option::None,
    };
}
impl<'p, T: _p::rpc::Table + 'p> test_use_generics::Reader<'p, T> {
    #[inline]
    pub fn basic(&self) -> _p::Accessor<'_, 'p, T, _p::Struct<TestGenerics>> {
        unsafe {
            <_p::Struct<
                TestGenerics,
            > as _p::field::FieldType>::accessor(&self.0, &TestUseGenerics::BASIC)
        }
    }
    #[inline]
    pub fn inner(&self) -> _p::Accessor<'_, 'p, T, _p::Struct<test_generics::Inner>> {
        unsafe {
            <_p::Struct<
                test_generics::Inner,
            > as _p::field::FieldType>::accessor(&self.0, &TestUseGenerics::INNER)
        }
    }
    #[inline]
    pub fn inner2(&self) -> _p::Accessor<'_, 'p, T, _p::Struct<test_generics::Inner2>> {
        unsafe {
            <_p::Struct<
                test_generics::Inner2,
            > as _p::field::FieldType>::accessor(&self.0, &TestUseGenerics::INNER2)
        }
    }
    #[inline]
    pub fn unspecified(&self) -> _p::Accessor<'_, 'p, T, _p::Struct<TestGenerics>> {
        unsafe {
            <_p::Struct<
                TestGenerics,
            > as _p::field::FieldType>::accessor(&self.0, &TestUseGenerics::UNSPECIFIED)
        }
    }
    #[inline]
    pub fn unspecified_inner(
        &self,
    ) -> _p::Accessor<'_, 'p, T, _p::Struct<test_generics::Inner2>> {
        unsafe {
            <_p::Struct<
                test_generics::Inner2,
            > as _p::field::FieldType>::accessor(
                &self.0,
                &TestUseGenerics::UNSPECIFIED_INNER,
            )
        }
    }
    #[inline]
    pub fn default(&self) -> _p::Accessor<'_, 'p, T, _p::Struct<TestGenerics>> {
        unsafe {
            <_p::Struct<
                TestGenerics,
            > as _p::field::FieldType>::accessor(&self.0, &TestUseGenerics::DEFAULT)
        }
    }
    #[inline]
    pub fn default_inner(
        &self,
    ) -> _p::Accessor<'_, 'p, T, _p::Struct<test_generics::Inner>> {
        unsafe {
            <_p::Struct<
                test_generics::Inner,
            > as _p::field::FieldType>::accessor(
                &self.0,
                &TestUseGenerics::DEFAULT_INNER,
            )
        }
    }
    #[inline]
    pub fn default_user(&self) -> _p::Accessor<'_, 'p, T, _p::Struct<TestUseGenerics>> {
        unsafe {
            <_p::Struct<
                TestUseGenerics,
            > as _p::field::FieldType>::accessor(&self.0, &TestUseGenerics::DEFAULT_USER)
        }
    }
    #[inline]
    pub fn wrapper(&self) -> _p::Accessor<'_, 'p, T, _p::Struct<TestGenericsWrapper>> {
        unsafe {
            <_p::Struct<
                TestGenericsWrapper,
            > as _p::field::FieldType>::accessor(&self.0, &TestUseGenerics::WRAPPER)
        }
    }
    #[inline]
    pub fn default_wrapper(
        &self,
    ) -> _p::Accessor<'_, 'p, T, _p::Struct<TestGenericsWrapper>> {
        unsafe {
            <_p::Struct<
                TestGenericsWrapper,
            > as _p::field::FieldType>::accessor(
                &self.0,
                &TestUseGenerics::DEFAULT_WRAPPER,
            )
        }
    }
    #[inline]
    pub fn default_wrapper2(
        &self,
    ) -> _p::Accessor<'_, 'p, T, _p::Struct<TestGenericsWrapper2>> {
        unsafe {
            <_p::Struct<
                TestGenericsWrapper2,
            > as _p::field::FieldType>::accessor(
                &self.0,
                &TestUseGenerics::DEFAULT_WRAPPER2,
            )
        }
    }
    #[inline]
    pub fn alias_foo(&self) -> _p::Accessor<'_, 'p, T, _p::Struct<TestAllTypes>> {
        unsafe {
            <_p::Struct<
                TestAllTypes,
            > as _p::field::FieldType>::accessor(&self.0, &TestUseGenerics::ALIAS_FOO)
        }
    }
    #[inline]
    pub fn alias_inner(
        &self,
    ) -> _p::Accessor<'_, 'p, T, _p::Struct<test_generics::Inner>> {
        unsafe {
            <_p::Struct<
                test_generics::Inner,
            > as _p::field::FieldType>::accessor(&self.0, &TestUseGenerics::ALIAS_INNER)
        }
    }
    #[inline]
    pub fn alias_inner2(
        &self,
    ) -> _p::Accessor<'_, 'p, T, _p::Struct<test_generics::Inner2>> {
        unsafe {
            <_p::Struct<
                test_generics::Inner2,
            > as _p::field::FieldType>::accessor(&self.0, &TestUseGenerics::ALIAS_INNER2)
        }
    }
    #[inline]
    pub fn alias_inner2_bind(
        &self,
    ) -> _p::Accessor<'_, 'p, T, _p::Struct<test_generics::Inner2>> {
        unsafe {
            <_p::Struct<
                test_generics::Inner2,
            > as _p::field::FieldType>::accessor(
                &self.0,
                &TestUseGenerics::ALIAS_INNER2_BIND,
            )
        }
    }
    #[inline]
    pub fn alias_inner2_text(
        &self,
    ) -> _p::Accessor<'_, 'p, T, _p::Struct<test_generics::Inner2>> {
        unsafe {
            <_p::Struct<
                test_generics::Inner2,
            > as _p::field::FieldType>::accessor(
                &self.0,
                &TestUseGenerics::ALIAS_INNER2_TEXT,
            )
        }
    }
    #[inline]
    pub fn alias_rev(&self) -> _p::Accessor<'_, 'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(
                &self.0,
                &TestUseGenerics::ALIAS_REV,
            )
        }
    }
    #[inline]
    pub fn use_aliases(
        &self,
    ) -> _p::Accessor<'_, 'p, T, _p::Struct<test_generics::UseAliases>> {
        unsafe {
            <_p::Struct<
                test_generics::UseAliases,
            > as _p::field::FieldType>::accessor(&self.0, &TestUseGenerics::USE_ALIASES)
        }
    }
    #[inline]
    pub fn cap(&self) -> _p::Accessor<'_, 'p, T, _p::Struct<TestGenerics>> {
        unsafe {
            <_p::Struct<
                TestGenerics,
            > as _p::field::FieldType>::accessor(&self.0, &TestUseGenerics::CAP)
        }
    }
    #[inline]
    pub fn generic_cap(&self) -> _p::Accessor<'_, 'p, T, _p::AnyPtr> {
        unsafe {
            <_p::AnyPtr as _p::field::FieldType>::accessor(
                &self.0,
                &TestUseGenerics::GENERIC_CAP,
            )
        }
    }
}
impl<'p, T: _p::rpc::Table + 'p> test_use_generics::Builder<'p, T> {
    #[inline]
    pub fn basic(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Struct<TestGenerics>> {
        unsafe {
            <_p::Struct<
                TestGenerics,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestUseGenerics::BASIC)
        }
    }
    #[inline]
    pub fn inner(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::Struct<test_generics::Inner>> {
        unsafe {
            <_p::Struct<
                test_generics::Inner,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestUseGenerics::INNER)
        }
    }
    #[inline]
    pub fn inner2(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::Struct<test_generics::Inner2>> {
        unsafe {
            <_p::Struct<
                test_generics::Inner2,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestUseGenerics::INNER2)
        }
    }
    #[inline]
    pub fn unspecified(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::Struct<TestGenerics>> {
        unsafe {
            <_p::Struct<
                TestGenerics,
            > as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestUseGenerics::UNSPECIFIED,
            )
        }
    }
    #[inline]
    pub fn unspecified_inner(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::Struct<test_generics::Inner2>> {
        unsafe {
            <_p::Struct<
                test_generics::Inner2,
            > as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestUseGenerics::UNSPECIFIED_INNER,
            )
        }
    }
    #[inline]
    pub fn default(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Struct<TestGenerics>> {
        unsafe {
            <_p::Struct<
                TestGenerics,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestUseGenerics::DEFAULT)
        }
    }
    #[inline]
    pub fn default_inner(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::Struct<test_generics::Inner>> {
        unsafe {
            <_p::Struct<
                test_generics::Inner,
            > as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestUseGenerics::DEFAULT_INNER,
            )
        }
    }
    #[inline]
    pub fn default_user(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::Struct<TestUseGenerics>> {
        unsafe {
            <_p::Struct<
                TestUseGenerics,
            > as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestUseGenerics::DEFAULT_USER,
            )
        }
    }
    #[inline]
    pub fn wrapper(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::Struct<TestGenericsWrapper>> {
        unsafe {
            <_p::Struct<
                TestGenericsWrapper,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestUseGenerics::WRAPPER)
        }
    }
    #[inline]
    pub fn default_wrapper(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::Struct<TestGenericsWrapper>> {
        unsafe {
            <_p::Struct<
                TestGenericsWrapper,
            > as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestUseGenerics::DEFAULT_WRAPPER,
            )
        }
    }
    #[inline]
    pub fn default_wrapper2(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::Struct<TestGenericsWrapper2>> {
        unsafe {
            <_p::Struct<
                TestGenericsWrapper2,
            > as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestUseGenerics::DEFAULT_WRAPPER2,
            )
        }
    }
    #[inline]
    pub fn alias_foo(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Struct<TestAllTypes>> {
        unsafe {
            <_p::Struct<
                TestAllTypes,
            > as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestUseGenerics::ALIAS_FOO,
            )
        }
    }
    #[inline]
    pub fn alias_inner(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::Struct<test_generics::Inner>> {
        unsafe {
            <_p::Struct<
                test_generics::Inner,
            > as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestUseGenerics::ALIAS_INNER,
            )
        }
    }
    #[inline]
    pub fn alias_inner2(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::Struct<test_generics::Inner2>> {
        unsafe {
            <_p::Struct<
                test_generics::Inner2,
            > as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestUseGenerics::ALIAS_INNER2,
            )
        }
    }
    #[inline]
    pub fn alias_inner2_bind(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::Struct<test_generics::Inner2>> {
        unsafe {
            <_p::Struct<
                test_generics::Inner2,
            > as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestUseGenerics::ALIAS_INNER2_BIND,
            )
        }
    }
    #[inline]
    pub fn alias_inner2_text(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::Struct<test_generics::Inner2>> {
        unsafe {
            <_p::Struct<
                test_generics::Inner2,
            > as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestUseGenerics::ALIAS_INNER2_TEXT,
            )
        }
    }
    #[inline]
    pub fn alias_rev(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestUseGenerics::ALIAS_REV,
            )
        }
    }
    #[inline]
    pub fn use_aliases(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::Struct<test_generics::UseAliases>> {
        unsafe {
            <_p::Struct<
                test_generics::UseAliases,
            > as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestUseGenerics::USE_ALIASES,
            )
        }
    }
    #[inline]
    pub fn cap(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Struct<TestGenerics>> {
        unsafe {
            <_p::Struct<
                TestGenerics,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestUseGenerics::CAP)
        }
    }
    #[inline]
    pub fn generic_cap(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::AnyPtr> {
        unsafe {
            <_p::AnyPtr as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestUseGenerics::GENERIC_CAP,
            )
        }
    }
    #[inline]
    pub fn into_basic(self) -> _p::AccessorOwned<'p, T, _p::Struct<TestGenerics>> {
        unsafe {
            <_p::Struct<
                TestGenerics,
            > as _p::field::FieldType>::accessor(self.0, &TestUseGenerics::BASIC)
        }
    }
    #[inline]
    pub fn into_inner(
        self,
    ) -> _p::AccessorOwned<'p, T, _p::Struct<test_generics::Inner>> {
        unsafe {
            <_p::Struct<
                test_generics::Inner,
            > as _p::field::FieldType>::accessor(self.0, &TestUseGenerics::INNER)
        }
    }
    #[inline]
    pub fn into_inner2(
        self,
    ) -> _p::AccessorOwned<'p, T, _p::Struct<test_generics::Inner2>> {
        unsafe {
            <_p::Struct<
                test_generics::Inner2,
            > as _p::field::FieldType>::accessor(self.0, &TestUseGenerics::INNER2)
        }
    }
    #[inline]
    pub fn into_unspecified(self) -> _p::AccessorOwned<'p, T, _p::Struct<TestGenerics>> {
        unsafe {
            <_p::Struct<
                TestGenerics,
            > as _p::field::FieldType>::accessor(self.0, &TestUseGenerics::UNSPECIFIED)
        }
    }
    #[inline]
    pub fn into_unspecified_inner(
        self,
    ) -> _p::AccessorOwned<'p, T, _p::Struct<test_generics::Inner2>> {
        unsafe {
            <_p::Struct<
                test_generics::Inner2,
            > as _p::field::FieldType>::accessor(
                self.0,
                &TestUseGenerics::UNSPECIFIED_INNER,
            )
        }
    }
    #[inline]
    pub fn into_default(self) -> _p::AccessorOwned<'p, T, _p::Struct<TestGenerics>> {
        unsafe {
            <_p::Struct<
                TestGenerics,
            > as _p::field::FieldType>::accessor(self.0, &TestUseGenerics::DEFAULT)
        }
    }
    #[inline]
    pub fn into_default_inner(
        self,
    ) -> _p::AccessorOwned<'p, T, _p::Struct<test_generics::Inner>> {
        unsafe {
            <_p::Struct<
                test_generics::Inner,
            > as _p::field::FieldType>::accessor(self.0, &TestUseGenerics::DEFAULT_INNER)
        }
    }
    #[inline]
    pub fn into_default_user(
        self,
    ) -> _p::AccessorOwned<'p, T, _p::Struct<TestUseGenerics>> {
        unsafe {
            <_p::Struct<
                TestUseGenerics,
            > as _p::field::FieldType>::accessor(self.0, &TestUseGenerics::DEFAULT_USER)
        }
    }
    #[inline]
    pub fn into_wrapper(
        self,
    ) -> _p::AccessorOwned<'p, T, _p::Struct<TestGenericsWrapper>> {
        unsafe {
            <_p::Struct<
                TestGenericsWrapper,
            > as _p::field::FieldType>::accessor(self.0, &TestUseGenerics::WRAPPER)
        }
    }
    #[inline]
    pub fn into_default_wrapper(
        self,
    ) -> _p::AccessorOwned<'p, T, _p::Struct<TestGenericsWrapper>> {
        unsafe {
            <_p::Struct<
                TestGenericsWrapper,
            > as _p::field::FieldType>::accessor(
                self.0,
                &TestUseGenerics::DEFAULT_WRAPPER,
            )
        }
    }
    #[inline]
    pub fn into_default_wrapper2(
        self,
    ) -> _p::AccessorOwned<'p, T, _p::Struct<TestGenericsWrapper2>> {
        unsafe {
            <_p::Struct<
                TestGenericsWrapper2,
            > as _p::field::FieldType>::accessor(
                self.0,
                &TestUseGenerics::DEFAULT_WRAPPER2,
            )
        }
    }
    #[inline]
    pub fn into_alias_foo(self) -> _p::AccessorOwned<'p, T, _p::Struct<TestAllTypes>> {
        unsafe {
            <_p::Struct<
                TestAllTypes,
            > as _p::field::FieldType>::accessor(self.0, &TestUseGenerics::ALIAS_FOO)
        }
    }
    #[inline]
    pub fn into_alias_inner(
        self,
    ) -> _p::AccessorOwned<'p, T, _p::Struct<test_generics::Inner>> {
        unsafe {
            <_p::Struct<
                test_generics::Inner,
            > as _p::field::FieldType>::accessor(self.0, &TestUseGenerics::ALIAS_INNER)
        }
    }
    #[inline]
    pub fn into_alias_inner2(
        self,
    ) -> _p::AccessorOwned<'p, T, _p::Struct<test_generics::Inner2>> {
        unsafe {
            <_p::Struct<
                test_generics::Inner2,
            > as _p::field::FieldType>::accessor(self.0, &TestUseGenerics::ALIAS_INNER2)
        }
    }
    #[inline]
    pub fn into_alias_inner2_bind(
        self,
    ) -> _p::AccessorOwned<'p, T, _p::Struct<test_generics::Inner2>> {
        unsafe {
            <_p::Struct<
                test_generics::Inner2,
            > as _p::field::FieldType>::accessor(
                self.0,
                &TestUseGenerics::ALIAS_INNER2_BIND,
            )
        }
    }
    #[inline]
    pub fn into_alias_inner2_text(
        self,
    ) -> _p::AccessorOwned<'p, T, _p::Struct<test_generics::Inner2>> {
        unsafe {
            <_p::Struct<
                test_generics::Inner2,
            > as _p::field::FieldType>::accessor(
                self.0,
                &TestUseGenerics::ALIAS_INNER2_TEXT,
            )
        }
    }
    #[inline]
    pub fn into_alias_rev(self) -> _p::AccessorOwned<'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(
                self.0,
                &TestUseGenerics::ALIAS_REV,
            )
        }
    }
    #[inline]
    pub fn into_use_aliases(
        self,
    ) -> _p::AccessorOwned<'p, T, _p::Struct<test_generics::UseAliases>> {
        unsafe {
            <_p::Struct<
                test_generics::UseAliases,
            > as _p::field::FieldType>::accessor(self.0, &TestUseGenerics::USE_ALIASES)
        }
    }
    #[inline]
    pub fn into_cap(self) -> _p::AccessorOwned<'p, T, _p::Struct<TestGenerics>> {
        unsafe {
            <_p::Struct<
                TestGenerics,
            > as _p::field::FieldType>::accessor(self.0, &TestUseGenerics::CAP)
        }
    }
    #[inline]
    pub fn into_generic_cap(self) -> _p::AccessorOwned<'p, T, _p::AnyPtr> {
        unsafe {
            <_p::AnyPtr as _p::field::FieldType>::accessor(
                self.0,
                &TestUseGenerics::GENERIC_CAP,
            )
        }
    }
}
pub mod test_use_generics {
    use super::{__file, __imports, _p};
    pub type Reader<'a, T = _p::rpc::Empty> = super::TestUseGenerics<
        _p::StructReader<'a, T>,
    >;
    pub type Builder<'a, T = _p::rpc::Empty> = super::TestUseGenerics<
        _p::StructBuilder<'a, T>,
    >;
}
#[derive(Clone)]
pub struct TestEmptyStruct<T = _p::Family>(T);
impl _p::ty::SchemaType for TestEmptyStruct {
    const ID: u64 = 14220547125180143324u64;
}
impl<T> _p::IntoFamily for TestEmptyStruct<T> {
    type Family = TestEmptyStruct;
}
impl<T: _p::Capable> _p::Capable for TestEmptyStruct<T> {
    type Table = T::Table;
    type Imbued = T::Imbued;
    type ImbuedWith<T2: _p::rpc::Table> = TestEmptyStruct<T::ImbuedWith<T2>>;
    #[inline]
    fn imbued(&self) -> &Self::Imbued {
        self.0.imbued()
    }
    #[inline]
    fn imbue_release<T2: _p::rpc::Table>(
        self,
        new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
    ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
        let (imbued, old) = self.0.imbue_release(new_table);
        (TestEmptyStruct(imbued), old)
    }
    #[inline]
    fn imbue_release_into<U>(&self, other: U) -> (U::ImbuedWith<Self::Table>, U::Imbued)
    where
        U: _p::Capable,
        U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
    {
        self.0.imbue_release_into(other)
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_empty_struct::Reader<'a, T> {
    type Ptr = _p::StructReader<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
for test_empty_struct::Reader<'a, T> {
    #[inline]
    fn from(ptr: _p::StructReader<'a, T>) -> Self {
        TestEmptyStruct(ptr)
    }
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_empty_struct::Reader<'a, T>>
for _p::StructReader<'a, T> {
    #[inline]
    fn from(reader: test_empty_struct::Reader<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
for test_empty_struct::Reader<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructReader<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructReader for test_empty_struct::Reader<'a, T> {}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_empty_struct::Builder<'a, T> {
    type Ptr = _p::StructBuilder<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_empty_struct::Builder<'a, T>>
for _p::StructBuilder<'a, T> {
    #[inline]
    fn from(reader: test_empty_struct::Builder<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
for test_empty_struct::Builder<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
for test_empty_struct::Builder<'a, T> {
    #[inline]
    fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
        &mut self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for test_empty_struct::Builder<'a, T> {
    unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
        Self(ptr)
    }
}
impl _p::StructView for TestEmptyStruct {
    type Reader<'a, T: _p::rpc::Table> = test_empty_struct::Reader<'a, T>;
    type Builder<'a, T: _p::rpc::Table> = test_empty_struct::Builder<'a, T>;
}
impl _p::ty::Struct for TestEmptyStruct {
    const SIZE: _p::StructSize = _p::StructSize {
        data: 0u16,
        ptrs: 0u16,
    };
}
impl TestEmptyStruct {}
impl<'p, T: _p::rpc::Table + 'p> test_empty_struct::Reader<'p, T> {}
impl<'p, T: _p::rpc::Table + 'p> test_empty_struct::Builder<'p, T> {}
pub mod test_empty_struct {
    use super::{__file, __imports, _p};
    pub type Reader<'a, T = _p::rpc::Empty> = super::TestEmptyStruct<
        _p::StructReader<'a, T>,
    >;
    pub type Builder<'a, T = _p::rpc::Empty> = super::TestEmptyStruct<
        _p::StructBuilder<'a, T>,
    >;
}
#[derive(Clone)]
pub struct TestConstants<T = _p::Family>(T);
impl _p::ty::SchemaType for TestConstants {
    const ID: u64 = 12388686092088975509u64;
}
impl<T> _p::IntoFamily for TestConstants<T> {
    type Family = TestConstants;
}
impl<T: _p::Capable> _p::Capable for TestConstants<T> {
    type Table = T::Table;
    type Imbued = T::Imbued;
    type ImbuedWith<T2: _p::rpc::Table> = TestConstants<T::ImbuedWith<T2>>;
    #[inline]
    fn imbued(&self) -> &Self::Imbued {
        self.0.imbued()
    }
    #[inline]
    fn imbue_release<T2: _p::rpc::Table>(
        self,
        new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
    ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
        let (imbued, old) = self.0.imbue_release(new_table);
        (TestConstants(imbued), old)
    }
    #[inline]
    fn imbue_release_into<U>(&self, other: U) -> (U::ImbuedWith<Self::Table>, U::Imbued)
    where
        U: _p::Capable,
        U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
    {
        self.0.imbue_release_into(other)
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_constants::Reader<'a, T> {
    type Ptr = _p::StructReader<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
for test_constants::Reader<'a, T> {
    #[inline]
    fn from(ptr: _p::StructReader<'a, T>) -> Self {
        TestConstants(ptr)
    }
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_constants::Reader<'a, T>>
for _p::StructReader<'a, T> {
    #[inline]
    fn from(reader: test_constants::Reader<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
for test_constants::Reader<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructReader<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructReader for test_constants::Reader<'a, T> {}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_constants::Builder<'a, T> {
    type Ptr = _p::StructBuilder<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_constants::Builder<'a, T>>
for _p::StructBuilder<'a, T> {
    #[inline]
    fn from(reader: test_constants::Builder<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
for test_constants::Builder<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
for test_constants::Builder<'a, T> {
    #[inline]
    fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
        &mut self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for test_constants::Builder<'a, T> {
    unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
        Self(ptr)
    }
}
impl _p::StructView for TestConstants {
    type Reader<'a, T: _p::rpc::Table> = test_constants::Reader<'a, T>;
    type Builder<'a, T: _p::rpc::Table> = test_constants::Builder<'a, T>;
}
impl _p::ty::Struct for TestConstants {
    const SIZE: _p::StructSize = _p::StructSize {
        data: 0u16,
        ptrs: 0u16,
    };
}
impl TestConstants {}
impl<'p, T: _p::rpc::Table + 'p> test_constants::Reader<'p, T> {}
impl<'p, T: _p::rpc::Table + 'p> test_constants::Builder<'p, T> {}
pub mod test_constants {
    use super::{__file, __imports, _p};
    pub type Reader<'a, T = _p::rpc::Empty> = super::TestConstants<
        _p::StructReader<'a, T>,
    >;
    pub type Builder<'a, T = _p::rpc::Empty> = super::TestConstants<
        _p::StructBuilder<'a, T>,
    >;
    pub const VOID_CONST: () = ();
    pub const BOOL_CONST: bool = true;
    pub const INT8_CONST: i8 = -123i8;
    pub const INT16_CONST: i16 = -12345i16;
    pub const INT32_CONST: i32 = -12345678i32;
    pub const INT64_CONST: i64 = -123456789012345i64;
    pub const UINT8_CONST: u8 = 234u8;
    pub const UINT16_CONST: u16 = 45678u16;
    pub const UINT32_CONST: u32 = 3456789012u32;
    pub const UINT64_CONST: u64 = 12345678901234567890u64;
    pub const FLOAT32_CONST: f32 = 1234.5f32;
    pub const FLOAT64_CONST: f64 = -123000000000000000000000000000000000000000000000f64;
    pub const TEXT_CONST: _p::ty::ConstPtr<_p::Text> = unsafe {
        _p::ty::ConstPtr::new(
            &[
                _p::Word([1u8, 0u8, 0u8, 0u8, 34u8, 0u8, 0u8, 0u8]),
                _p::Word([102u8, 111u8, 111u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            ],
        )
    };
    pub const DATA_CONST: _p::ty::ConstPtr<_p::Data> = unsafe {
        _p::ty::ConstPtr::new(
            &[
                _p::Word([1u8, 0u8, 0u8, 0u8, 26u8, 0u8, 0u8, 0u8]),
                _p::Word([98u8, 97u8, 114u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            ],
        )
    };
    pub const STRUCT_CONST: _p::ty::ConstPtr<_p::Struct<super::TestAllTypes>> = unsafe {
        _p::ty::ConstPtr::new(
            &[
                _p::Word([0u8, 0u8, 0u8, 0u8, 6u8, 0u8, 20u8, 0u8]),
                _p::Word([1u8, 244u8, 128u8, 13u8, 14u8, 16u8, 76u8, 251u8]),
                _p::Word([78u8, 115u8, 232u8, 56u8, 166u8, 51u8, 0u8, 0u8]),
                _p::Word([90u8, 0u8, 210u8, 4u8, 20u8, 136u8, 98u8, 3u8]),
                _p::Word([210u8, 10u8, 111u8, 18u8, 33u8, 25u8, 204u8, 4u8]),
                _p::Word([95u8, 112u8, 9u8, 175u8, 2u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 144u8, 117u8, 64u8]),
                _p::Word([77u8, 0u8, 0u8, 0u8, 34u8, 0u8, 0u8, 0u8]),
                _p::Word([77u8, 0u8, 0u8, 0u8, 26u8, 0u8, 0u8, 0u8]),
                _p::Word([76u8, 0u8, 0u8, 0u8, 6u8, 0u8, 20u8, 0u8]),
                _p::Word([1u8, 0u8, 0u8, 0u8, 24u8, 0u8, 0u8, 0u8]),
                _p::Word([33u8, 1u8, 0u8, 0u8, 41u8, 0u8, 0u8, 0u8]),
                _p::Word([33u8, 1u8, 0u8, 0u8, 34u8, 0u8, 0u8, 0u8]),
                _p::Word([33u8, 1u8, 0u8, 0u8, 35u8, 0u8, 0u8, 0u8]),
                _p::Word([33u8, 1u8, 0u8, 0u8, 36u8, 0u8, 0u8, 0u8]),
                _p::Word([37u8, 1u8, 0u8, 0u8, 37u8, 0u8, 0u8, 0u8]),
                _p::Word([49u8, 1u8, 0u8, 0u8, 34u8, 0u8, 0u8, 0u8]),
                _p::Word([49u8, 1u8, 0u8, 0u8, 35u8, 0u8, 0u8, 0u8]),
                _p::Word([49u8, 1u8, 0u8, 0u8, 36u8, 0u8, 0u8, 0u8]),
                _p::Word([53u8, 1u8, 0u8, 0u8, 37u8, 0u8, 0u8, 0u8]),
                _p::Word([65u8, 1u8, 0u8, 0u8, 52u8, 0u8, 0u8, 0u8]),
                _p::Word([73u8, 1u8, 0u8, 0u8, 53u8, 0u8, 0u8, 0u8]),
                _p::Word([93u8, 1u8, 0u8, 0u8, 30u8, 0u8, 0u8, 0u8]),
                _p::Word([113u8, 1u8, 0u8, 0u8, 30u8, 0u8, 0u8, 0u8]),
                _p::Word([133u8, 1u8, 0u8, 0u8, 119u8, 2u8, 0u8, 0u8]),
                _p::Word([213u8, 2u8, 0u8, 0u8, 27u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([98u8, 97u8, 122u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([113u8, 117u8, 120u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([77u8, 0u8, 0u8, 0u8, 58u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([72u8, 0u8, 0u8, 0u8, 6u8, 0u8, 20u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([110u8, 101u8, 115u8, 116u8, 101u8, 100u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([77u8, 0u8, 0u8, 0u8, 114u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([114u8, 101u8, 97u8, 108u8, 108u8, 121u8, 32u8, 110u8]),
                _p::Word([101u8, 115u8, 116u8, 101u8, 100u8, 0u8, 0u8, 0u8]),
                _p::Word([26u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([12u8, 222u8, 128u8, 127u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([210u8, 4u8, 210u8, 233u8, 0u8, 128u8, 255u8, 127u8]),
                _p::Word([78u8, 97u8, 188u8, 0u8, 64u8, 211u8, 160u8, 250u8]),
                _p::Word([0u8, 0u8, 0u8, 128u8, 255u8, 255u8, 255u8, 127u8]),
                _p::Word([121u8, 223u8, 13u8, 134u8, 72u8, 112u8, 0u8, 0u8]),
                _p::Word([46u8, 117u8, 19u8, 253u8, 138u8, 150u8, 253u8, 255u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 128u8]),
                _p::Word([255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 127u8]),
                _p::Word([12u8, 34u8, 0u8, 255u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([210u8, 4u8, 46u8, 22u8, 0u8, 0u8, 255u8, 255u8]),
                _p::Word([78u8, 97u8, 188u8, 0u8, 192u8, 44u8, 95u8, 5u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 255u8, 255u8, 255u8, 255u8]),
                _p::Word([121u8, 223u8, 13u8, 134u8, 72u8, 112u8, 0u8, 0u8]),
                _p::Word([210u8, 138u8, 236u8, 2u8, 117u8, 105u8, 2u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 56u8, 180u8, 150u8, 73u8]),
                _p::Word([194u8, 189u8, 240u8, 124u8, 194u8, 189u8, 240u8, 252u8]),
                _p::Word([234u8, 28u8, 8u8, 2u8, 234u8, 28u8, 8u8, 130u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([64u8, 222u8, 119u8, 131u8, 33u8, 18u8, 220u8, 66u8]),
                _p::Word([41u8, 144u8, 35u8, 202u8, 229u8, 200u8, 118u8, 127u8]),
                _p::Word([41u8, 144u8, 35u8, 202u8, 229u8, 200u8, 118u8, 255u8]),
                _p::Word([145u8, 247u8, 80u8, 55u8, 158u8, 120u8, 102u8, 0u8]),
                _p::Word([145u8, 247u8, 80u8, 55u8, 158u8, 120u8, 102u8, 128u8]),
                _p::Word([9u8, 0u8, 0u8, 0u8, 42u8, 0u8, 0u8, 0u8]),
                _p::Word([9u8, 0u8, 0u8, 0u8, 50u8, 0u8, 0u8, 0u8]),
                _p::Word([9u8, 0u8, 0u8, 0u8, 58u8, 0u8, 0u8, 0u8]),
                _p::Word([113u8, 117u8, 117u8, 120u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([99u8, 111u8, 114u8, 103u8, 101u8, 0u8, 0u8, 0u8]),
                _p::Word([103u8, 114u8, 97u8, 117u8, 108u8, 116u8, 0u8, 0u8]),
                _p::Word([9u8, 0u8, 0u8, 0u8, 50u8, 0u8, 0u8, 0u8]),
                _p::Word([9u8, 0u8, 0u8, 0u8, 42u8, 0u8, 0u8, 0u8]),
                _p::Word([9u8, 0u8, 0u8, 0u8, 34u8, 0u8, 0u8, 0u8]),
                _p::Word([103u8, 97u8, 114u8, 112u8, 108u8, 121u8, 0u8, 0u8]),
                _p::Word([119u8, 97u8, 108u8, 100u8, 111u8, 0u8, 0u8, 0u8]),
                _p::Word([102u8, 114u8, 101u8, 100u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([12u8, 0u8, 0u8, 0u8, 6u8, 0u8, 20u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([29u8, 1u8, 0u8, 0u8, 122u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([189u8, 0u8, 0u8, 0u8, 122u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([93u8, 0u8, 0u8, 0u8, 122u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([120u8, 32u8, 115u8, 116u8, 114u8, 117u8, 99u8, 116u8]),
                _p::Word([108u8, 105u8, 115u8, 116u8, 32u8, 49u8, 0u8, 0u8]),
                _p::Word([120u8, 32u8, 115u8, 116u8, 114u8, 117u8, 99u8, 116u8]),
                _p::Word([108u8, 105u8, 115u8, 116u8, 32u8, 50u8, 0u8, 0u8]),
                _p::Word([120u8, 32u8, 115u8, 116u8, 114u8, 117u8, 99u8, 116u8]),
                _p::Word([108u8, 105u8, 115u8, 116u8, 32u8, 51u8, 0u8, 0u8]),
                _p::Word([3u8, 0u8, 1u8, 0u8, 6u8, 0u8, 0u8, 0u8]),
            ],
        )
    };
    pub const ENUM_CONST: super::TestEnum = super::TestEnum::Corge;
    pub const VOID_LIST_CONST: _p::ty::ConstPtr<_p::List<()>> = unsafe {
        _p::ty::ConstPtr::new(&[_p::Word([1u8, 0u8, 0u8, 0u8, 48u8, 0u8, 0u8, 0u8])])
    };
    pub const BOOL_LIST_CONST: _p::ty::ConstPtr<_p::List<bool>> = unsafe {
        _p::ty::ConstPtr::new(
            &[
                _p::Word([1u8, 0u8, 0u8, 0u8, 33u8, 0u8, 0u8, 0u8]),
                _p::Word([9u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            ],
        )
    };
    pub const INT8_LIST_CONST: _p::ty::ConstPtr<_p::List<i8>> = unsafe {
        _p::ty::ConstPtr::new(
            &[
                _p::Word([1u8, 0u8, 0u8, 0u8, 18u8, 0u8, 0u8, 0u8]),
                _p::Word([111u8, 145u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            ],
        )
    };
    pub const INT16_LIST_CONST: _p::ty::ConstPtr<_p::List<i16>> = unsafe {
        _p::ty::ConstPtr::new(
            &[
                _p::Word([1u8, 0u8, 0u8, 0u8, 19u8, 0u8, 0u8, 0u8]),
                _p::Word([103u8, 43u8, 153u8, 212u8, 0u8, 0u8, 0u8, 0u8]),
            ],
        )
    };
    pub const INT32_LIST_CONST: _p::ty::ConstPtr<_p::List<i32>> = unsafe {
        _p::ty::ConstPtr::new(
            &[
                _p::Word([1u8, 0u8, 0u8, 0u8, 20u8, 0u8, 0u8, 0u8]),
                _p::Word([199u8, 107u8, 159u8, 6u8, 57u8, 148u8, 96u8, 249u8]),
            ],
        )
    };
    pub const INT64_LIST_CONST: _p::ty::ConstPtr<_p::List<i64>> = unsafe {
        _p::ty::ConstPtr::new(
            &[
                _p::Word([1u8, 0u8, 0u8, 0u8, 21u8, 0u8, 0u8, 0u8]),
                _p::Word([199u8, 113u8, 196u8, 43u8, 171u8, 117u8, 107u8, 15u8]),
                _p::Word([57u8, 142u8, 59u8, 212u8, 84u8, 138u8, 148u8, 240u8]),
            ],
        )
    };
    pub const UINT8_LIST_CONST: _p::ty::ConstPtr<_p::List<u8>> = unsafe {
        _p::ty::ConstPtr::new(
            &[
                _p::Word([1u8, 0u8, 0u8, 0u8, 18u8, 0u8, 0u8, 0u8]),
                _p::Word([111u8, 222u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            ],
        )
    };
    pub const UINT16_LIST_CONST: _p::ty::ConstPtr<_p::List<u16>> = unsafe {
        _p::ty::ConstPtr::new(
            &[
                _p::Word([1u8, 0u8, 0u8, 0u8, 19u8, 0u8, 0u8, 0u8]),
                _p::Word([53u8, 130u8, 156u8, 173u8, 0u8, 0u8, 0u8, 0u8]),
            ],
        )
    };
    pub const UINT32_LIST_CONST: _p::ty::ConstPtr<_p::List<u32>> = unsafe {
        _p::ty::ConstPtr::new(
            &[
                _p::Word([1u8, 0u8, 0u8, 0u8, 12u8, 0u8, 0u8, 0u8]),
                _p::Word([85u8, 161u8, 174u8, 198u8, 0u8, 0u8, 0u8, 0u8]),
            ],
        )
    };
    pub const UINT64_LIST_CONST: _p::ty::ConstPtr<_p::List<u64>> = unsafe {
        _p::ty::ConstPtr::new(
            &[
                _p::Word([1u8, 0u8, 0u8, 0u8, 13u8, 0u8, 0u8, 0u8]),
                _p::Word([199u8, 113u8, 172u8, 181u8, 175u8, 152u8, 50u8, 154u8]),
            ],
        )
    };
    pub const FLOAT32_LIST_CONST: _p::ty::ConstPtr<_p::List<f32>> = unsafe {
        _p::ty::ConstPtr::new(
            &[
                _p::Word([1u8, 0u8, 0u8, 0u8, 36u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 156u8, 173u8, 69u8, 0u8, 0u8, 128u8, 127u8]),
                _p::Word([0u8, 0u8, 128u8, 255u8, 0u8, 0u8, 192u8, 127u8]),
            ],
        )
    };
    pub const FLOAT64_LIST_CONST: _p::ty::ConstPtr<_p::List<f64>> = unsafe {
        _p::ty::ConstPtr::new(
            &[
                _p::Word([1u8, 0u8, 0u8, 0u8, 37u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 192u8, 97u8, 190u8, 64u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 240u8, 127u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 240u8, 255u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 248u8, 127u8]),
            ],
        )
    };
    pub const TEXT_LIST_CONST: _p::ty::ConstPtr<_p::List<_p::Text>> = unsafe {
        _p::ty::ConstPtr::new(
            &[
                _p::Word([1u8, 0u8, 0u8, 0u8, 30u8, 0u8, 0u8, 0u8]),
                _p::Word([9u8, 0u8, 0u8, 0u8, 50u8, 0u8, 0u8, 0u8]),
                _p::Word([9u8, 0u8, 0u8, 0u8, 50u8, 0u8, 0u8, 0u8]),
                _p::Word([9u8, 0u8, 0u8, 0u8, 42u8, 0u8, 0u8, 0u8]),
                _p::Word([112u8, 108u8, 117u8, 103u8, 104u8, 0u8, 0u8, 0u8]),
                _p::Word([120u8, 121u8, 122u8, 122u8, 121u8, 0u8, 0u8, 0u8]),
                _p::Word([116u8, 104u8, 117u8, 100u8, 0u8, 0u8, 0u8, 0u8]),
            ],
        )
    };
    pub const DATA_LIST_CONST: _p::ty::ConstPtr<_p::List<_p::Data>> = unsafe {
        _p::ty::ConstPtr::new(
            &[
                _p::Word([1u8, 0u8, 0u8, 0u8, 30u8, 0u8, 0u8, 0u8]),
                _p::Word([9u8, 0u8, 0u8, 0u8, 34u8, 0u8, 0u8, 0u8]),
                _p::Word([9u8, 0u8, 0u8, 0u8, 74u8, 0u8, 0u8, 0u8]),
                _p::Word([13u8, 0u8, 0u8, 0u8, 58u8, 0u8, 0u8, 0u8]),
                _p::Word([111u8, 111u8, 112u8, 115u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([101u8, 120u8, 104u8, 97u8, 117u8, 115u8, 116u8, 101u8]),
                _p::Word([100u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([114u8, 102u8, 99u8, 51u8, 48u8, 57u8, 50u8, 0u8]),
            ],
        )
    };
    pub const STRUCT_LIST_CONST: _p::ty::ConstPtr<
        _p::List<_p::Struct<super::TestAllTypes>>,
    > = unsafe {
        _p::ty::ConstPtr::new(
            &[
                _p::Word([1u8, 0u8, 0u8, 0u8, 119u8, 2u8, 0u8, 0u8]),
                _p::Word([12u8, 0u8, 0u8, 0u8, 6u8, 0u8, 20u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([29u8, 1u8, 0u8, 0u8, 106u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([189u8, 0u8, 0u8, 0u8, 106u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([93u8, 0u8, 0u8, 0u8, 106u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([115u8, 116u8, 114u8, 117u8, 99u8, 116u8, 108u8, 105u8]),
                _p::Word([115u8, 116u8, 32u8, 49u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([115u8, 116u8, 114u8, 117u8, 99u8, 116u8, 108u8, 105u8]),
                _p::Word([115u8, 116u8, 32u8, 50u8, 0u8, 0u8, 0u8, 0u8]),
                _p::Word([115u8, 116u8, 114u8, 117u8, 99u8, 116u8, 108u8, 105u8]),
                _p::Word([115u8, 116u8, 32u8, 51u8, 0u8, 0u8, 0u8, 0u8]),
            ],
        )
    };
    pub const ENUM_LIST_CONST: _p::ty::ConstPtr<_p::List<_p::Enum<super::TestEnum>>> = unsafe {
        _p::ty::ConstPtr::new(
            &[
                _p::Word([1u8, 0u8, 0u8, 0u8, 19u8, 0u8, 0u8, 0u8]),
                _p::Word([0u8, 0u8, 7u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            ],
        )
    };
}
pub const GLOBAL_INT: u32 = 12345u32;
pub const GLOBAL_TEXT: _p::ty::ConstPtr<_p::Text> = unsafe {
    _p::ty::ConstPtr::new(
        &[
            _p::Word([1u8, 0u8, 0u8, 0u8, 58u8, 0u8, 0u8, 0u8]),
            _p::Word([102u8, 111u8, 111u8, 98u8, 97u8, 114u8, 0u8, 0u8]),
        ],
    )
};
pub const GLOBAL_STRUCT: _p::ty::ConstPtr<_p::Struct<TestAllTypes>> = unsafe {
    _p::ty::ConstPtr::new(
        &[
            _p::Word([0u8, 0u8, 0u8, 0u8, 6u8, 0u8, 20u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 49u8, 212u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
        ],
    )
};
pub const GLOBAL_PRINTABLE_STRUCT: _p::ty::ConstPtr<
    _p::Struct<TestPrintInlineStructs>,
> = unsafe {
    _p::ty::ConstPtr::new(
        &[
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 2u8, 0u8]),
            _p::Word([5u8, 0u8, 0u8, 0u8, 34u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([102u8, 111u8, 111u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
        ],
    )
};
pub const DERIVED_CONSTANT: _p::ty::ConstPtr<_p::Struct<TestAllTypes>> = unsafe {
    _p::ty::ConstPtr::new(
        &[
            _p::Word([0u8, 0u8, 0u8, 0u8, 6u8, 0u8, 20u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 57u8, 48u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([77u8, 0u8, 0u8, 0u8, 34u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([72u8, 0u8, 0u8, 0u8, 6u8, 0u8, 20u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([117u8, 3u8, 0u8, 0u8, 19u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([77u8, 3u8, 0u8, 0u8, 119u8, 2u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([102u8, 111u8, 111u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([1u8, 244u8, 128u8, 13u8, 14u8, 16u8, 76u8, 251u8]),
            _p::Word([78u8, 115u8, 232u8, 56u8, 166u8, 51u8, 0u8, 0u8]),
            _p::Word([90u8, 0u8, 210u8, 4u8, 20u8, 136u8, 98u8, 3u8]),
            _p::Word([210u8, 10u8, 111u8, 18u8, 33u8, 25u8, 204u8, 4u8]),
            _p::Word([95u8, 112u8, 9u8, 175u8, 2u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 144u8, 117u8, 64u8]),
            _p::Word([77u8, 0u8, 0u8, 0u8, 34u8, 0u8, 0u8, 0u8]),
            _p::Word([77u8, 0u8, 0u8, 0u8, 26u8, 0u8, 0u8, 0u8]),
            _p::Word([76u8, 0u8, 0u8, 0u8, 6u8, 0u8, 20u8, 0u8]),
            _p::Word([1u8, 0u8, 0u8, 0u8, 24u8, 0u8, 0u8, 0u8]),
            _p::Word([33u8, 1u8, 0u8, 0u8, 41u8, 0u8, 0u8, 0u8]),
            _p::Word([33u8, 1u8, 0u8, 0u8, 34u8, 0u8, 0u8, 0u8]),
            _p::Word([33u8, 1u8, 0u8, 0u8, 35u8, 0u8, 0u8, 0u8]),
            _p::Word([33u8, 1u8, 0u8, 0u8, 36u8, 0u8, 0u8, 0u8]),
            _p::Word([37u8, 1u8, 0u8, 0u8, 37u8, 0u8, 0u8, 0u8]),
            _p::Word([49u8, 1u8, 0u8, 0u8, 34u8, 0u8, 0u8, 0u8]),
            _p::Word([49u8, 1u8, 0u8, 0u8, 35u8, 0u8, 0u8, 0u8]),
            _p::Word([49u8, 1u8, 0u8, 0u8, 36u8, 0u8, 0u8, 0u8]),
            _p::Word([53u8, 1u8, 0u8, 0u8, 37u8, 0u8, 0u8, 0u8]),
            _p::Word([65u8, 1u8, 0u8, 0u8, 52u8, 0u8, 0u8, 0u8]),
            _p::Word([73u8, 1u8, 0u8, 0u8, 53u8, 0u8, 0u8, 0u8]),
            _p::Word([93u8, 1u8, 0u8, 0u8, 30u8, 0u8, 0u8, 0u8]),
            _p::Word([113u8, 1u8, 0u8, 0u8, 30u8, 0u8, 0u8, 0u8]),
            _p::Word([133u8, 1u8, 0u8, 0u8, 119u8, 2u8, 0u8, 0u8]),
            _p::Word([213u8, 2u8, 0u8, 0u8, 27u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([98u8, 97u8, 122u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([113u8, 117u8, 120u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([77u8, 0u8, 0u8, 0u8, 58u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([72u8, 0u8, 0u8, 0u8, 6u8, 0u8, 20u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([110u8, 101u8, 115u8, 116u8, 101u8, 100u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([77u8, 0u8, 0u8, 0u8, 114u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([114u8, 101u8, 97u8, 108u8, 108u8, 121u8, 32u8, 110u8]),
            _p::Word([101u8, 115u8, 116u8, 101u8, 100u8, 0u8, 0u8, 0u8]),
            _p::Word([26u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([12u8, 222u8, 128u8, 127u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([210u8, 4u8, 210u8, 233u8, 0u8, 128u8, 255u8, 127u8]),
            _p::Word([78u8, 97u8, 188u8, 0u8, 64u8, 211u8, 160u8, 250u8]),
            _p::Word([0u8, 0u8, 0u8, 128u8, 255u8, 255u8, 255u8, 127u8]),
            _p::Word([121u8, 223u8, 13u8, 134u8, 72u8, 112u8, 0u8, 0u8]),
            _p::Word([46u8, 117u8, 19u8, 253u8, 138u8, 150u8, 253u8, 255u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 128u8]),
            _p::Word([255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 127u8]),
            _p::Word([12u8, 34u8, 0u8, 255u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([210u8, 4u8, 46u8, 22u8, 0u8, 0u8, 255u8, 255u8]),
            _p::Word([78u8, 97u8, 188u8, 0u8, 192u8, 44u8, 95u8, 5u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 255u8, 255u8, 255u8, 255u8]),
            _p::Word([121u8, 223u8, 13u8, 134u8, 72u8, 112u8, 0u8, 0u8]),
            _p::Word([210u8, 138u8, 236u8, 2u8, 117u8, 105u8, 2u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 56u8, 180u8, 150u8, 73u8]),
            _p::Word([194u8, 189u8, 240u8, 124u8, 194u8, 189u8, 240u8, 252u8]),
            _p::Word([234u8, 28u8, 8u8, 2u8, 234u8, 28u8, 8u8, 130u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([64u8, 222u8, 119u8, 131u8, 33u8, 18u8, 220u8, 66u8]),
            _p::Word([41u8, 144u8, 35u8, 202u8, 229u8, 200u8, 118u8, 127u8]),
            _p::Word([41u8, 144u8, 35u8, 202u8, 229u8, 200u8, 118u8, 255u8]),
            _p::Word([145u8, 247u8, 80u8, 55u8, 158u8, 120u8, 102u8, 0u8]),
            _p::Word([145u8, 247u8, 80u8, 55u8, 158u8, 120u8, 102u8, 128u8]),
            _p::Word([9u8, 0u8, 0u8, 0u8, 42u8, 0u8, 0u8, 0u8]),
            _p::Word([9u8, 0u8, 0u8, 0u8, 50u8, 0u8, 0u8, 0u8]),
            _p::Word([9u8, 0u8, 0u8, 0u8, 58u8, 0u8, 0u8, 0u8]),
            _p::Word([113u8, 117u8, 117u8, 120u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([99u8, 111u8, 114u8, 103u8, 101u8, 0u8, 0u8, 0u8]),
            _p::Word([103u8, 114u8, 97u8, 117u8, 108u8, 116u8, 0u8, 0u8]),
            _p::Word([9u8, 0u8, 0u8, 0u8, 50u8, 0u8, 0u8, 0u8]),
            _p::Word([9u8, 0u8, 0u8, 0u8, 42u8, 0u8, 0u8, 0u8]),
            _p::Word([9u8, 0u8, 0u8, 0u8, 34u8, 0u8, 0u8, 0u8]),
            _p::Word([103u8, 97u8, 114u8, 112u8, 108u8, 121u8, 0u8, 0u8]),
            _p::Word([119u8, 97u8, 108u8, 100u8, 111u8, 0u8, 0u8, 0u8]),
            _p::Word([102u8, 114u8, 101u8, 100u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([12u8, 0u8, 0u8, 0u8, 6u8, 0u8, 20u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([29u8, 1u8, 0u8, 0u8, 122u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([189u8, 0u8, 0u8, 0u8, 122u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([93u8, 0u8, 0u8, 0u8, 122u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([120u8, 32u8, 115u8, 116u8, 114u8, 117u8, 99u8, 116u8]),
            _p::Word([108u8, 105u8, 115u8, 116u8, 32u8, 49u8, 0u8, 0u8]),
            _p::Word([120u8, 32u8, 115u8, 116u8, 114u8, 117u8, 99u8, 116u8]),
            _p::Word([108u8, 105u8, 115u8, 116u8, 32u8, 50u8, 0u8, 0u8]),
            _p::Word([120u8, 32u8, 115u8, 116u8, 114u8, 117u8, 99u8, 116u8]),
            _p::Word([108u8, 105u8, 115u8, 116u8, 32u8, 51u8, 0u8, 0u8]),
            _p::Word([3u8, 0u8, 1u8, 0u8, 6u8, 0u8, 0u8, 0u8]),
            _p::Word([103u8, 43u8, 153u8, 212u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([12u8, 0u8, 0u8, 0u8, 6u8, 0u8, 20u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([29u8, 1u8, 0u8, 0u8, 106u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([189u8, 0u8, 0u8, 0u8, 106u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([93u8, 0u8, 0u8, 0u8, 106u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([115u8, 116u8, 114u8, 117u8, 99u8, 116u8, 108u8, 105u8]),
            _p::Word([115u8, 116u8, 32u8, 49u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([115u8, 116u8, 114u8, 117u8, 99u8, 116u8, 108u8, 105u8]),
            _p::Word([115u8, 116u8, 32u8, 50u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([115u8, 116u8, 114u8, 117u8, 99u8, 116u8, 108u8, 105u8]),
            _p::Word([115u8, 116u8, 32u8, 51u8, 0u8, 0u8, 0u8, 0u8]),
        ],
    )
};
pub const GENERIC_CONSTANT: _p::ty::ConstPtr<_p::Struct<TestGenerics>> = unsafe {
    _p::ty::ConstPtr::new(
        &[
            _p::Word([0u8, 0u8, 0u8, 0u8, 1u8, 0u8, 3u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([8u8, 0u8, 0u8, 0u8, 6u8, 0u8, 20u8, 0u8]),
            _p::Word([108u8, 0u8, 0u8, 0u8, 1u8, 0u8, 3u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 123u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([9u8, 0u8, 0u8, 0u8, 42u8, 0u8, 0u8, 0u8]),
            _p::Word([8u8, 0u8, 0u8, 0u8, 1u8, 0u8, 3u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([116u8, 101u8, 120u8, 116u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([8u8, 0u8, 0u8, 0u8, 6u8, 0u8, 20u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 65u8, 1u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
        ],
    )
};
pub const EMBEDDED_DATA: _p::ty::ConstPtr<_p::Data> = unsafe {
    _p::ty::ConstPtr::new(
        &[
            _p::Word([1u8, 0u8, 0u8, 0u8, 250u8, 25u8, 0u8, 0u8]),
            _p::Word([48u8, 95u8, 1u8, 80u8, 6u8, 20u8, 255u8, 1u8]),
            _p::Word([133u8, 199u8, 207u8, 178u8, 158u8, 67u8, 255u8, 3u8]),
            _p::Word([135u8, 32u8, 242u8, 121u8, 183u8, 143u8, 255u8, 255u8]),
            _p::Word([234u8, 0u8, 110u8, 178u8, 20u8, 106u8, 10u8, 206u8]),
            _p::Word([210u8, 10u8, 31u8, 235u8, 140u8, 169u8, 84u8, 171u8]),
            _p::Word([30u8, 80u8, 154u8, 68u8, 5u8, 254u8, 187u8, 224u8]),
            _p::Word([192u8, 130u8, 139u8, 181u8, 201u8, 17u8, 77u8, 34u8]),
            _p::Word([17u8, 77u8, 26u8, 81u8, 76u8, 6u8, 20u8, 19u8]),
            _p::Word([133u8, 3u8, 48u8, 19u8, 129u8, 3u8, 33u8, 19u8]),
            _p::Word([129u8, 3u8, 18u8, 19u8, 129u8, 3u8, 19u8, 19u8]),
            _p::Word([129u8, 3u8, 20u8, 19u8, 129u8, 3u8, 21u8, 19u8]),
            _p::Word([133u8, 3u8, 18u8, 19u8, 133u8, 3u8, 19u8, 19u8]),
            _p::Word([133u8, 3u8, 12u8, 19u8, 133u8, 3u8, 13u8, 19u8]),
            _p::Word([133u8, 3u8, 36u8, 19u8, 137u8, 3u8, 37u8, 19u8]),
            _p::Word([149u8, 3u8, 30u8, 19u8, 169u8, 3u8, 30u8, 51u8]),
            _p::Word([193u8, 3u8, 119u8, 2u8, 19u8, 17u8, 5u8, 19u8]),
            _p::Word([0u8, 0u8, 7u8, 102u8, 111u8, 111u8, 7u8, 98u8]),
            _p::Word([97u8, 114u8, 255u8, 1u8, 244u8, 128u8, 13u8, 14u8]),
            _p::Word([16u8, 76u8, 251u8, 0u8, 63u8, 78u8, 115u8, 232u8]),
            _p::Word([56u8, 166u8, 51u8, 253u8, 90u8, 210u8, 4u8, 20u8]),
            _p::Word([136u8, 98u8, 3u8, 255u8, 210u8, 10u8, 111u8, 18u8]),
            _p::Word([33u8, 25u8, 204u8, 4u8, 0u8, 31u8, 95u8, 112u8]),
            _p::Word([9u8, 175u8, 2u8, 224u8, 144u8, 117u8, 64u8, 17u8]),
            _p::Word([77u8, 34u8, 17u8, 77u8, 26u8, 81u8, 76u8, 6u8]),
            _p::Word([20u8, 19u8, 37u8, 1u8, 24u8, 19u8, 33u8, 1u8]),
            _p::Word([41u8, 19u8, 33u8, 1u8, 34u8, 19u8, 33u8, 1u8]),
            _p::Word([35u8, 19u8, 33u8, 1u8, 36u8, 19u8, 37u8, 1u8]),
            _p::Word([37u8, 19u8, 49u8, 1u8, 34u8, 19u8, 49u8, 1u8]),
            _p::Word([35u8, 19u8, 49u8, 1u8, 36u8, 19u8, 53u8, 1u8]),
            _p::Word([37u8, 19u8, 65u8, 1u8, 52u8, 19u8, 73u8, 1u8]),
            _p::Word([53u8, 19u8, 93u8, 1u8, 30u8, 19u8, 113u8, 1u8]),
            _p::Word([30u8, 51u8, 133u8, 1u8, 119u8, 2u8, 19u8, 213u8]),
            _p::Word([2u8, 27u8, 0u8, 0u8, 7u8, 98u8, 97u8, 122u8]),
            _p::Word([7u8, 113u8, 117u8, 120u8, 0u8, 5u8, 17u8, 77u8]),
            _p::Word([58u8, 0u8, 0u8, 81u8, 72u8, 6u8, 20u8, 0u8]),
            _p::Word([16u8, 63u8, 110u8, 101u8, 115u8, 116u8, 101u8, 100u8]),
            _p::Word([0u8, 5u8, 17u8, 77u8, 114u8, 0u8, 18u8, 255u8]),
            _p::Word([114u8, 101u8, 97u8, 108u8, 108u8, 121u8, 32u8, 110u8]),
            _p::Word([0u8, 31u8, 101u8, 115u8, 116u8, 101u8, 100u8, 1u8]),
            _p::Word([26u8, 15u8, 12u8, 222u8, 128u8, 127u8, 239u8, 210u8]),
            _p::Word([4u8, 210u8, 233u8, 128u8, 255u8, 127u8, 247u8, 78u8]),
            _p::Word([97u8, 188u8, 64u8, 211u8, 160u8, 250u8, 248u8, 128u8]),
            _p::Word([255u8, 255u8, 255u8, 127u8, 63u8, 121u8, 223u8, 13u8]),
            _p::Word([134u8, 72u8, 112u8, 255u8, 46u8, 117u8, 19u8, 253u8]),
            _p::Word([138u8, 150u8, 253u8, 255u8, 0u8, 128u8, 128u8, 255u8]),
            _p::Word([255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 127u8]),
            _p::Word([0u8, 11u8, 12u8, 34u8, 255u8, 207u8, 210u8, 4u8]),
            _p::Word([46u8, 22u8, 255u8, 255u8, 247u8, 78u8, 97u8, 188u8]),
            _p::Word([192u8, 44u8, 95u8, 5u8, 240u8, 255u8, 255u8, 255u8]),
            _p::Word([255u8, 63u8, 121u8, 223u8, 13u8, 134u8, 72u8, 112u8]),
            _p::Word([127u8, 210u8, 138u8, 236u8, 2u8, 117u8, 105u8, 2u8]),
            _p::Word([0u8, 0u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8]),
            _p::Word([255u8, 255u8, 255u8, 0u8, 240u8, 56u8, 180u8, 150u8]),
            _p::Word([73u8, 255u8, 194u8, 189u8, 240u8, 124u8, 194u8, 189u8]),
            _p::Word([240u8, 252u8, 1u8, 234u8, 28u8, 8u8, 2u8, 234u8]),
            _p::Word([28u8, 8u8, 130u8, 0u8, 0u8, 255u8, 64u8, 222u8]),
            _p::Word([119u8, 131u8, 33u8, 18u8, 220u8, 66u8, 4u8, 41u8]),
            _p::Word([144u8, 35u8, 202u8, 229u8, 200u8, 118u8, 127u8, 41u8]),
            _p::Word([144u8, 35u8, 202u8, 229u8, 200u8, 118u8, 255u8, 145u8]),
            _p::Word([247u8, 80u8, 55u8, 158u8, 120u8, 102u8, 0u8, 145u8]),
            _p::Word([247u8, 80u8, 55u8, 158u8, 120u8, 102u8, 128u8, 17u8]),
            _p::Word([9u8, 42u8, 17u8, 9u8, 50u8, 17u8, 9u8, 58u8]),
            _p::Word([15u8, 113u8, 117u8, 117u8, 120u8, 31u8, 99u8, 111u8]),
            _p::Word([114u8, 103u8, 101u8, 63u8, 103u8, 114u8, 97u8, 117u8]),
            _p::Word([108u8, 116u8, 17u8, 9u8, 50u8, 17u8, 9u8, 42u8]),
            _p::Word([17u8, 9u8, 34u8, 63u8, 103u8, 97u8, 114u8, 112u8]),
            _p::Word([108u8, 121u8, 31u8, 119u8, 97u8, 108u8, 100u8, 111u8]),
            _p::Word([15u8, 102u8, 114u8, 101u8, 100u8, 81u8, 12u8, 6u8]),
            _p::Word([20u8, 0u8, 5u8, 19u8, 29u8, 1u8, 122u8, 0u8]),
            _p::Word([24u8, 17u8, 189u8, 122u8, 0u8, 24u8, 17u8, 93u8]),
            _p::Word([122u8, 0u8, 18u8, 255u8, 120u8, 32u8, 115u8, 116u8]),
            _p::Word([114u8, 117u8, 99u8, 116u8, 0u8, 63u8, 108u8, 105u8]),
            _p::Word([115u8, 116u8, 32u8, 49u8, 255u8, 120u8, 32u8, 115u8]),
            _p::Word([116u8, 114u8, 117u8, 99u8, 116u8, 0u8, 63u8, 108u8]),
            _p::Word([105u8, 115u8, 116u8, 32u8, 50u8, 255u8, 120u8, 32u8]),
            _p::Word([115u8, 116u8, 114u8, 117u8, 99u8, 116u8, 0u8, 63u8]),
            _p::Word([108u8, 105u8, 115u8, 116u8, 32u8, 51u8, 21u8, 3u8]),
            _p::Word([1u8, 6u8, 1u8, 9u8, 3u8, 111u8, 145u8, 15u8]),
            _p::Word([103u8, 43u8, 153u8, 212u8, 255u8, 199u8, 107u8, 159u8]),
            _p::Word([6u8, 57u8, 148u8, 96u8, 249u8, 2u8, 199u8, 113u8]),
            _p::Word([196u8, 43u8, 171u8, 117u8, 107u8, 15u8, 57u8, 142u8]),
            _p::Word([59u8, 212u8, 84u8, 138u8, 148u8, 240u8, 3u8, 111u8]),
            _p::Word([222u8, 15u8, 53u8, 130u8, 156u8, 173u8, 15u8, 85u8]),
            _p::Word([161u8, 174u8, 198u8, 255u8, 199u8, 113u8, 172u8, 181u8]),
            _p::Word([175u8, 152u8, 50u8, 154u8, 0u8, 206u8, 156u8, 173u8]),
            _p::Word([69u8, 128u8, 127u8, 204u8, 128u8, 255u8, 192u8, 127u8]),
            _p::Word([240u8, 192u8, 97u8, 190u8, 64u8, 192u8, 240u8, 127u8]),
            _p::Word([192u8, 240u8, 255u8, 192u8, 248u8, 127u8, 17u8, 9u8]),
            _p::Word([50u8, 17u8, 9u8, 50u8, 17u8, 9u8, 42u8, 31u8]),
            _p::Word([112u8, 108u8, 117u8, 103u8, 104u8, 31u8, 120u8, 121u8]),
            _p::Word([122u8, 122u8, 121u8, 15u8, 116u8, 104u8, 117u8, 100u8]),
            _p::Word([17u8, 9u8, 34u8, 17u8, 9u8, 74u8, 17u8, 13u8]),
            _p::Word([58u8, 15u8, 111u8, 111u8, 112u8, 115u8, 255u8, 101u8]),
            _p::Word([120u8, 104u8, 97u8, 117u8, 115u8, 116u8, 101u8, 0u8]),
            _p::Word([1u8, 100u8, 127u8, 114u8, 102u8, 99u8, 51u8, 48u8]),
            _p::Word([57u8, 50u8, 81u8, 12u8, 6u8, 20u8, 0u8, 5u8]),
            _p::Word([19u8, 29u8, 1u8, 106u8, 0u8, 24u8, 17u8, 189u8]),
            _p::Word([106u8, 0u8, 24u8, 17u8, 93u8, 106u8, 0u8, 18u8]),
            _p::Word([255u8, 115u8, 116u8, 114u8, 117u8, 99u8, 116u8, 108u8]),
            _p::Word([105u8, 0u8, 15u8, 115u8, 116u8, 32u8, 49u8, 255u8]),
            _p::Word([115u8, 116u8, 114u8, 117u8, 99u8, 116u8, 108u8, 105u8]),
            _p::Word([0u8, 15u8, 115u8, 116u8, 32u8, 50u8, 255u8, 115u8]),
            _p::Word([116u8, 114u8, 117u8, 99u8, 116u8, 108u8, 105u8, 0u8]),
            _p::Word([15u8, 115u8, 116u8, 32u8, 51u8, 4u8, 7u8, 0u8]),
        ],
    )
};
pub const EMBEDDED_TEXT: _p::ty::ConstPtr<_p::Text> = unsafe {
    _p::ty::ConstPtr::new(
        &[
            _p::Word([1u8, 0u8, 0u8, 0u8, 98u8, 132u8, 0u8, 0u8]),
            _p::Word([40u8, 118u8, 111u8, 105u8, 100u8, 70u8, 105u8, 101u8]),
            _p::Word([108u8, 100u8, 32u8, 61u8, 32u8, 118u8, 111u8, 105u8]),
            _p::Word([100u8, 44u8, 32u8, 98u8, 111u8, 111u8, 108u8, 70u8]),
            _p::Word([105u8, 101u8, 108u8, 100u8, 32u8, 61u8, 32u8, 116u8]),
            _p::Word([114u8, 117u8, 101u8, 44u8, 32u8, 105u8, 110u8, 116u8]),
            _p::Word([56u8, 70u8, 105u8, 101u8, 108u8, 100u8, 32u8, 61u8]),
            _p::Word([32u8, 45u8, 49u8, 50u8, 51u8, 44u8, 32u8, 105u8]),
            _p::Word([110u8, 116u8, 49u8, 54u8, 70u8, 105u8, 101u8, 108u8]),
            _p::Word([100u8, 32u8, 61u8, 32u8, 45u8, 49u8, 50u8, 51u8]),
            _p::Word([52u8, 53u8, 44u8, 32u8, 105u8, 110u8, 116u8, 51u8]),
            _p::Word([50u8, 70u8, 105u8, 101u8, 108u8, 100u8, 32u8, 61u8]),
            _p::Word([32u8, 45u8, 49u8, 50u8, 51u8, 52u8, 53u8, 54u8]),
            _p::Word([55u8, 56u8, 44u8, 32u8, 105u8, 110u8, 116u8, 54u8]),
            _p::Word([52u8, 70u8, 105u8, 101u8, 108u8, 100u8, 32u8, 61u8]),
            _p::Word([32u8, 45u8, 49u8, 50u8, 51u8, 52u8, 53u8, 54u8]),
            _p::Word([55u8, 56u8, 57u8, 48u8, 49u8, 50u8, 51u8, 52u8]),
            _p::Word([53u8, 44u8, 32u8, 117u8, 73u8, 110u8, 116u8, 56u8]),
            _p::Word([70u8, 105u8, 101u8, 108u8, 100u8, 32u8, 61u8, 32u8]),
            _p::Word([50u8, 51u8, 52u8, 44u8, 32u8, 117u8, 73u8, 110u8]),
            _p::Word([116u8, 49u8, 54u8, 70u8, 105u8, 101u8, 108u8, 100u8]),
            _p::Word([32u8, 61u8, 32u8, 52u8, 53u8, 54u8, 55u8, 56u8]),
            _p::Word([44u8, 32u8, 117u8, 73u8, 110u8, 116u8, 51u8, 50u8]),
            _p::Word([70u8, 105u8, 101u8, 108u8, 100u8, 32u8, 61u8, 32u8]),
            _p::Word([51u8, 52u8, 53u8, 54u8, 55u8, 56u8, 57u8, 48u8]),
            _p::Word([49u8, 50u8, 44u8, 32u8, 117u8, 73u8, 110u8, 116u8]),
            _p::Word([54u8, 52u8, 70u8, 105u8, 101u8, 108u8, 100u8, 32u8]),
            _p::Word([61u8, 32u8, 49u8, 50u8, 51u8, 52u8, 53u8, 54u8]),
            _p::Word([55u8, 56u8, 57u8, 48u8, 49u8, 50u8, 51u8, 52u8]),
            _p::Word([53u8, 54u8, 55u8, 56u8, 57u8, 48u8, 44u8, 32u8]),
            _p::Word([102u8, 108u8, 111u8, 97u8, 116u8, 51u8, 50u8, 70u8]),
            _p::Word([105u8, 101u8, 108u8, 100u8, 32u8, 61u8, 32u8, 49u8]),
            _p::Word([50u8, 51u8, 52u8, 46u8, 53u8, 44u8, 32u8, 102u8]),
            _p::Word([108u8, 111u8, 97u8, 116u8, 54u8, 52u8, 70u8, 105u8]),
            _p::Word([101u8, 108u8, 100u8, 32u8, 61u8, 32u8, 45u8, 49u8]),
            _p::Word([46u8, 50u8, 51u8, 101u8, 52u8, 55u8, 44u8, 32u8]),
            _p::Word([116u8, 101u8, 120u8, 116u8, 70u8, 105u8, 101u8, 108u8]),
            _p::Word([100u8, 32u8, 61u8, 32u8, 34u8, 102u8, 111u8, 111u8]),
            _p::Word([34u8, 44u8, 32u8, 100u8, 97u8, 116u8, 97u8, 70u8]),
            _p::Word([105u8, 101u8, 108u8, 100u8, 32u8, 61u8, 32u8, 34u8]),
            _p::Word([98u8, 97u8, 114u8, 34u8, 44u8, 32u8, 115u8, 116u8]),
            _p::Word([114u8, 117u8, 99u8, 116u8, 70u8, 105u8, 101u8, 108u8]),
            _p::Word([100u8, 32u8, 61u8, 32u8, 40u8, 118u8, 111u8, 105u8]),
            _p::Word([100u8, 70u8, 105u8, 101u8, 108u8, 100u8, 32u8, 61u8]),
            _p::Word([32u8, 118u8, 111u8, 105u8, 100u8, 44u8, 32u8, 98u8]),
            _p::Word([111u8, 111u8, 108u8, 70u8, 105u8, 101u8, 108u8, 100u8]),
            _p::Word([32u8, 61u8, 32u8, 116u8, 114u8, 117u8, 101u8, 44u8]),
            _p::Word([32u8, 105u8, 110u8, 116u8, 56u8, 70u8, 105u8, 101u8]),
            _p::Word([108u8, 100u8, 32u8, 61u8, 32u8, 45u8, 49u8, 50u8]),
            _p::Word([44u8, 32u8, 105u8, 110u8, 116u8, 49u8, 54u8, 70u8]),
            _p::Word([105u8, 101u8, 108u8, 100u8, 32u8, 61u8, 32u8, 51u8]),
            _p::Word([52u8, 53u8, 54u8, 44u8, 32u8, 105u8, 110u8, 116u8]),
            _p::Word([51u8, 50u8, 70u8, 105u8, 101u8, 108u8, 100u8, 32u8]),
            _p::Word([61u8, 32u8, 45u8, 55u8, 56u8, 57u8, 48u8, 49u8]),
            _p::Word([50u8, 51u8, 52u8, 44u8, 32u8, 105u8, 110u8, 116u8]),
            _p::Word([54u8, 52u8, 70u8, 105u8, 101u8, 108u8, 100u8, 32u8]),
            _p::Word([61u8, 32u8, 53u8, 54u8, 55u8, 56u8, 57u8, 48u8]),
            _p::Word([49u8, 50u8, 51u8, 52u8, 53u8, 54u8, 55u8, 56u8]),
            _p::Word([44u8, 32u8, 117u8, 73u8, 110u8, 116u8, 56u8, 70u8]),
            _p::Word([105u8, 101u8, 108u8, 100u8, 32u8, 61u8, 32u8, 57u8]),
            _p::Word([48u8, 44u8, 32u8, 117u8, 73u8, 110u8, 116u8, 49u8]),
            _p::Word([54u8, 70u8, 105u8, 101u8, 108u8, 100u8, 32u8, 61u8]),
            _p::Word([32u8, 49u8, 50u8, 51u8, 52u8, 44u8, 32u8, 117u8]),
            _p::Word([73u8, 110u8, 116u8, 51u8, 50u8, 70u8, 105u8, 101u8]),
            _p::Word([108u8, 100u8, 32u8, 61u8, 32u8, 53u8, 54u8, 55u8]),
            _p::Word([56u8, 57u8, 48u8, 49u8, 50u8, 44u8, 32u8, 117u8]),
            _p::Word([73u8, 110u8, 116u8, 54u8, 52u8, 70u8, 105u8, 101u8]),
            _p::Word([108u8, 100u8, 32u8, 61u8, 32u8, 51u8, 52u8, 53u8]),
            _p::Word([54u8, 55u8, 56u8, 57u8, 48u8, 49u8, 50u8, 51u8]),
            _p::Word([52u8, 53u8, 54u8, 55u8, 56u8, 57u8, 48u8, 44u8]),
            _p::Word([32u8, 102u8, 108u8, 111u8, 97u8, 116u8, 51u8, 50u8]),
            _p::Word([70u8, 105u8, 101u8, 108u8, 100u8, 32u8, 61u8, 32u8]),
            _p::Word([45u8, 49u8, 46u8, 50u8, 53u8, 101u8, 45u8, 49u8]),
            _p::Word([48u8, 44u8, 32u8, 102u8, 108u8, 111u8, 97u8, 116u8]),
            _p::Word([54u8, 52u8, 70u8, 105u8, 101u8, 108u8, 100u8, 32u8]),
            _p::Word([61u8, 32u8, 51u8, 52u8, 53u8, 44u8, 32u8, 116u8]),
            _p::Word([101u8, 120u8, 116u8, 70u8, 105u8, 101u8, 108u8, 100u8]),
            _p::Word([32u8, 61u8, 32u8, 34u8, 98u8, 97u8, 122u8, 34u8]),
            _p::Word([44u8, 32u8, 100u8, 97u8, 116u8, 97u8, 70u8, 105u8]),
            _p::Word([101u8, 108u8, 100u8, 32u8, 61u8, 32u8, 34u8, 113u8]),
            _p::Word([117u8, 120u8, 34u8, 44u8, 32u8, 115u8, 116u8, 114u8]),
            _p::Word([117u8, 99u8, 116u8, 70u8, 105u8, 101u8, 108u8, 100u8]),
            _p::Word([32u8, 61u8, 32u8, 40u8, 118u8, 111u8, 105u8, 100u8]),
            _p::Word([70u8, 105u8, 101u8, 108u8, 100u8, 32u8, 61u8, 32u8]),
            _p::Word([118u8, 111u8, 105u8, 100u8, 44u8, 32u8, 98u8, 111u8]),
            _p::Word([111u8, 108u8, 70u8, 105u8, 101u8, 108u8, 100u8, 32u8]),
            _p::Word([61u8, 32u8, 102u8, 97u8, 108u8, 115u8, 101u8, 44u8]),
            _p::Word([32u8, 105u8, 110u8, 116u8, 56u8, 70u8, 105u8, 101u8]),
            _p::Word([108u8, 100u8, 32u8, 61u8, 32u8, 48u8, 44u8, 32u8]),
            _p::Word([105u8, 110u8, 116u8, 49u8, 54u8, 70u8, 105u8, 101u8]),
            _p::Word([108u8, 100u8, 32u8, 61u8, 32u8, 48u8, 44u8, 32u8]),
            _p::Word([105u8, 110u8, 116u8, 51u8, 50u8, 70u8, 105u8, 101u8]),
            _p::Word([108u8, 100u8, 32u8, 61u8, 32u8, 48u8, 44u8, 32u8]),
            _p::Word([105u8, 110u8, 116u8, 54u8, 52u8, 70u8, 105u8, 101u8]),
            _p::Word([108u8, 100u8, 32u8, 61u8, 32u8, 48u8, 44u8, 32u8]),
            _p::Word([117u8, 73u8, 110u8, 116u8, 56u8, 70u8, 105u8, 101u8]),
            _p::Word([108u8, 100u8, 32u8, 61u8, 32u8, 48u8, 44u8, 32u8]),
            _p::Word([117u8, 73u8, 110u8, 116u8, 49u8, 54u8, 70u8, 105u8]),
            _p::Word([101u8, 108u8, 100u8, 32u8, 61u8, 32u8, 48u8, 44u8]),
            _p::Word([32u8, 117u8, 73u8, 110u8, 116u8, 51u8, 50u8, 70u8]),
            _p::Word([105u8, 101u8, 108u8, 100u8, 32u8, 61u8, 32u8, 48u8]),
            _p::Word([44u8, 32u8, 117u8, 73u8, 110u8, 116u8, 54u8, 52u8]),
            _p::Word([70u8, 105u8, 101u8, 108u8, 100u8, 32u8, 61u8, 32u8]),
            _p::Word([48u8, 44u8, 32u8, 102u8, 108u8, 111u8, 97u8, 116u8]),
            _p::Word([51u8, 50u8, 70u8, 105u8, 101u8, 108u8, 100u8, 32u8]),
            _p::Word([61u8, 32u8, 48u8, 44u8, 32u8, 102u8, 108u8, 111u8]),
            _p::Word([97u8, 116u8, 54u8, 52u8, 70u8, 105u8, 101u8, 108u8]),
            _p::Word([100u8, 32u8, 61u8, 32u8, 48u8, 44u8, 32u8, 116u8]),
            _p::Word([101u8, 120u8, 116u8, 70u8, 105u8, 101u8, 108u8, 100u8]),
            _p::Word([32u8, 61u8, 32u8, 34u8, 110u8, 101u8, 115u8, 116u8]),
            _p::Word([101u8, 100u8, 34u8, 44u8, 32u8, 115u8, 116u8, 114u8]),
            _p::Word([117u8, 99u8, 116u8, 70u8, 105u8, 101u8, 108u8, 100u8]),
            _p::Word([32u8, 61u8, 32u8, 40u8, 118u8, 111u8, 105u8, 100u8]),
            _p::Word([70u8, 105u8, 101u8, 108u8, 100u8, 32u8, 61u8, 32u8]),
            _p::Word([118u8, 111u8, 105u8, 100u8, 44u8, 32u8, 98u8, 111u8]),
            _p::Word([111u8, 108u8, 70u8, 105u8, 101u8, 108u8, 100u8, 32u8]),
            _p::Word([61u8, 32u8, 102u8, 97u8, 108u8, 115u8, 101u8, 44u8]),
            _p::Word([32u8, 105u8, 110u8, 116u8, 56u8, 70u8, 105u8, 101u8]),
            _p::Word([108u8, 100u8, 32u8, 61u8, 32u8, 48u8, 44u8, 32u8]),
            _p::Word([105u8, 110u8, 116u8, 49u8, 54u8, 70u8, 105u8, 101u8]),
            _p::Word([108u8, 100u8, 32u8, 61u8, 32u8, 48u8, 44u8, 32u8]),
            _p::Word([105u8, 110u8, 116u8, 51u8, 50u8, 70u8, 105u8, 101u8]),
            _p::Word([108u8, 100u8, 32u8, 61u8, 32u8, 48u8, 44u8, 32u8]),
            _p::Word([105u8, 110u8, 116u8, 54u8, 52u8, 70u8, 105u8, 101u8]),
            _p::Word([108u8, 100u8, 32u8, 61u8, 32u8, 48u8, 44u8, 32u8]),
            _p::Word([117u8, 73u8, 110u8, 116u8, 56u8, 70u8, 105u8, 101u8]),
            _p::Word([108u8, 100u8, 32u8, 61u8, 32u8, 48u8, 44u8, 32u8]),
            _p::Word([117u8, 73u8, 110u8, 116u8, 49u8, 54u8, 70u8, 105u8]),
            _p::Word([101u8, 108u8, 100u8, 32u8, 61u8, 32u8, 48u8, 44u8]),
            _p::Word([32u8, 117u8, 73u8, 110u8, 116u8, 51u8, 50u8, 70u8]),
            _p::Word([105u8, 101u8, 108u8, 100u8, 32u8, 61u8, 32u8, 48u8]),
            _p::Word([44u8, 32u8, 117u8, 73u8, 110u8, 116u8, 54u8, 52u8]),
            _p::Word([70u8, 105u8, 101u8, 108u8, 100u8, 32u8, 61u8, 32u8]),
            _p::Word([48u8, 44u8, 32u8, 102u8, 108u8, 111u8, 97u8, 116u8]),
            _p::Word([51u8, 50u8, 70u8, 105u8, 101u8, 108u8, 100u8, 32u8]),
            _p::Word([61u8, 32u8, 48u8, 44u8, 32u8, 102u8, 108u8, 111u8]),
            _p::Word([97u8, 116u8, 54u8, 52u8, 70u8, 105u8, 101u8, 108u8]),
            _p::Word([100u8, 32u8, 61u8, 32u8, 48u8, 44u8, 32u8, 116u8]),
            _p::Word([101u8, 120u8, 116u8, 70u8, 105u8, 101u8, 108u8, 100u8]),
            _p::Word([32u8, 61u8, 32u8, 34u8, 114u8, 101u8, 97u8, 108u8]),
            _p::Word([108u8, 121u8, 32u8, 110u8, 101u8, 115u8, 116u8, 101u8]),
            _p::Word([100u8, 34u8, 44u8, 32u8, 101u8, 110u8, 117u8, 109u8]),
            _p::Word([70u8, 105u8, 101u8, 108u8, 100u8, 32u8, 61u8, 32u8]),
            _p::Word([102u8, 111u8, 111u8, 44u8, 32u8, 105u8, 110u8, 116u8]),
            _p::Word([101u8, 114u8, 102u8, 97u8, 99u8, 101u8, 70u8, 105u8]),
            _p::Word([101u8, 108u8, 100u8, 32u8, 61u8, 32u8, 118u8, 111u8]),
            _p::Word([105u8, 100u8, 41u8, 44u8, 32u8, 101u8, 110u8, 117u8]),
            _p::Word([109u8, 70u8, 105u8, 101u8, 108u8, 100u8, 32u8, 61u8]),
            _p::Word([32u8, 102u8, 111u8, 111u8, 44u8, 32u8, 105u8, 110u8]),
            _p::Word([116u8, 101u8, 114u8, 102u8, 97u8, 99u8, 101u8, 70u8]),
            _p::Word([105u8, 101u8, 108u8, 100u8, 32u8, 61u8, 32u8, 118u8]),
            _p::Word([111u8, 105u8, 100u8, 41u8, 44u8, 32u8, 101u8, 110u8]),
            _p::Word([117u8, 109u8, 70u8, 105u8, 101u8, 108u8, 100u8, 32u8]),
            _p::Word([61u8, 32u8, 98u8, 97u8, 122u8, 44u8, 32u8, 105u8]),
            _p::Word([110u8, 116u8, 101u8, 114u8, 102u8, 97u8, 99u8, 101u8]),
            _p::Word([70u8, 105u8, 101u8, 108u8, 100u8, 32u8, 61u8, 32u8]),
            _p::Word([118u8, 111u8, 105u8, 100u8, 44u8, 32u8, 118u8, 111u8]),
            _p::Word([105u8, 100u8, 76u8, 105u8, 115u8, 116u8, 32u8, 61u8]),
            _p::Word([32u8, 91u8, 118u8, 111u8, 105u8, 100u8, 44u8, 32u8]),
            _p::Word([118u8, 111u8, 105u8, 100u8, 44u8, 32u8, 118u8, 111u8]),
            _p::Word([105u8, 100u8, 93u8, 44u8, 32u8, 98u8, 111u8, 111u8]),
            _p::Word([108u8, 76u8, 105u8, 115u8, 116u8, 32u8, 61u8, 32u8]),
            _p::Word([91u8, 102u8, 97u8, 108u8, 115u8, 101u8, 44u8, 32u8]),
            _p::Word([116u8, 114u8, 117u8, 101u8, 44u8, 32u8, 102u8, 97u8]),
            _p::Word([108u8, 115u8, 101u8, 44u8, 32u8, 116u8, 114u8, 117u8]),
            _p::Word([101u8, 44u8, 32u8, 116u8, 114u8, 117u8, 101u8, 93u8]),
            _p::Word([44u8, 32u8, 105u8, 110u8, 116u8, 56u8, 76u8, 105u8]),
            _p::Word([115u8, 116u8, 32u8, 61u8, 32u8, 91u8, 49u8, 50u8]),
            _p::Word([44u8, 32u8, 45u8, 51u8, 52u8, 44u8, 32u8, 45u8]),
            _p::Word([49u8, 50u8, 56u8, 44u8, 32u8, 49u8, 50u8, 55u8]),
            _p::Word([93u8, 44u8, 32u8, 105u8, 110u8, 116u8, 49u8, 54u8]),
            _p::Word([76u8, 105u8, 115u8, 116u8, 32u8, 61u8, 32u8, 91u8]),
            _p::Word([49u8, 50u8, 51u8, 52u8, 44u8, 32u8, 45u8, 53u8]),
            _p::Word([54u8, 55u8, 56u8, 44u8, 32u8, 45u8, 51u8, 50u8]),
            _p::Word([55u8, 54u8, 56u8, 44u8, 32u8, 51u8, 50u8, 55u8]),
            _p::Word([54u8, 55u8, 93u8, 44u8, 32u8, 105u8, 110u8, 116u8]),
            _p::Word([51u8, 50u8, 76u8, 105u8, 115u8, 116u8, 32u8, 61u8]),
            _p::Word([32u8, 91u8, 49u8, 50u8, 51u8, 52u8, 53u8, 54u8]),
            _p::Word([55u8, 56u8, 44u8, 32u8, 45u8, 57u8, 48u8, 49u8]),
            _p::Word([50u8, 51u8, 52u8, 53u8, 54u8, 44u8, 32u8, 45u8]),
            _p::Word([50u8, 49u8, 52u8, 55u8, 52u8, 56u8, 51u8, 54u8]),
            _p::Word([52u8, 56u8, 44u8, 32u8, 50u8, 49u8, 52u8, 55u8]),
            _p::Word([52u8, 56u8, 51u8, 54u8, 52u8, 55u8, 93u8, 44u8]),
            _p::Word([32u8, 105u8, 110u8, 116u8, 54u8, 52u8, 76u8, 105u8]),
            _p::Word([115u8, 116u8, 32u8, 61u8, 32u8, 91u8, 49u8, 50u8]),
            _p::Word([51u8, 52u8, 53u8, 54u8, 55u8, 56u8, 57u8, 48u8]),
            _p::Word([49u8, 50u8, 51u8, 52u8, 53u8, 44u8, 32u8, 45u8]),
            _p::Word([54u8, 55u8, 56u8, 57u8, 48u8, 49u8, 50u8, 51u8]),
            _p::Word([52u8, 53u8, 54u8, 55u8, 56u8, 57u8, 48u8, 44u8]),
            _p::Word([32u8, 45u8, 57u8, 50u8, 50u8, 51u8, 51u8, 55u8]),
            _p::Word([50u8, 48u8, 51u8, 54u8, 56u8, 53u8, 52u8, 55u8]),
            _p::Word([55u8, 53u8, 56u8, 48u8, 56u8, 44u8, 32u8, 57u8]),
            _p::Word([50u8, 50u8, 51u8, 51u8, 55u8, 50u8, 48u8, 51u8]),
            _p::Word([54u8, 56u8, 53u8, 52u8, 55u8, 55u8, 53u8, 56u8]),
            _p::Word([48u8, 55u8, 93u8, 44u8, 32u8, 117u8, 73u8, 110u8]),
            _p::Word([116u8, 56u8, 76u8, 105u8, 115u8, 116u8, 32u8, 61u8]),
            _p::Word([32u8, 91u8, 49u8, 50u8, 44u8, 32u8, 51u8, 52u8]),
            _p::Word([44u8, 32u8, 48u8, 44u8, 32u8, 50u8, 53u8, 53u8]),
            _p::Word([93u8, 44u8, 32u8, 117u8, 73u8, 110u8, 116u8, 49u8]),
            _p::Word([54u8, 76u8, 105u8, 115u8, 116u8, 32u8, 61u8, 32u8]),
            _p::Word([91u8, 49u8, 50u8, 51u8, 52u8, 44u8, 32u8, 53u8]),
            _p::Word([54u8, 55u8, 56u8, 44u8, 32u8, 48u8, 44u8, 32u8]),
            _p::Word([54u8, 53u8, 53u8, 51u8, 53u8, 93u8, 44u8, 32u8]),
            _p::Word([117u8, 73u8, 110u8, 116u8, 51u8, 50u8, 76u8, 105u8]),
            _p::Word([115u8, 116u8, 32u8, 61u8, 32u8, 91u8, 49u8, 50u8]),
            _p::Word([51u8, 52u8, 53u8, 54u8, 55u8, 56u8, 44u8, 32u8]),
            _p::Word([57u8, 48u8, 49u8, 50u8, 51u8, 52u8, 53u8, 54u8]),
            _p::Word([44u8, 32u8, 48u8, 44u8, 32u8, 52u8, 50u8, 57u8]),
            _p::Word([52u8, 57u8, 54u8, 55u8, 50u8, 57u8, 53u8, 93u8]),
            _p::Word([44u8, 32u8, 117u8, 73u8, 110u8, 116u8, 54u8, 52u8]),
            _p::Word([76u8, 105u8, 115u8, 116u8, 32u8, 61u8, 32u8, 91u8]),
            _p::Word([49u8, 50u8, 51u8, 52u8, 53u8, 54u8, 55u8, 56u8]),
            _p::Word([57u8, 48u8, 49u8, 50u8, 51u8, 52u8, 53u8, 44u8]),
            _p::Word([32u8, 54u8, 55u8, 56u8, 57u8, 48u8, 49u8, 50u8]),
            _p::Word([51u8, 52u8, 53u8, 54u8, 55u8, 56u8, 57u8, 48u8]),
            _p::Word([44u8, 32u8, 48u8, 44u8, 32u8, 49u8, 56u8, 52u8]),
            _p::Word([52u8, 54u8, 55u8, 52u8, 52u8, 48u8, 55u8, 51u8]),
            _p::Word([55u8, 48u8, 57u8, 53u8, 53u8, 49u8, 54u8, 49u8]),
            _p::Word([53u8, 93u8, 44u8, 32u8, 102u8, 108u8, 111u8, 97u8]),
            _p::Word([116u8, 51u8, 50u8, 76u8, 105u8, 115u8, 116u8, 32u8]),
            _p::Word([61u8, 32u8, 91u8, 48u8, 44u8, 32u8, 49u8, 50u8]),
            _p::Word([51u8, 52u8, 53u8, 54u8, 55u8, 44u8, 32u8, 49u8]),
            _p::Word([101u8, 51u8, 55u8, 44u8, 32u8, 45u8, 49u8, 101u8]),
            _p::Word([51u8, 55u8, 44u8, 32u8, 49u8, 101u8, 45u8, 51u8]),
            _p::Word([55u8, 44u8, 32u8, 45u8, 49u8, 101u8, 45u8, 51u8]),
            _p::Word([55u8, 93u8, 44u8, 32u8, 102u8, 108u8, 111u8, 97u8]),
            _p::Word([116u8, 54u8, 52u8, 76u8, 105u8, 115u8, 116u8, 32u8]),
            _p::Word([61u8, 32u8, 91u8, 48u8, 44u8, 32u8, 49u8, 50u8]),
            _p::Word([51u8, 52u8, 53u8, 54u8, 55u8, 56u8, 57u8, 48u8]),
            _p::Word([49u8, 50u8, 51u8, 52u8, 53u8, 44u8, 32u8, 49u8]),
            _p::Word([101u8, 51u8, 48u8, 54u8, 44u8, 32u8, 45u8, 49u8]),
            _p::Word([101u8, 51u8, 48u8, 54u8, 44u8, 32u8, 49u8, 101u8]),
            _p::Word([45u8, 51u8, 48u8, 54u8, 44u8, 32u8, 45u8, 49u8]),
            _p::Word([101u8, 45u8, 51u8, 48u8, 54u8, 93u8, 44u8, 32u8]),
            _p::Word([116u8, 101u8, 120u8, 116u8, 76u8, 105u8, 115u8, 116u8]),
            _p::Word([32u8, 61u8, 32u8, 91u8, 34u8, 113u8, 117u8, 117u8]),
            _p::Word([120u8, 34u8, 44u8, 32u8, 34u8, 99u8, 111u8, 114u8]),
            _p::Word([103u8, 101u8, 34u8, 44u8, 32u8, 34u8, 103u8, 114u8]),
            _p::Word([97u8, 117u8, 108u8, 116u8, 34u8, 93u8, 44u8, 32u8]),
            _p::Word([100u8, 97u8, 116u8, 97u8, 76u8, 105u8, 115u8, 116u8]),
            _p::Word([32u8, 61u8, 32u8, 91u8, 34u8, 103u8, 97u8, 114u8]),
            _p::Word([112u8, 108u8, 121u8, 34u8, 44u8, 32u8, 34u8, 119u8]),
            _p::Word([97u8, 108u8, 100u8, 111u8, 34u8, 44u8, 32u8, 34u8]),
            _p::Word([102u8, 114u8, 101u8, 100u8, 34u8, 93u8, 44u8, 32u8]),
            _p::Word([115u8, 116u8, 114u8, 117u8, 99u8, 116u8, 76u8, 105u8]),
            _p::Word([115u8, 116u8, 32u8, 61u8, 32u8, 91u8, 40u8, 118u8]),
            _p::Word([111u8, 105u8, 100u8, 70u8, 105u8, 101u8, 108u8, 100u8]),
            _p::Word([32u8, 61u8, 32u8, 118u8, 111u8, 105u8, 100u8, 44u8]),
            _p::Word([32u8, 98u8, 111u8, 111u8, 108u8, 70u8, 105u8, 101u8]),
            _p::Word([108u8, 100u8, 32u8, 61u8, 32u8, 102u8, 97u8, 108u8]),
            _p::Word([115u8, 101u8, 44u8, 32u8, 105u8, 110u8, 116u8, 56u8]),
            _p::Word([70u8, 105u8, 101u8, 108u8, 100u8, 32u8, 61u8, 32u8]),
            _p::Word([48u8, 44u8, 32u8, 105u8, 110u8, 116u8, 49u8, 54u8]),
            _p::Word([70u8, 105u8, 101u8, 108u8, 100u8, 32u8, 61u8, 32u8]),
            _p::Word([48u8, 44u8, 32u8, 105u8, 110u8, 116u8, 51u8, 50u8]),
            _p::Word([70u8, 105u8, 101u8, 108u8, 100u8, 32u8, 61u8, 32u8]),
            _p::Word([48u8, 44u8, 32u8, 105u8, 110u8, 116u8, 54u8, 52u8]),
            _p::Word([70u8, 105u8, 101u8, 108u8, 100u8, 32u8, 61u8, 32u8]),
            _p::Word([48u8, 44u8, 32u8, 117u8, 73u8, 110u8, 116u8, 56u8]),
            _p::Word([70u8, 105u8, 101u8, 108u8, 100u8, 32u8, 61u8, 32u8]),
            _p::Word([48u8, 44u8, 32u8, 117u8, 73u8, 110u8, 116u8, 49u8]),
            _p::Word([54u8, 70u8, 105u8, 101u8, 108u8, 100u8, 32u8, 61u8]),
            _p::Word([32u8, 48u8, 44u8, 32u8, 117u8, 73u8, 110u8, 116u8]),
            _p::Word([51u8, 50u8, 70u8, 105u8, 101u8, 108u8, 100u8, 32u8]),
            _p::Word([61u8, 32u8, 48u8, 44u8, 32u8, 117u8, 73u8, 110u8]),
            _p::Word([116u8, 54u8, 52u8, 70u8, 105u8, 101u8, 108u8, 100u8]),
            _p::Word([32u8, 61u8, 32u8, 48u8, 44u8, 32u8, 102u8, 108u8]),
            _p::Word([111u8, 97u8, 116u8, 51u8, 50u8, 70u8, 105u8, 101u8]),
            _p::Word([108u8, 100u8, 32u8, 61u8, 32u8, 48u8, 44u8, 32u8]),
            _p::Word([102u8, 108u8, 111u8, 97u8, 116u8, 54u8, 52u8, 70u8]),
            _p::Word([105u8, 101u8, 108u8, 100u8, 32u8, 61u8, 32u8, 48u8]),
            _p::Word([44u8, 32u8, 116u8, 101u8, 120u8, 116u8, 70u8, 105u8]),
            _p::Word([101u8, 108u8, 100u8, 32u8, 61u8, 32u8, 34u8, 120u8]),
            _p::Word([32u8, 115u8, 116u8, 114u8, 117u8, 99u8, 116u8, 108u8]),
            _p::Word([105u8, 115u8, 116u8, 32u8, 49u8, 34u8, 44u8, 32u8]),
            _p::Word([101u8, 110u8, 117u8, 109u8, 70u8, 105u8, 101u8, 108u8]),
            _p::Word([100u8, 32u8, 61u8, 32u8, 102u8, 111u8, 111u8, 44u8]),
            _p::Word([32u8, 105u8, 110u8, 116u8, 101u8, 114u8, 102u8, 97u8]),
            _p::Word([99u8, 101u8, 70u8, 105u8, 101u8, 108u8, 100u8, 32u8]),
            _p::Word([61u8, 32u8, 118u8, 111u8, 105u8, 100u8, 41u8, 44u8]),
            _p::Word([32u8, 40u8, 118u8, 111u8, 105u8, 100u8, 70u8, 105u8]),
            _p::Word([101u8, 108u8, 100u8, 32u8, 61u8, 32u8, 118u8, 111u8]),
            _p::Word([105u8, 100u8, 44u8, 32u8, 98u8, 111u8, 111u8, 108u8]),
            _p::Word([70u8, 105u8, 101u8, 108u8, 100u8, 32u8, 61u8, 32u8]),
            _p::Word([102u8, 97u8, 108u8, 115u8, 101u8, 44u8, 32u8, 105u8]),
            _p::Word([110u8, 116u8, 56u8, 70u8, 105u8, 101u8, 108u8, 100u8]),
            _p::Word([32u8, 61u8, 32u8, 48u8, 44u8, 32u8, 105u8, 110u8]),
            _p::Word([116u8, 49u8, 54u8, 70u8, 105u8, 101u8, 108u8, 100u8]),
            _p::Word([32u8, 61u8, 32u8, 48u8, 44u8, 32u8, 105u8, 110u8]),
            _p::Word([116u8, 51u8, 50u8, 70u8, 105u8, 101u8, 108u8, 100u8]),
            _p::Word([32u8, 61u8, 32u8, 48u8, 44u8, 32u8, 105u8, 110u8]),
            _p::Word([116u8, 54u8, 52u8, 70u8, 105u8, 101u8, 108u8, 100u8]),
            _p::Word([32u8, 61u8, 32u8, 48u8, 44u8, 32u8, 117u8, 73u8]),
            _p::Word([110u8, 116u8, 56u8, 70u8, 105u8, 101u8, 108u8, 100u8]),
            _p::Word([32u8, 61u8, 32u8, 48u8, 44u8, 32u8, 117u8, 73u8]),
            _p::Word([110u8, 116u8, 49u8, 54u8, 70u8, 105u8, 101u8, 108u8]),
            _p::Word([100u8, 32u8, 61u8, 32u8, 48u8, 44u8, 32u8, 117u8]),
            _p::Word([73u8, 110u8, 116u8, 51u8, 50u8, 70u8, 105u8, 101u8]),
            _p::Word([108u8, 100u8, 32u8, 61u8, 32u8, 48u8, 44u8, 32u8]),
            _p::Word([117u8, 73u8, 110u8, 116u8, 54u8, 52u8, 70u8, 105u8]),
            _p::Word([101u8, 108u8, 100u8, 32u8, 61u8, 32u8, 48u8, 44u8]),
            _p::Word([32u8, 102u8, 108u8, 111u8, 97u8, 116u8, 51u8, 50u8]),
            _p::Word([70u8, 105u8, 101u8, 108u8, 100u8, 32u8, 61u8, 32u8]),
            _p::Word([48u8, 44u8, 32u8, 102u8, 108u8, 111u8, 97u8, 116u8]),
            _p::Word([54u8, 52u8, 70u8, 105u8, 101u8, 108u8, 100u8, 32u8]),
            _p::Word([61u8, 32u8, 48u8, 44u8, 32u8, 116u8, 101u8, 120u8]),
            _p::Word([116u8, 70u8, 105u8, 101u8, 108u8, 100u8, 32u8, 61u8]),
            _p::Word([32u8, 34u8, 120u8, 32u8, 115u8, 116u8, 114u8, 117u8]),
            _p::Word([99u8, 116u8, 108u8, 105u8, 115u8, 116u8, 32u8, 50u8]),
            _p::Word([34u8, 44u8, 32u8, 101u8, 110u8, 117u8, 109u8, 70u8]),
            _p::Word([105u8, 101u8, 108u8, 100u8, 32u8, 61u8, 32u8, 102u8]),
            _p::Word([111u8, 111u8, 44u8, 32u8, 105u8, 110u8, 116u8, 101u8]),
            _p::Word([114u8, 102u8, 97u8, 99u8, 101u8, 70u8, 105u8, 101u8]),
            _p::Word([108u8, 100u8, 32u8, 61u8, 32u8, 118u8, 111u8, 105u8]),
            _p::Word([100u8, 41u8, 44u8, 32u8, 40u8, 118u8, 111u8, 105u8]),
            _p::Word([100u8, 70u8, 105u8, 101u8, 108u8, 100u8, 32u8, 61u8]),
            _p::Word([32u8, 118u8, 111u8, 105u8, 100u8, 44u8, 32u8, 98u8]),
            _p::Word([111u8, 111u8, 108u8, 70u8, 105u8, 101u8, 108u8, 100u8]),
            _p::Word([32u8, 61u8, 32u8, 102u8, 97u8, 108u8, 115u8, 101u8]),
            _p::Word([44u8, 32u8, 105u8, 110u8, 116u8, 56u8, 70u8, 105u8]),
            _p::Word([101u8, 108u8, 100u8, 32u8, 61u8, 32u8, 48u8, 44u8]),
            _p::Word([32u8, 105u8, 110u8, 116u8, 49u8, 54u8, 70u8, 105u8]),
            _p::Word([101u8, 108u8, 100u8, 32u8, 61u8, 32u8, 48u8, 44u8]),
            _p::Word([32u8, 105u8, 110u8, 116u8, 51u8, 50u8, 70u8, 105u8]),
            _p::Word([101u8, 108u8, 100u8, 32u8, 61u8, 32u8, 48u8, 44u8]),
            _p::Word([32u8, 105u8, 110u8, 116u8, 54u8, 52u8, 70u8, 105u8]),
            _p::Word([101u8, 108u8, 100u8, 32u8, 61u8, 32u8, 48u8, 44u8]),
            _p::Word([32u8, 117u8, 73u8, 110u8, 116u8, 56u8, 70u8, 105u8]),
            _p::Word([101u8, 108u8, 100u8, 32u8, 61u8, 32u8, 48u8, 44u8]),
            _p::Word([32u8, 117u8, 73u8, 110u8, 116u8, 49u8, 54u8, 70u8]),
            _p::Word([105u8, 101u8, 108u8, 100u8, 32u8, 61u8, 32u8, 48u8]),
            _p::Word([44u8, 32u8, 117u8, 73u8, 110u8, 116u8, 51u8, 50u8]),
            _p::Word([70u8, 105u8, 101u8, 108u8, 100u8, 32u8, 61u8, 32u8]),
            _p::Word([48u8, 44u8, 32u8, 117u8, 73u8, 110u8, 116u8, 54u8]),
            _p::Word([52u8, 70u8, 105u8, 101u8, 108u8, 100u8, 32u8, 61u8]),
            _p::Word([32u8, 48u8, 44u8, 32u8, 102u8, 108u8, 111u8, 97u8]),
            _p::Word([116u8, 51u8, 50u8, 70u8, 105u8, 101u8, 108u8, 100u8]),
            _p::Word([32u8, 61u8, 32u8, 48u8, 44u8, 32u8, 102u8, 108u8]),
            _p::Word([111u8, 97u8, 116u8, 54u8, 52u8, 70u8, 105u8, 101u8]),
            _p::Word([108u8, 100u8, 32u8, 61u8, 32u8, 48u8, 44u8, 32u8]),
            _p::Word([116u8, 101u8, 120u8, 116u8, 70u8, 105u8, 101u8, 108u8]),
            _p::Word([100u8, 32u8, 61u8, 32u8, 34u8, 120u8, 32u8, 115u8]),
            _p::Word([116u8, 114u8, 117u8, 99u8, 116u8, 108u8, 105u8, 115u8]),
            _p::Word([116u8, 32u8, 51u8, 34u8, 44u8, 32u8, 101u8, 110u8]),
            _p::Word([117u8, 109u8, 70u8, 105u8, 101u8, 108u8, 100u8, 32u8]),
            _p::Word([61u8, 32u8, 102u8, 111u8, 111u8, 44u8, 32u8, 105u8]),
            _p::Word([110u8, 116u8, 101u8, 114u8, 102u8, 97u8, 99u8, 101u8]),
            _p::Word([70u8, 105u8, 101u8, 108u8, 100u8, 32u8, 61u8, 32u8]),
            _p::Word([118u8, 111u8, 105u8, 100u8, 41u8, 93u8, 44u8, 32u8]),
            _p::Word([101u8, 110u8, 117u8, 109u8, 76u8, 105u8, 115u8, 116u8]),
            _p::Word([32u8, 61u8, 32u8, 91u8, 113u8, 117u8, 120u8, 44u8]),
            _p::Word([32u8, 98u8, 97u8, 114u8, 44u8, 32u8, 103u8, 114u8]),
            _p::Word([97u8, 117u8, 108u8, 116u8, 93u8, 41u8, 44u8, 32u8]),
            _p::Word([101u8, 110u8, 117u8, 109u8, 70u8, 105u8, 101u8, 108u8]),
            _p::Word([100u8, 32u8, 61u8, 32u8, 99u8, 111u8, 114u8, 103u8]),
            _p::Word([101u8, 44u8, 32u8, 105u8, 110u8, 116u8, 101u8, 114u8]),
            _p::Word([102u8, 97u8, 99u8, 101u8, 70u8, 105u8, 101u8, 108u8]),
            _p::Word([100u8, 32u8, 61u8, 32u8, 118u8, 111u8, 105u8, 100u8]),
            _p::Word([44u8, 32u8, 118u8, 111u8, 105u8, 100u8, 76u8, 105u8]),
            _p::Word([115u8, 116u8, 32u8, 61u8, 32u8, 91u8, 118u8, 111u8]),
            _p::Word([105u8, 100u8, 44u8, 32u8, 118u8, 111u8, 105u8, 100u8]),
            _p::Word([44u8, 32u8, 118u8, 111u8, 105u8, 100u8, 44u8, 32u8]),
            _p::Word([118u8, 111u8, 105u8, 100u8, 44u8, 32u8, 118u8, 111u8]),
            _p::Word([105u8, 100u8, 44u8, 32u8, 118u8, 111u8, 105u8, 100u8]),
            _p::Word([93u8, 44u8, 32u8, 98u8, 111u8, 111u8, 108u8, 76u8]),
            _p::Word([105u8, 115u8, 116u8, 32u8, 61u8, 32u8, 91u8, 116u8]),
            _p::Word([114u8, 117u8, 101u8, 44u8, 32u8, 102u8, 97u8, 108u8]),
            _p::Word([115u8, 101u8, 44u8, 32u8, 102u8, 97u8, 108u8, 115u8]),
            _p::Word([101u8, 44u8, 32u8, 116u8, 114u8, 117u8, 101u8, 93u8]),
            _p::Word([44u8, 32u8, 105u8, 110u8, 116u8, 56u8, 76u8, 105u8]),
            _p::Word([115u8, 116u8, 32u8, 61u8, 32u8, 91u8, 49u8, 49u8]),
            _p::Word([49u8, 44u8, 32u8, 45u8, 49u8, 49u8, 49u8, 93u8]),
            _p::Word([44u8, 32u8, 105u8, 110u8, 116u8, 49u8, 54u8, 76u8]),
            _p::Word([105u8, 115u8, 116u8, 32u8, 61u8, 32u8, 91u8, 49u8]),
            _p::Word([49u8, 49u8, 49u8, 49u8, 44u8, 32u8, 45u8, 49u8]),
            _p::Word([49u8, 49u8, 49u8, 49u8, 93u8, 44u8, 32u8, 105u8]),
            _p::Word([110u8, 116u8, 51u8, 50u8, 76u8, 105u8, 115u8, 116u8]),
            _p::Word([32u8, 61u8, 32u8, 91u8, 49u8, 49u8, 49u8, 49u8]),
            _p::Word([49u8, 49u8, 49u8, 49u8, 49u8, 44u8, 32u8, 45u8]),
            _p::Word([49u8, 49u8, 49u8, 49u8, 49u8, 49u8, 49u8, 49u8]),
            _p::Word([49u8, 93u8, 44u8, 32u8, 105u8, 110u8, 116u8, 54u8]),
            _p::Word([52u8, 76u8, 105u8, 115u8, 116u8, 32u8, 61u8, 32u8]),
            _p::Word([91u8, 49u8, 49u8, 49u8, 49u8, 49u8, 49u8, 49u8]),
            _p::Word([49u8, 49u8, 49u8, 49u8, 49u8, 49u8, 49u8, 49u8]),
            _p::Word([49u8, 49u8, 49u8, 49u8, 44u8, 32u8, 45u8, 49u8]),
            _p::Word([49u8, 49u8, 49u8, 49u8, 49u8, 49u8, 49u8, 49u8]),
            _p::Word([49u8, 49u8, 49u8, 49u8, 49u8, 49u8, 49u8, 49u8]),
            _p::Word([49u8, 49u8, 93u8, 44u8, 32u8, 117u8, 73u8, 110u8]),
            _p::Word([116u8, 56u8, 76u8, 105u8, 115u8, 116u8, 32u8, 61u8]),
            _p::Word([32u8, 91u8, 49u8, 49u8, 49u8, 44u8, 32u8, 50u8]),
            _p::Word([50u8, 50u8, 93u8, 44u8, 32u8, 117u8, 73u8, 110u8]),
            _p::Word([116u8, 49u8, 54u8, 76u8, 105u8, 115u8, 116u8, 32u8]),
            _p::Word([61u8, 32u8, 91u8, 51u8, 51u8, 51u8, 51u8, 51u8]),
            _p::Word([44u8, 32u8, 52u8, 52u8, 52u8, 52u8, 52u8, 93u8]),
            _p::Word([44u8, 32u8, 117u8, 73u8, 110u8, 116u8, 51u8, 50u8]),
            _p::Word([76u8, 105u8, 115u8, 116u8, 32u8, 61u8, 32u8, 91u8]),
            _p::Word([51u8, 51u8, 51u8, 51u8, 51u8, 51u8, 51u8, 51u8]),
            _p::Word([51u8, 51u8, 93u8, 44u8, 32u8, 117u8, 73u8, 110u8]),
            _p::Word([116u8, 54u8, 52u8, 76u8, 105u8, 115u8, 116u8, 32u8]),
            _p::Word([61u8, 32u8, 91u8, 49u8, 49u8, 49u8, 49u8, 49u8]),
            _p::Word([49u8, 49u8, 49u8, 49u8, 49u8, 49u8, 49u8, 49u8]),
            _p::Word([49u8, 49u8, 49u8, 49u8, 49u8, 49u8, 49u8, 93u8]),
            _p::Word([44u8, 32u8, 102u8, 108u8, 111u8, 97u8, 116u8, 51u8]),
            _p::Word([50u8, 76u8, 105u8, 115u8, 116u8, 32u8, 61u8, 32u8]),
            _p::Word([91u8, 53u8, 53u8, 53u8, 53u8, 46u8, 53u8, 44u8]),
            _p::Word([32u8, 105u8, 110u8, 102u8, 44u8, 32u8, 45u8, 105u8]),
            _p::Word([110u8, 102u8, 44u8, 32u8, 110u8, 97u8, 110u8, 93u8]),
            _p::Word([44u8, 32u8, 102u8, 108u8, 111u8, 97u8, 116u8, 54u8]),
            _p::Word([52u8, 76u8, 105u8, 115u8, 116u8, 32u8, 61u8, 32u8]),
            _p::Word([91u8, 55u8, 55u8, 55u8, 55u8, 46u8, 55u8, 53u8]),
            _p::Word([44u8, 32u8, 105u8, 110u8, 102u8, 44u8, 32u8, 45u8]),
            _p::Word([105u8, 110u8, 102u8, 44u8, 32u8, 110u8, 97u8, 110u8]),
            _p::Word([93u8, 44u8, 32u8, 116u8, 101u8, 120u8, 116u8, 76u8]),
            _p::Word([105u8, 115u8, 116u8, 32u8, 61u8, 32u8, 91u8, 34u8]),
            _p::Word([112u8, 108u8, 117u8, 103u8, 104u8, 34u8, 44u8, 32u8]),
            _p::Word([34u8, 120u8, 121u8, 122u8, 122u8, 121u8, 34u8, 44u8]),
            _p::Word([32u8, 34u8, 116u8, 104u8, 117u8, 100u8, 34u8, 93u8]),
            _p::Word([44u8, 32u8, 100u8, 97u8, 116u8, 97u8, 76u8, 105u8]),
            _p::Word([115u8, 116u8, 32u8, 61u8, 32u8, 91u8, 34u8, 111u8]),
            _p::Word([111u8, 112u8, 115u8, 34u8, 44u8, 32u8, 34u8, 101u8]),
            _p::Word([120u8, 104u8, 97u8, 117u8, 115u8, 116u8, 101u8, 100u8]),
            _p::Word([34u8, 44u8, 32u8, 34u8, 114u8, 102u8, 99u8, 51u8]),
            _p::Word([48u8, 57u8, 50u8, 34u8, 93u8, 44u8, 32u8, 115u8]),
            _p::Word([116u8, 114u8, 117u8, 99u8, 116u8, 76u8, 105u8, 115u8]),
            _p::Word([116u8, 32u8, 61u8, 32u8, 91u8, 40u8, 118u8, 111u8]),
            _p::Word([105u8, 100u8, 70u8, 105u8, 101u8, 108u8, 100u8, 32u8]),
            _p::Word([61u8, 32u8, 118u8, 111u8, 105u8, 100u8, 44u8, 32u8]),
            _p::Word([98u8, 111u8, 111u8, 108u8, 70u8, 105u8, 101u8, 108u8]),
            _p::Word([100u8, 32u8, 61u8, 32u8, 102u8, 97u8, 108u8, 115u8]),
            _p::Word([101u8, 44u8, 32u8, 105u8, 110u8, 116u8, 56u8, 70u8]),
            _p::Word([105u8, 101u8, 108u8, 100u8, 32u8, 61u8, 32u8, 48u8]),
            _p::Word([44u8, 32u8, 105u8, 110u8, 116u8, 49u8, 54u8, 70u8]),
            _p::Word([105u8, 101u8, 108u8, 100u8, 32u8, 61u8, 32u8, 48u8]),
            _p::Word([44u8, 32u8, 105u8, 110u8, 116u8, 51u8, 50u8, 70u8]),
            _p::Word([105u8, 101u8, 108u8, 100u8, 32u8, 61u8, 32u8, 48u8]),
            _p::Word([44u8, 32u8, 105u8, 110u8, 116u8, 54u8, 52u8, 70u8]),
            _p::Word([105u8, 101u8, 108u8, 100u8, 32u8, 61u8, 32u8, 48u8]),
            _p::Word([44u8, 32u8, 117u8, 73u8, 110u8, 116u8, 56u8, 70u8]),
            _p::Word([105u8, 101u8, 108u8, 100u8, 32u8, 61u8, 32u8, 48u8]),
            _p::Word([44u8, 32u8, 117u8, 73u8, 110u8, 116u8, 49u8, 54u8]),
            _p::Word([70u8, 105u8, 101u8, 108u8, 100u8, 32u8, 61u8, 32u8]),
            _p::Word([48u8, 44u8, 32u8, 117u8, 73u8, 110u8, 116u8, 51u8]),
            _p::Word([50u8, 70u8, 105u8, 101u8, 108u8, 100u8, 32u8, 61u8]),
            _p::Word([32u8, 48u8, 44u8, 32u8, 117u8, 73u8, 110u8, 116u8]),
            _p::Word([54u8, 52u8, 70u8, 105u8, 101u8, 108u8, 100u8, 32u8]),
            _p::Word([61u8, 32u8, 48u8, 44u8, 32u8, 102u8, 108u8, 111u8]),
            _p::Word([97u8, 116u8, 51u8, 50u8, 70u8, 105u8, 101u8, 108u8]),
            _p::Word([100u8, 32u8, 61u8, 32u8, 48u8, 44u8, 32u8, 102u8]),
            _p::Word([108u8, 111u8, 97u8, 116u8, 54u8, 52u8, 70u8, 105u8]),
            _p::Word([101u8, 108u8, 100u8, 32u8, 61u8, 32u8, 48u8, 44u8]),
            _p::Word([32u8, 116u8, 101u8, 120u8, 116u8, 70u8, 105u8, 101u8]),
            _p::Word([108u8, 100u8, 32u8, 61u8, 32u8, 34u8, 115u8, 116u8]),
            _p::Word([114u8, 117u8, 99u8, 116u8, 108u8, 105u8, 115u8, 116u8]),
            _p::Word([32u8, 49u8, 34u8, 44u8, 32u8, 101u8, 110u8, 117u8]),
            _p::Word([109u8, 70u8, 105u8, 101u8, 108u8, 100u8, 32u8, 61u8]),
            _p::Word([32u8, 102u8, 111u8, 111u8, 44u8, 32u8, 105u8, 110u8]),
            _p::Word([116u8, 101u8, 114u8, 102u8, 97u8, 99u8, 101u8, 70u8]),
            _p::Word([105u8, 101u8, 108u8, 100u8, 32u8, 61u8, 32u8, 118u8]),
            _p::Word([111u8, 105u8, 100u8, 41u8, 44u8, 32u8, 40u8, 118u8]),
            _p::Word([111u8, 105u8, 100u8, 70u8, 105u8, 101u8, 108u8, 100u8]),
            _p::Word([32u8, 61u8, 32u8, 118u8, 111u8, 105u8, 100u8, 44u8]),
            _p::Word([32u8, 98u8, 111u8, 111u8, 108u8, 70u8, 105u8, 101u8]),
            _p::Word([108u8, 100u8, 32u8, 61u8, 32u8, 102u8, 97u8, 108u8]),
            _p::Word([115u8, 101u8, 44u8, 32u8, 105u8, 110u8, 116u8, 56u8]),
            _p::Word([70u8, 105u8, 101u8, 108u8, 100u8, 32u8, 61u8, 32u8]),
            _p::Word([48u8, 44u8, 32u8, 105u8, 110u8, 116u8, 49u8, 54u8]),
            _p::Word([70u8, 105u8, 101u8, 108u8, 100u8, 32u8, 61u8, 32u8]),
            _p::Word([48u8, 44u8, 32u8, 105u8, 110u8, 116u8, 51u8, 50u8]),
            _p::Word([70u8, 105u8, 101u8, 108u8, 100u8, 32u8, 61u8, 32u8]),
            _p::Word([48u8, 44u8, 32u8, 105u8, 110u8, 116u8, 54u8, 52u8]),
            _p::Word([70u8, 105u8, 101u8, 108u8, 100u8, 32u8, 61u8, 32u8]),
            _p::Word([48u8, 44u8, 32u8, 117u8, 73u8, 110u8, 116u8, 56u8]),
            _p::Word([70u8, 105u8, 101u8, 108u8, 100u8, 32u8, 61u8, 32u8]),
            _p::Word([48u8, 44u8, 32u8, 117u8, 73u8, 110u8, 116u8, 49u8]),
            _p::Word([54u8, 70u8, 105u8, 101u8, 108u8, 100u8, 32u8, 61u8]),
            _p::Word([32u8, 48u8, 44u8, 32u8, 117u8, 73u8, 110u8, 116u8]),
            _p::Word([51u8, 50u8, 70u8, 105u8, 101u8, 108u8, 100u8, 32u8]),
            _p::Word([61u8, 32u8, 48u8, 44u8, 32u8, 117u8, 73u8, 110u8]),
            _p::Word([116u8, 54u8, 52u8, 70u8, 105u8, 101u8, 108u8, 100u8]),
            _p::Word([32u8, 61u8, 32u8, 48u8, 44u8, 32u8, 102u8, 108u8]),
            _p::Word([111u8, 97u8, 116u8, 51u8, 50u8, 70u8, 105u8, 101u8]),
            _p::Word([108u8, 100u8, 32u8, 61u8, 32u8, 48u8, 44u8, 32u8]),
            _p::Word([102u8, 108u8, 111u8, 97u8, 116u8, 54u8, 52u8, 70u8]),
            _p::Word([105u8, 101u8, 108u8, 100u8, 32u8, 61u8, 32u8, 48u8]),
            _p::Word([44u8, 32u8, 116u8, 101u8, 120u8, 116u8, 70u8, 105u8]),
            _p::Word([101u8, 108u8, 100u8, 32u8, 61u8, 32u8, 34u8, 115u8]),
            _p::Word([116u8, 114u8, 117u8, 99u8, 116u8, 108u8, 105u8, 115u8]),
            _p::Word([116u8, 32u8, 50u8, 34u8, 44u8, 32u8, 101u8, 110u8]),
            _p::Word([117u8, 109u8, 70u8, 105u8, 101u8, 108u8, 100u8, 32u8]),
            _p::Word([61u8, 32u8, 102u8, 111u8, 111u8, 44u8, 32u8, 105u8]),
            _p::Word([110u8, 116u8, 101u8, 114u8, 102u8, 97u8, 99u8, 101u8]),
            _p::Word([70u8, 105u8, 101u8, 108u8, 100u8, 32u8, 61u8, 32u8]),
            _p::Word([118u8, 111u8, 105u8, 100u8, 41u8, 44u8, 32u8, 40u8]),
            _p::Word([118u8, 111u8, 105u8, 100u8, 70u8, 105u8, 101u8, 108u8]),
            _p::Word([100u8, 32u8, 61u8, 32u8, 118u8, 111u8, 105u8, 100u8]),
            _p::Word([44u8, 32u8, 98u8, 111u8, 111u8, 108u8, 70u8, 105u8]),
            _p::Word([101u8, 108u8, 100u8, 32u8, 61u8, 32u8, 102u8, 97u8]),
            _p::Word([108u8, 115u8, 101u8, 44u8, 32u8, 105u8, 110u8, 116u8]),
            _p::Word([56u8, 70u8, 105u8, 101u8, 108u8, 100u8, 32u8, 61u8]),
            _p::Word([32u8, 48u8, 44u8, 32u8, 105u8, 110u8, 116u8, 49u8]),
            _p::Word([54u8, 70u8, 105u8, 101u8, 108u8, 100u8, 32u8, 61u8]),
            _p::Word([32u8, 48u8, 44u8, 32u8, 105u8, 110u8, 116u8, 51u8]),
            _p::Word([50u8, 70u8, 105u8, 101u8, 108u8, 100u8, 32u8, 61u8]),
            _p::Word([32u8, 48u8, 44u8, 32u8, 105u8, 110u8, 116u8, 54u8]),
            _p::Word([52u8, 70u8, 105u8, 101u8, 108u8, 100u8, 32u8, 61u8]),
            _p::Word([32u8, 48u8, 44u8, 32u8, 117u8, 73u8, 110u8, 116u8]),
            _p::Word([56u8, 70u8, 105u8, 101u8, 108u8, 100u8, 32u8, 61u8]),
            _p::Word([32u8, 48u8, 44u8, 32u8, 117u8, 73u8, 110u8, 116u8]),
            _p::Word([49u8, 54u8, 70u8, 105u8, 101u8, 108u8, 100u8, 32u8]),
            _p::Word([61u8, 32u8, 48u8, 44u8, 32u8, 117u8, 73u8, 110u8]),
            _p::Word([116u8, 51u8, 50u8, 70u8, 105u8, 101u8, 108u8, 100u8]),
            _p::Word([32u8, 61u8, 32u8, 48u8, 44u8, 32u8, 117u8, 73u8]),
            _p::Word([110u8, 116u8, 54u8, 52u8, 70u8, 105u8, 101u8, 108u8]),
            _p::Word([100u8, 32u8, 61u8, 32u8, 48u8, 44u8, 32u8, 102u8]),
            _p::Word([108u8, 111u8, 97u8, 116u8, 51u8, 50u8, 70u8, 105u8]),
            _p::Word([101u8, 108u8, 100u8, 32u8, 61u8, 32u8, 48u8, 44u8]),
            _p::Word([32u8, 102u8, 108u8, 111u8, 97u8, 116u8, 54u8, 52u8]),
            _p::Word([70u8, 105u8, 101u8, 108u8, 100u8, 32u8, 61u8, 32u8]),
            _p::Word([48u8, 44u8, 32u8, 116u8, 101u8, 120u8, 116u8, 70u8]),
            _p::Word([105u8, 101u8, 108u8, 100u8, 32u8, 61u8, 32u8, 34u8]),
            _p::Word([115u8, 116u8, 114u8, 117u8, 99u8, 116u8, 108u8, 105u8]),
            _p::Word([115u8, 116u8, 32u8, 51u8, 34u8, 44u8, 32u8, 101u8]),
            _p::Word([110u8, 117u8, 109u8, 70u8, 105u8, 101u8, 108u8, 100u8]),
            _p::Word([32u8, 61u8, 32u8, 102u8, 111u8, 111u8, 44u8, 32u8]),
            _p::Word([105u8, 110u8, 116u8, 101u8, 114u8, 102u8, 97u8, 99u8]),
            _p::Word([101u8, 70u8, 105u8, 101u8, 108u8, 100u8, 32u8, 61u8]),
            _p::Word([32u8, 118u8, 111u8, 105u8, 100u8, 41u8, 93u8, 44u8]),
            _p::Word([32u8, 101u8, 110u8, 117u8, 109u8, 76u8, 105u8, 115u8]),
            _p::Word([116u8, 32u8, 61u8, 32u8, 91u8, 102u8, 111u8, 111u8]),
            _p::Word([44u8, 32u8, 103u8, 97u8, 114u8, 112u8, 108u8, 121u8]),
            _p::Word([93u8, 41u8, 10u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
        ],
    )
};
pub const EMBEDDED_STRUCT: _p::ty::ConstPtr<_p::Struct<TestAllTypes>> = unsafe {
    _p::ty::ConstPtr::new(
        &[
            _p::Word([0u8, 0u8, 0u8, 0u8, 6u8, 0u8, 20u8, 0u8]),
            _p::Word([1u8, 133u8, 199u8, 207u8, 178u8, 158u8, 67u8, 255u8]),
            _p::Word([135u8, 32u8, 242u8, 121u8, 183u8, 143u8, 255u8, 255u8]),
            _p::Word([234u8, 0u8, 110u8, 178u8, 20u8, 106u8, 10u8, 206u8]),
            _p::Word([210u8, 10u8, 31u8, 235u8, 140u8, 169u8, 84u8, 171u8]),
            _p::Word([0u8, 80u8, 154u8, 68u8, 5u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 187u8, 224u8, 192u8, 130u8, 139u8, 181u8, 201u8]),
            _p::Word([77u8, 0u8, 0u8, 0u8, 34u8, 0u8, 0u8, 0u8]),
            _p::Word([77u8, 0u8, 0u8, 0u8, 26u8, 0u8, 0u8, 0u8]),
            _p::Word([76u8, 0u8, 0u8, 0u8, 6u8, 0u8, 20u8, 0u8]),
            _p::Word([1u8, 0u8, 0u8, 0u8, 48u8, 0u8, 0u8, 0u8]),
            _p::Word([129u8, 3u8, 0u8, 0u8, 33u8, 0u8, 0u8, 0u8]),
            _p::Word([129u8, 3u8, 0u8, 0u8, 18u8, 0u8, 0u8, 0u8]),
            _p::Word([129u8, 3u8, 0u8, 0u8, 19u8, 0u8, 0u8, 0u8]),
            _p::Word([129u8, 3u8, 0u8, 0u8, 20u8, 0u8, 0u8, 0u8]),
            _p::Word([129u8, 3u8, 0u8, 0u8, 21u8, 0u8, 0u8, 0u8]),
            _p::Word([133u8, 3u8, 0u8, 0u8, 18u8, 0u8, 0u8, 0u8]),
            _p::Word([133u8, 3u8, 0u8, 0u8, 19u8, 0u8, 0u8, 0u8]),
            _p::Word([133u8, 3u8, 0u8, 0u8, 12u8, 0u8, 0u8, 0u8]),
            _p::Word([133u8, 3u8, 0u8, 0u8, 13u8, 0u8, 0u8, 0u8]),
            _p::Word([133u8, 3u8, 0u8, 0u8, 36u8, 0u8, 0u8, 0u8]),
            _p::Word([137u8, 3u8, 0u8, 0u8, 37u8, 0u8, 0u8, 0u8]),
            _p::Word([149u8, 3u8, 0u8, 0u8, 30u8, 0u8, 0u8, 0u8]),
            _p::Word([169u8, 3u8, 0u8, 0u8, 30u8, 0u8, 0u8, 0u8]),
            _p::Word([193u8, 3u8, 0u8, 0u8, 119u8, 2u8, 0u8, 0u8]),
            _p::Word([17u8, 5u8, 0u8, 0u8, 19u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([102u8, 111u8, 111u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([98u8, 97u8, 114u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([1u8, 244u8, 128u8, 13u8, 14u8, 16u8, 76u8, 251u8]),
            _p::Word([78u8, 115u8, 232u8, 56u8, 166u8, 51u8, 0u8, 0u8]),
            _p::Word([90u8, 0u8, 210u8, 4u8, 20u8, 136u8, 98u8, 3u8]),
            _p::Word([210u8, 10u8, 111u8, 18u8, 33u8, 25u8, 204u8, 4u8]),
            _p::Word([95u8, 112u8, 9u8, 175u8, 2u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 144u8, 117u8, 64u8]),
            _p::Word([77u8, 0u8, 0u8, 0u8, 34u8, 0u8, 0u8, 0u8]),
            _p::Word([77u8, 0u8, 0u8, 0u8, 26u8, 0u8, 0u8, 0u8]),
            _p::Word([76u8, 0u8, 0u8, 0u8, 6u8, 0u8, 20u8, 0u8]),
            _p::Word([1u8, 0u8, 0u8, 0u8, 24u8, 0u8, 0u8, 0u8]),
            _p::Word([33u8, 1u8, 0u8, 0u8, 41u8, 0u8, 0u8, 0u8]),
            _p::Word([33u8, 1u8, 0u8, 0u8, 34u8, 0u8, 0u8, 0u8]),
            _p::Word([33u8, 1u8, 0u8, 0u8, 35u8, 0u8, 0u8, 0u8]),
            _p::Word([33u8, 1u8, 0u8, 0u8, 36u8, 0u8, 0u8, 0u8]),
            _p::Word([37u8, 1u8, 0u8, 0u8, 37u8, 0u8, 0u8, 0u8]),
            _p::Word([49u8, 1u8, 0u8, 0u8, 34u8, 0u8, 0u8, 0u8]),
            _p::Word([49u8, 1u8, 0u8, 0u8, 35u8, 0u8, 0u8, 0u8]),
            _p::Word([49u8, 1u8, 0u8, 0u8, 36u8, 0u8, 0u8, 0u8]),
            _p::Word([53u8, 1u8, 0u8, 0u8, 37u8, 0u8, 0u8, 0u8]),
            _p::Word([65u8, 1u8, 0u8, 0u8, 52u8, 0u8, 0u8, 0u8]),
            _p::Word([73u8, 1u8, 0u8, 0u8, 53u8, 0u8, 0u8, 0u8]),
            _p::Word([93u8, 1u8, 0u8, 0u8, 30u8, 0u8, 0u8, 0u8]),
            _p::Word([113u8, 1u8, 0u8, 0u8, 30u8, 0u8, 0u8, 0u8]),
            _p::Word([133u8, 1u8, 0u8, 0u8, 119u8, 2u8, 0u8, 0u8]),
            _p::Word([213u8, 2u8, 0u8, 0u8, 27u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([98u8, 97u8, 122u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([113u8, 117u8, 120u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([77u8, 0u8, 0u8, 0u8, 58u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([72u8, 0u8, 0u8, 0u8, 6u8, 0u8, 20u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([110u8, 101u8, 115u8, 116u8, 101u8, 100u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([77u8, 0u8, 0u8, 0u8, 114u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([114u8, 101u8, 97u8, 108u8, 108u8, 121u8, 32u8, 110u8]),
            _p::Word([101u8, 115u8, 116u8, 101u8, 100u8, 0u8, 0u8, 0u8]),
            _p::Word([26u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([12u8, 222u8, 128u8, 127u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([210u8, 4u8, 210u8, 233u8, 0u8, 128u8, 255u8, 127u8]),
            _p::Word([78u8, 97u8, 188u8, 0u8, 64u8, 211u8, 160u8, 250u8]),
            _p::Word([0u8, 0u8, 0u8, 128u8, 255u8, 255u8, 255u8, 127u8]),
            _p::Word([121u8, 223u8, 13u8, 134u8, 72u8, 112u8, 0u8, 0u8]),
            _p::Word([46u8, 117u8, 19u8, 253u8, 138u8, 150u8, 253u8, 255u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 128u8]),
            _p::Word([255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 127u8]),
            _p::Word([12u8, 34u8, 0u8, 255u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([210u8, 4u8, 46u8, 22u8, 0u8, 0u8, 255u8, 255u8]),
            _p::Word([78u8, 97u8, 188u8, 0u8, 192u8, 44u8, 95u8, 5u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 255u8, 255u8, 255u8, 255u8]),
            _p::Word([121u8, 223u8, 13u8, 134u8, 72u8, 112u8, 0u8, 0u8]),
            _p::Word([210u8, 138u8, 236u8, 2u8, 117u8, 105u8, 2u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 56u8, 180u8, 150u8, 73u8]),
            _p::Word([194u8, 189u8, 240u8, 124u8, 194u8, 189u8, 240u8, 252u8]),
            _p::Word([234u8, 28u8, 8u8, 2u8, 234u8, 28u8, 8u8, 130u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([64u8, 222u8, 119u8, 131u8, 33u8, 18u8, 220u8, 66u8]),
            _p::Word([41u8, 144u8, 35u8, 202u8, 229u8, 200u8, 118u8, 127u8]),
            _p::Word([41u8, 144u8, 35u8, 202u8, 229u8, 200u8, 118u8, 255u8]),
            _p::Word([145u8, 247u8, 80u8, 55u8, 158u8, 120u8, 102u8, 0u8]),
            _p::Word([145u8, 247u8, 80u8, 55u8, 158u8, 120u8, 102u8, 128u8]),
            _p::Word([9u8, 0u8, 0u8, 0u8, 42u8, 0u8, 0u8, 0u8]),
            _p::Word([9u8, 0u8, 0u8, 0u8, 50u8, 0u8, 0u8, 0u8]),
            _p::Word([9u8, 0u8, 0u8, 0u8, 58u8, 0u8, 0u8, 0u8]),
            _p::Word([113u8, 117u8, 117u8, 120u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([99u8, 111u8, 114u8, 103u8, 101u8, 0u8, 0u8, 0u8]),
            _p::Word([103u8, 114u8, 97u8, 117u8, 108u8, 116u8, 0u8, 0u8]),
            _p::Word([9u8, 0u8, 0u8, 0u8, 50u8, 0u8, 0u8, 0u8]),
            _p::Word([9u8, 0u8, 0u8, 0u8, 42u8, 0u8, 0u8, 0u8]),
            _p::Word([9u8, 0u8, 0u8, 0u8, 34u8, 0u8, 0u8, 0u8]),
            _p::Word([103u8, 97u8, 114u8, 112u8, 108u8, 121u8, 0u8, 0u8]),
            _p::Word([119u8, 97u8, 108u8, 100u8, 111u8, 0u8, 0u8, 0u8]),
            _p::Word([102u8, 114u8, 101u8, 100u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([12u8, 0u8, 0u8, 0u8, 6u8, 0u8, 20u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([29u8, 1u8, 0u8, 0u8, 122u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([189u8, 0u8, 0u8, 0u8, 122u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([93u8, 0u8, 0u8, 0u8, 122u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([120u8, 32u8, 115u8, 116u8, 114u8, 117u8, 99u8, 116u8]),
            _p::Word([108u8, 105u8, 115u8, 116u8, 32u8, 49u8, 0u8, 0u8]),
            _p::Word([120u8, 32u8, 115u8, 116u8, 114u8, 117u8, 99u8, 116u8]),
            _p::Word([108u8, 105u8, 115u8, 116u8, 32u8, 50u8, 0u8, 0u8]),
            _p::Word([120u8, 32u8, 115u8, 116u8, 114u8, 117u8, 99u8, 116u8]),
            _p::Word([108u8, 105u8, 115u8, 116u8, 32u8, 51u8, 0u8, 0u8]),
            _p::Word([3u8, 0u8, 1u8, 0u8, 6u8, 0u8, 0u8, 0u8]),
            _p::Word([9u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([111u8, 145u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([103u8, 43u8, 153u8, 212u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([199u8, 107u8, 159u8, 6u8, 57u8, 148u8, 96u8, 249u8]),
            _p::Word([199u8, 113u8, 196u8, 43u8, 171u8, 117u8, 107u8, 15u8]),
            _p::Word([57u8, 142u8, 59u8, 212u8, 84u8, 138u8, 148u8, 240u8]),
            _p::Word([111u8, 222u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([53u8, 130u8, 156u8, 173u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([85u8, 161u8, 174u8, 198u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([199u8, 113u8, 172u8, 181u8, 175u8, 152u8, 50u8, 154u8]),
            _p::Word([0u8, 156u8, 173u8, 69u8, 0u8, 0u8, 128u8, 127u8]),
            _p::Word([0u8, 0u8, 128u8, 255u8, 0u8, 0u8, 192u8, 127u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 192u8, 97u8, 190u8, 64u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 240u8, 127u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 240u8, 255u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 248u8, 127u8]),
            _p::Word([9u8, 0u8, 0u8, 0u8, 50u8, 0u8, 0u8, 0u8]),
            _p::Word([9u8, 0u8, 0u8, 0u8, 50u8, 0u8, 0u8, 0u8]),
            _p::Word([9u8, 0u8, 0u8, 0u8, 42u8, 0u8, 0u8, 0u8]),
            _p::Word([112u8, 108u8, 117u8, 103u8, 104u8, 0u8, 0u8, 0u8]),
            _p::Word([120u8, 121u8, 122u8, 122u8, 121u8, 0u8, 0u8, 0u8]),
            _p::Word([116u8, 104u8, 117u8, 100u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([9u8, 0u8, 0u8, 0u8, 34u8, 0u8, 0u8, 0u8]),
            _p::Word([9u8, 0u8, 0u8, 0u8, 74u8, 0u8, 0u8, 0u8]),
            _p::Word([13u8, 0u8, 0u8, 0u8, 58u8, 0u8, 0u8, 0u8]),
            _p::Word([111u8, 111u8, 112u8, 115u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([101u8, 120u8, 104u8, 97u8, 117u8, 115u8, 116u8, 101u8]),
            _p::Word([100u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([114u8, 102u8, 99u8, 51u8, 48u8, 57u8, 50u8, 0u8]),
            _p::Word([12u8, 0u8, 0u8, 0u8, 6u8, 0u8, 20u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([29u8, 1u8, 0u8, 0u8, 106u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([189u8, 0u8, 0u8, 0u8, 106u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([93u8, 0u8, 0u8, 0u8, 106u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([115u8, 116u8, 114u8, 117u8, 99u8, 116u8, 108u8, 105u8]),
            _p::Word([115u8, 116u8, 32u8, 49u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([115u8, 116u8, 114u8, 117u8, 99u8, 116u8, 108u8, 105u8]),
            _p::Word([115u8, 116u8, 32u8, 50u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([115u8, 116u8, 114u8, 117u8, 99u8, 116u8, 108u8, 105u8]),
            _p::Word([115u8, 116u8, 32u8, 51u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 7u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
        ],
    )
};
pub const NON_ASCII_TEXT: _p::ty::ConstPtr<_p::Text> = unsafe {
    _p::ty::ConstPtr::new(
        &[
            _p::Word([1u8, 0u8, 0u8, 0u8, 90u8, 0u8, 0u8, 0u8]),
            _p::Word([226u8, 153u8, 171u8, 32u8, 195u8, 169u8, 32u8, 226u8]),
            _p::Word([156u8, 147u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
        ],
    )
};
pub const BLOCK_TEXT: _p::ty::ConstPtr<_p::Text> = unsafe {
    _p::ty::ConstPtr::new(
        &[
            _p::Word([1u8, 0u8, 0u8, 0u8, 250u8, 2u8, 0u8, 0u8]),
            _p::Word([102u8, 111u8, 111u8, 32u8, 98u8, 97u8, 114u8, 32u8]),
            _p::Word([98u8, 97u8, 122u8, 10u8, 34u8, 113u8, 117u8, 120u8]),
            _p::Word([34u8, 32u8, 96u8, 99u8, 111u8, 114u8, 103u8, 101u8]),
            _p::Word([96u8, 32u8, 39u8, 103u8, 114u8, 97u8, 117u8, 108u8]),
            _p::Word([116u8, 39u8, 10u8, 114u8, 101u8, 103u8, 117u8, 108u8]),
            _p::Word([97u8, 114u8, 34u8, 113u8, 117u8, 111u8, 116u8, 101u8]),
            _p::Word([100u8, 34u8, 108u8, 105u8, 110u8, 101u8, 103u8, 97u8]),
            _p::Word([114u8, 112u8, 108u8, 121u8, 92u8, 110u8, 119u8, 97u8]),
            _p::Word([108u8, 100u8, 111u8, 92u8, 116u8, 102u8, 114u8, 101u8]),
            _p::Word([100u8, 92u8, 34u8, 112u8, 108u8, 117u8, 103u8, 104u8]),
            _p::Word([92u8, 34u8, 120u8, 121u8, 122u8, 122u8, 121u8, 92u8]),
            _p::Word([39u8, 116u8, 104u8, 117u8, 100u8, 10u8, 0u8, 0u8]),
        ],
    )
};
#[derive(Clone)]
pub struct TestAnyPointerConstants<T = _p::Family>(T);
impl _p::ty::SchemaType for TestAnyPointerConstants {
    const ID: u64 = 15979476109953374643u64;
}
impl<T> _p::IntoFamily for TestAnyPointerConstants<T> {
    type Family = TestAnyPointerConstants;
}
impl<T: _p::Capable> _p::Capable for TestAnyPointerConstants<T> {
    type Table = T::Table;
    type Imbued = T::Imbued;
    type ImbuedWith<T2: _p::rpc::Table> = TestAnyPointerConstants<T::ImbuedWith<T2>>;
    #[inline]
    fn imbued(&self) -> &Self::Imbued {
        self.0.imbued()
    }
    #[inline]
    fn imbue_release<T2: _p::rpc::Table>(
        self,
        new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
    ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
        let (imbued, old) = self.0.imbue_release(new_table);
        (TestAnyPointerConstants(imbued), old)
    }
    #[inline]
    fn imbue_release_into<U>(&self, other: U) -> (U::ImbuedWith<Self::Table>, U::Imbued)
    where
        U: _p::Capable,
        U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
    {
        self.0.imbue_release_into(other)
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr
for test_any_pointer_constants::Reader<'a, T> {
    type Ptr = _p::StructReader<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
for test_any_pointer_constants::Reader<'a, T> {
    #[inline]
    fn from(ptr: _p::StructReader<'a, T>) -> Self {
        TestAnyPointerConstants(ptr)
    }
}
impl<
    'a,
    T: _p::rpc::Table,
> core::convert::From<test_any_pointer_constants::Reader<'a, T>>
for _p::StructReader<'a, T> {
    #[inline]
    fn from(reader: test_any_pointer_constants::Reader<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
for test_any_pointer_constants::Reader<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructReader<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructReader
for test_any_pointer_constants::Reader<'a, T> {}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr
for test_any_pointer_constants::Builder<'a, T> {
    type Ptr = _p::StructBuilder<'a, T>;
}
impl<
    'a,
    T: _p::rpc::Table,
> core::convert::From<test_any_pointer_constants::Builder<'a, T>>
for _p::StructBuilder<'a, T> {
    #[inline]
    fn from(reader: test_any_pointer_constants::Builder<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
for test_any_pointer_constants::Builder<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
for test_any_pointer_constants::Builder<'a, T> {
    #[inline]
    fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
        &mut self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder
for test_any_pointer_constants::Builder<'a, T> {
    unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
        Self(ptr)
    }
}
impl _p::StructView for TestAnyPointerConstants {
    type Reader<'a, T: _p::rpc::Table> = test_any_pointer_constants::Reader<'a, T>;
    type Builder<'a, T: _p::rpc::Table> = test_any_pointer_constants::Builder<'a, T>;
}
impl _p::ty::Struct for TestAnyPointerConstants {
    const SIZE: _p::StructSize = _p::StructSize {
        data: 0u16,
        ptrs: 4u16,
    };
}
impl TestAnyPointerConstants {
    const ANY_KIND_AS_STRUCT: _p::Descriptor<_p::AnyPtr> = _p::Descriptor::<_p::AnyPtr> {
        slot: 0u32,
        default: ::core::option::Option::None,
    };
    const ANY_STRUCT_AS_STRUCT: _p::Descriptor<_p::AnyStruct> = _p::Descriptor::<
        _p::AnyStruct,
    > {
        slot: 1u32,
        default: ::core::option::Option::None,
    };
    const ANY_KIND_AS_LIST: _p::Descriptor<_p::AnyPtr> = _p::Descriptor::<_p::AnyPtr> {
        slot: 2u32,
        default: ::core::option::Option::None,
    };
    const ANY_LIST_AS_LIST: _p::Descriptor<_p::AnyList> = _p::Descriptor::<_p::AnyList> {
        slot: 3u32,
        default: ::core::option::Option::None,
    };
}
impl<'p, T: _p::rpc::Table + 'p> test_any_pointer_constants::Reader<'p, T> {
    #[inline]
    pub fn any_kind_as_struct(&self) -> _p::Accessor<'_, 'p, T, _p::AnyPtr> {
        unsafe {
            <_p::AnyPtr as _p::field::FieldType>::accessor(
                &self.0,
                &TestAnyPointerConstants::ANY_KIND_AS_STRUCT,
            )
        }
    }
    #[inline]
    pub fn any_struct_as_struct(&self) -> _p::Accessor<'_, 'p, T, _p::AnyStruct> {
        unsafe {
            <_p::AnyStruct as _p::field::FieldType>::accessor(
                &self.0,
                &TestAnyPointerConstants::ANY_STRUCT_AS_STRUCT,
            )
        }
    }
    #[inline]
    pub fn any_kind_as_list(&self) -> _p::Accessor<'_, 'p, T, _p::AnyPtr> {
        unsafe {
            <_p::AnyPtr as _p::field::FieldType>::accessor(
                &self.0,
                &TestAnyPointerConstants::ANY_KIND_AS_LIST,
            )
        }
    }
    #[inline]
    pub fn any_list_as_list(&self) -> _p::Accessor<'_, 'p, T, _p::AnyList> {
        unsafe {
            <_p::AnyList as _p::field::FieldType>::accessor(
                &self.0,
                &TestAnyPointerConstants::ANY_LIST_AS_LIST,
            )
        }
    }
}
impl<'p, T: _p::rpc::Table + 'p> test_any_pointer_constants::Builder<'p, T> {
    #[inline]
    pub fn any_kind_as_struct(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::AnyPtr> {
        unsafe {
            <_p::AnyPtr as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestAnyPointerConstants::ANY_KIND_AS_STRUCT,
            )
        }
    }
    #[inline]
    pub fn any_struct_as_struct(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::AnyStruct> {
        unsafe {
            <_p::AnyStruct as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestAnyPointerConstants::ANY_STRUCT_AS_STRUCT,
            )
        }
    }
    #[inline]
    pub fn any_kind_as_list(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::AnyPtr> {
        unsafe {
            <_p::AnyPtr as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestAnyPointerConstants::ANY_KIND_AS_LIST,
            )
        }
    }
    #[inline]
    pub fn any_list_as_list(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::AnyList> {
        unsafe {
            <_p::AnyList as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestAnyPointerConstants::ANY_LIST_AS_LIST,
            )
        }
    }
    #[inline]
    pub fn into_any_kind_as_struct(self) -> _p::AccessorOwned<'p, T, _p::AnyPtr> {
        unsafe {
            <_p::AnyPtr as _p::field::FieldType>::accessor(
                self.0,
                &TestAnyPointerConstants::ANY_KIND_AS_STRUCT,
            )
        }
    }
    #[inline]
    pub fn into_any_struct_as_struct(self) -> _p::AccessorOwned<'p, T, _p::AnyStruct> {
        unsafe {
            <_p::AnyStruct as _p::field::FieldType>::accessor(
                self.0,
                &TestAnyPointerConstants::ANY_STRUCT_AS_STRUCT,
            )
        }
    }
    #[inline]
    pub fn into_any_kind_as_list(self) -> _p::AccessorOwned<'p, T, _p::AnyPtr> {
        unsafe {
            <_p::AnyPtr as _p::field::FieldType>::accessor(
                self.0,
                &TestAnyPointerConstants::ANY_KIND_AS_LIST,
            )
        }
    }
    #[inline]
    pub fn into_any_list_as_list(self) -> _p::AccessorOwned<'p, T, _p::AnyList> {
        unsafe {
            <_p::AnyList as _p::field::FieldType>::accessor(
                self.0,
                &TestAnyPointerConstants::ANY_LIST_AS_LIST,
            )
        }
    }
}
pub mod test_any_pointer_constants {
    use super::{__file, __imports, _p};
    pub type Reader<'a, T = _p::rpc::Empty> = super::TestAnyPointerConstants<
        _p::StructReader<'a, T>,
    >;
    pub type Builder<'a, T = _p::rpc::Empty> = super::TestAnyPointerConstants<
        _p::StructBuilder<'a, T>,
    >;
}
pub const ANY_POINTER_CONSTANTS: _p::ty::ConstPtr<_p::Struct<TestAnyPointerConstants>> = unsafe {
    _p::ty::ConstPtr::new(
        &[
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 4u8, 0u8]),
            _p::Word([12u8, 0u8, 0u8, 0u8, 6u8, 0u8, 20u8, 0u8]),
            _p::Word([68u8, 3u8, 0u8, 0u8, 6u8, 0u8, 20u8, 0u8]),
            _p::Word([125u8, 6u8, 0u8, 0u8, 20u8, 0u8, 0u8, 0u8]),
            _p::Word([125u8, 6u8, 0u8, 0u8, 20u8, 0u8, 0u8, 0u8]),
            _p::Word([1u8, 244u8, 128u8, 13u8, 14u8, 16u8, 76u8, 251u8]),
            _p::Word([78u8, 115u8, 232u8, 56u8, 166u8, 51u8, 0u8, 0u8]),
            _p::Word([90u8, 0u8, 210u8, 4u8, 20u8, 136u8, 98u8, 3u8]),
            _p::Word([210u8, 10u8, 111u8, 18u8, 33u8, 25u8, 204u8, 4u8]),
            _p::Word([95u8, 112u8, 9u8, 175u8, 2u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 144u8, 117u8, 64u8]),
            _p::Word([77u8, 0u8, 0u8, 0u8, 34u8, 0u8, 0u8, 0u8]),
            _p::Word([77u8, 0u8, 0u8, 0u8, 26u8, 0u8, 0u8, 0u8]),
            _p::Word([76u8, 0u8, 0u8, 0u8, 6u8, 0u8, 20u8, 0u8]),
            _p::Word([1u8, 0u8, 0u8, 0u8, 24u8, 0u8, 0u8, 0u8]),
            _p::Word([33u8, 1u8, 0u8, 0u8, 41u8, 0u8, 0u8, 0u8]),
            _p::Word([33u8, 1u8, 0u8, 0u8, 34u8, 0u8, 0u8, 0u8]),
            _p::Word([33u8, 1u8, 0u8, 0u8, 35u8, 0u8, 0u8, 0u8]),
            _p::Word([33u8, 1u8, 0u8, 0u8, 36u8, 0u8, 0u8, 0u8]),
            _p::Word([37u8, 1u8, 0u8, 0u8, 37u8, 0u8, 0u8, 0u8]),
            _p::Word([49u8, 1u8, 0u8, 0u8, 34u8, 0u8, 0u8, 0u8]),
            _p::Word([49u8, 1u8, 0u8, 0u8, 35u8, 0u8, 0u8, 0u8]),
            _p::Word([49u8, 1u8, 0u8, 0u8, 36u8, 0u8, 0u8, 0u8]),
            _p::Word([53u8, 1u8, 0u8, 0u8, 37u8, 0u8, 0u8, 0u8]),
            _p::Word([65u8, 1u8, 0u8, 0u8, 52u8, 0u8, 0u8, 0u8]),
            _p::Word([73u8, 1u8, 0u8, 0u8, 53u8, 0u8, 0u8, 0u8]),
            _p::Word([93u8, 1u8, 0u8, 0u8, 30u8, 0u8, 0u8, 0u8]),
            _p::Word([113u8, 1u8, 0u8, 0u8, 30u8, 0u8, 0u8, 0u8]),
            _p::Word([133u8, 1u8, 0u8, 0u8, 119u8, 2u8, 0u8, 0u8]),
            _p::Word([213u8, 2u8, 0u8, 0u8, 27u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([98u8, 97u8, 122u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([113u8, 117u8, 120u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([77u8, 0u8, 0u8, 0u8, 58u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([72u8, 0u8, 0u8, 0u8, 6u8, 0u8, 20u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([110u8, 101u8, 115u8, 116u8, 101u8, 100u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([77u8, 0u8, 0u8, 0u8, 114u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([114u8, 101u8, 97u8, 108u8, 108u8, 121u8, 32u8, 110u8]),
            _p::Word([101u8, 115u8, 116u8, 101u8, 100u8, 0u8, 0u8, 0u8]),
            _p::Word([26u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([12u8, 222u8, 128u8, 127u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([210u8, 4u8, 210u8, 233u8, 0u8, 128u8, 255u8, 127u8]),
            _p::Word([78u8, 97u8, 188u8, 0u8, 64u8, 211u8, 160u8, 250u8]),
            _p::Word([0u8, 0u8, 0u8, 128u8, 255u8, 255u8, 255u8, 127u8]),
            _p::Word([121u8, 223u8, 13u8, 134u8, 72u8, 112u8, 0u8, 0u8]),
            _p::Word([46u8, 117u8, 19u8, 253u8, 138u8, 150u8, 253u8, 255u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 128u8]),
            _p::Word([255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 127u8]),
            _p::Word([12u8, 34u8, 0u8, 255u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([210u8, 4u8, 46u8, 22u8, 0u8, 0u8, 255u8, 255u8]),
            _p::Word([78u8, 97u8, 188u8, 0u8, 192u8, 44u8, 95u8, 5u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 255u8, 255u8, 255u8, 255u8]),
            _p::Word([121u8, 223u8, 13u8, 134u8, 72u8, 112u8, 0u8, 0u8]),
            _p::Word([210u8, 138u8, 236u8, 2u8, 117u8, 105u8, 2u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 56u8, 180u8, 150u8, 73u8]),
            _p::Word([194u8, 189u8, 240u8, 124u8, 194u8, 189u8, 240u8, 252u8]),
            _p::Word([234u8, 28u8, 8u8, 2u8, 234u8, 28u8, 8u8, 130u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([64u8, 222u8, 119u8, 131u8, 33u8, 18u8, 220u8, 66u8]),
            _p::Word([41u8, 144u8, 35u8, 202u8, 229u8, 200u8, 118u8, 127u8]),
            _p::Word([41u8, 144u8, 35u8, 202u8, 229u8, 200u8, 118u8, 255u8]),
            _p::Word([145u8, 247u8, 80u8, 55u8, 158u8, 120u8, 102u8, 0u8]),
            _p::Word([145u8, 247u8, 80u8, 55u8, 158u8, 120u8, 102u8, 128u8]),
            _p::Word([9u8, 0u8, 0u8, 0u8, 42u8, 0u8, 0u8, 0u8]),
            _p::Word([9u8, 0u8, 0u8, 0u8, 50u8, 0u8, 0u8, 0u8]),
            _p::Word([9u8, 0u8, 0u8, 0u8, 58u8, 0u8, 0u8, 0u8]),
            _p::Word([113u8, 117u8, 117u8, 120u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([99u8, 111u8, 114u8, 103u8, 101u8, 0u8, 0u8, 0u8]),
            _p::Word([103u8, 114u8, 97u8, 117u8, 108u8, 116u8, 0u8, 0u8]),
            _p::Word([9u8, 0u8, 0u8, 0u8, 50u8, 0u8, 0u8, 0u8]),
            _p::Word([9u8, 0u8, 0u8, 0u8, 42u8, 0u8, 0u8, 0u8]),
            _p::Word([9u8, 0u8, 0u8, 0u8, 34u8, 0u8, 0u8, 0u8]),
            _p::Word([103u8, 97u8, 114u8, 112u8, 108u8, 121u8, 0u8, 0u8]),
            _p::Word([119u8, 97u8, 108u8, 100u8, 111u8, 0u8, 0u8, 0u8]),
            _p::Word([102u8, 114u8, 101u8, 100u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([12u8, 0u8, 0u8, 0u8, 6u8, 0u8, 20u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([29u8, 1u8, 0u8, 0u8, 122u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([189u8, 0u8, 0u8, 0u8, 122u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([93u8, 0u8, 0u8, 0u8, 122u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([120u8, 32u8, 115u8, 116u8, 114u8, 117u8, 99u8, 116u8]),
            _p::Word([108u8, 105u8, 115u8, 116u8, 32u8, 49u8, 0u8, 0u8]),
            _p::Word([120u8, 32u8, 115u8, 116u8, 114u8, 117u8, 99u8, 116u8]),
            _p::Word([108u8, 105u8, 115u8, 116u8, 32u8, 50u8, 0u8, 0u8]),
            _p::Word([120u8, 32u8, 115u8, 116u8, 114u8, 117u8, 99u8, 116u8]),
            _p::Word([108u8, 105u8, 115u8, 116u8, 32u8, 51u8, 0u8, 0u8]),
            _p::Word([3u8, 0u8, 1u8, 0u8, 6u8, 0u8, 0u8, 0u8]),
            _p::Word([1u8, 244u8, 128u8, 13u8, 14u8, 16u8, 76u8, 251u8]),
            _p::Word([78u8, 115u8, 232u8, 56u8, 166u8, 51u8, 0u8, 0u8]),
            _p::Word([90u8, 0u8, 210u8, 4u8, 20u8, 136u8, 98u8, 3u8]),
            _p::Word([210u8, 10u8, 111u8, 18u8, 33u8, 25u8, 204u8, 4u8]),
            _p::Word([95u8, 112u8, 9u8, 175u8, 2u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 144u8, 117u8, 64u8]),
            _p::Word([77u8, 0u8, 0u8, 0u8, 34u8, 0u8, 0u8, 0u8]),
            _p::Word([77u8, 0u8, 0u8, 0u8, 26u8, 0u8, 0u8, 0u8]),
            _p::Word([76u8, 0u8, 0u8, 0u8, 6u8, 0u8, 20u8, 0u8]),
            _p::Word([1u8, 0u8, 0u8, 0u8, 24u8, 0u8, 0u8, 0u8]),
            _p::Word([33u8, 1u8, 0u8, 0u8, 41u8, 0u8, 0u8, 0u8]),
            _p::Word([33u8, 1u8, 0u8, 0u8, 34u8, 0u8, 0u8, 0u8]),
            _p::Word([33u8, 1u8, 0u8, 0u8, 35u8, 0u8, 0u8, 0u8]),
            _p::Word([33u8, 1u8, 0u8, 0u8, 36u8, 0u8, 0u8, 0u8]),
            _p::Word([37u8, 1u8, 0u8, 0u8, 37u8, 0u8, 0u8, 0u8]),
            _p::Word([49u8, 1u8, 0u8, 0u8, 34u8, 0u8, 0u8, 0u8]),
            _p::Word([49u8, 1u8, 0u8, 0u8, 35u8, 0u8, 0u8, 0u8]),
            _p::Word([49u8, 1u8, 0u8, 0u8, 36u8, 0u8, 0u8, 0u8]),
            _p::Word([53u8, 1u8, 0u8, 0u8, 37u8, 0u8, 0u8, 0u8]),
            _p::Word([65u8, 1u8, 0u8, 0u8, 52u8, 0u8, 0u8, 0u8]),
            _p::Word([73u8, 1u8, 0u8, 0u8, 53u8, 0u8, 0u8, 0u8]),
            _p::Word([93u8, 1u8, 0u8, 0u8, 30u8, 0u8, 0u8, 0u8]),
            _p::Word([113u8, 1u8, 0u8, 0u8, 30u8, 0u8, 0u8, 0u8]),
            _p::Word([133u8, 1u8, 0u8, 0u8, 119u8, 2u8, 0u8, 0u8]),
            _p::Word([213u8, 2u8, 0u8, 0u8, 27u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([98u8, 97u8, 122u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([113u8, 117u8, 120u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([77u8, 0u8, 0u8, 0u8, 58u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([72u8, 0u8, 0u8, 0u8, 6u8, 0u8, 20u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([110u8, 101u8, 115u8, 116u8, 101u8, 100u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([77u8, 0u8, 0u8, 0u8, 114u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([114u8, 101u8, 97u8, 108u8, 108u8, 121u8, 32u8, 110u8]),
            _p::Word([101u8, 115u8, 116u8, 101u8, 100u8, 0u8, 0u8, 0u8]),
            _p::Word([26u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([12u8, 222u8, 128u8, 127u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([210u8, 4u8, 210u8, 233u8, 0u8, 128u8, 255u8, 127u8]),
            _p::Word([78u8, 97u8, 188u8, 0u8, 64u8, 211u8, 160u8, 250u8]),
            _p::Word([0u8, 0u8, 0u8, 128u8, 255u8, 255u8, 255u8, 127u8]),
            _p::Word([121u8, 223u8, 13u8, 134u8, 72u8, 112u8, 0u8, 0u8]),
            _p::Word([46u8, 117u8, 19u8, 253u8, 138u8, 150u8, 253u8, 255u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 128u8]),
            _p::Word([255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 127u8]),
            _p::Word([12u8, 34u8, 0u8, 255u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([210u8, 4u8, 46u8, 22u8, 0u8, 0u8, 255u8, 255u8]),
            _p::Word([78u8, 97u8, 188u8, 0u8, 192u8, 44u8, 95u8, 5u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 255u8, 255u8, 255u8, 255u8]),
            _p::Word([121u8, 223u8, 13u8, 134u8, 72u8, 112u8, 0u8, 0u8]),
            _p::Word([210u8, 138u8, 236u8, 2u8, 117u8, 105u8, 2u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 56u8, 180u8, 150u8, 73u8]),
            _p::Word([194u8, 189u8, 240u8, 124u8, 194u8, 189u8, 240u8, 252u8]),
            _p::Word([234u8, 28u8, 8u8, 2u8, 234u8, 28u8, 8u8, 130u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([64u8, 222u8, 119u8, 131u8, 33u8, 18u8, 220u8, 66u8]),
            _p::Word([41u8, 144u8, 35u8, 202u8, 229u8, 200u8, 118u8, 127u8]),
            _p::Word([41u8, 144u8, 35u8, 202u8, 229u8, 200u8, 118u8, 255u8]),
            _p::Word([145u8, 247u8, 80u8, 55u8, 158u8, 120u8, 102u8, 0u8]),
            _p::Word([145u8, 247u8, 80u8, 55u8, 158u8, 120u8, 102u8, 128u8]),
            _p::Word([9u8, 0u8, 0u8, 0u8, 42u8, 0u8, 0u8, 0u8]),
            _p::Word([9u8, 0u8, 0u8, 0u8, 50u8, 0u8, 0u8, 0u8]),
            _p::Word([9u8, 0u8, 0u8, 0u8, 58u8, 0u8, 0u8, 0u8]),
            _p::Word([113u8, 117u8, 117u8, 120u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([99u8, 111u8, 114u8, 103u8, 101u8, 0u8, 0u8, 0u8]),
            _p::Word([103u8, 114u8, 97u8, 117u8, 108u8, 116u8, 0u8, 0u8]),
            _p::Word([9u8, 0u8, 0u8, 0u8, 50u8, 0u8, 0u8, 0u8]),
            _p::Word([9u8, 0u8, 0u8, 0u8, 42u8, 0u8, 0u8, 0u8]),
            _p::Word([9u8, 0u8, 0u8, 0u8, 34u8, 0u8, 0u8, 0u8]),
            _p::Word([103u8, 97u8, 114u8, 112u8, 108u8, 121u8, 0u8, 0u8]),
            _p::Word([119u8, 97u8, 108u8, 100u8, 111u8, 0u8, 0u8, 0u8]),
            _p::Word([102u8, 114u8, 101u8, 100u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([12u8, 0u8, 0u8, 0u8, 6u8, 0u8, 20u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([29u8, 1u8, 0u8, 0u8, 122u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([189u8, 0u8, 0u8, 0u8, 122u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([93u8, 0u8, 0u8, 0u8, 122u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([120u8, 32u8, 115u8, 116u8, 114u8, 117u8, 99u8, 116u8]),
            _p::Word([108u8, 105u8, 115u8, 116u8, 32u8, 49u8, 0u8, 0u8]),
            _p::Word([120u8, 32u8, 115u8, 116u8, 114u8, 117u8, 99u8, 116u8]),
            _p::Word([108u8, 105u8, 115u8, 116u8, 32u8, 50u8, 0u8, 0u8]),
            _p::Word([120u8, 32u8, 115u8, 116u8, 114u8, 117u8, 99u8, 116u8]),
            _p::Word([108u8, 105u8, 115u8, 116u8, 32u8, 51u8, 0u8, 0u8]),
            _p::Word([3u8, 0u8, 1u8, 0u8, 6u8, 0u8, 0u8, 0u8]),
            _p::Word([199u8, 107u8, 159u8, 6u8, 57u8, 148u8, 96u8, 249u8]),
            _p::Word([199u8, 107u8, 159u8, 6u8, 57u8, 148u8, 96u8, 249u8]),
        ],
    )
};
#[derive(Clone)]
pub struct TestListOfAny<T = _p::Family>(T);
impl _p::ty::SchemaType for TestListOfAny {
    const ID: u64 = 12849988285685149627u64;
}
impl<T> _p::IntoFamily for TestListOfAny<T> {
    type Family = TestListOfAny;
}
impl<T: _p::Capable> _p::Capable for TestListOfAny<T> {
    type Table = T::Table;
    type Imbued = T::Imbued;
    type ImbuedWith<T2: _p::rpc::Table> = TestListOfAny<T::ImbuedWith<T2>>;
    #[inline]
    fn imbued(&self) -> &Self::Imbued {
        self.0.imbued()
    }
    #[inline]
    fn imbue_release<T2: _p::rpc::Table>(
        self,
        new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
    ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
        let (imbued, old) = self.0.imbue_release(new_table);
        (TestListOfAny(imbued), old)
    }
    #[inline]
    fn imbue_release_into<U>(&self, other: U) -> (U::ImbuedWith<Self::Table>, U::Imbued)
    where
        U: _p::Capable,
        U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
    {
        self.0.imbue_release_into(other)
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_list_of_any::Reader<'a, T> {
    type Ptr = _p::StructReader<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
for test_list_of_any::Reader<'a, T> {
    #[inline]
    fn from(ptr: _p::StructReader<'a, T>) -> Self {
        TestListOfAny(ptr)
    }
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_list_of_any::Reader<'a, T>>
for _p::StructReader<'a, T> {
    #[inline]
    fn from(reader: test_list_of_any::Reader<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
for test_list_of_any::Reader<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructReader<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructReader for test_list_of_any::Reader<'a, T> {}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_list_of_any::Builder<'a, T> {
    type Ptr = _p::StructBuilder<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_list_of_any::Builder<'a, T>>
for _p::StructBuilder<'a, T> {
    #[inline]
    fn from(reader: test_list_of_any::Builder<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
for test_list_of_any::Builder<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
for test_list_of_any::Builder<'a, T> {
    #[inline]
    fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
        &mut self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for test_list_of_any::Builder<'a, T> {
    unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
        Self(ptr)
    }
}
impl _p::StructView for TestListOfAny {
    type Reader<'a, T: _p::rpc::Table> = test_list_of_any::Reader<'a, T>;
    type Builder<'a, T: _p::rpc::Table> = test_list_of_any::Builder<'a, T>;
}
impl _p::ty::Struct for TestListOfAny {
    const SIZE: _p::StructSize = _p::StructSize {
        data: 0u16,
        ptrs: 2u16,
    };
}
impl TestListOfAny {
    const CAP_LIST: _p::Descriptor<_p::List<_p::AnyPtr>> = _p::Descriptor::<
        _p::List<_p::AnyPtr>,
    > {
        slot: 0u32,
        default: ::core::option::Option::None,
    };
    const LIST_LIST: _p::Descriptor<_p::List<_p::AnyList>> = _p::Descriptor::<
        _p::List<_p::AnyList>,
    > {
        slot: 1u32,
        default: ::core::option::Option::None,
    };
}
impl<'p, T: _p::rpc::Table + 'p> test_list_of_any::Reader<'p, T> {
    #[inline]
    pub fn cap_list(&self) -> _p::Accessor<'_, 'p, T, _p::List<_p::AnyPtr>> {
        unsafe {
            <_p::List<
                _p::AnyPtr,
            > as _p::field::FieldType>::accessor(&self.0, &TestListOfAny::CAP_LIST)
        }
    }
    #[inline]
    pub fn list_list(&self) -> _p::Accessor<'_, 'p, T, _p::List<_p::AnyList>> {
        unsafe {
            <_p::List<
                _p::AnyList,
            > as _p::field::FieldType>::accessor(&self.0, &TestListOfAny::LIST_LIST)
        }
    }
}
impl<'p, T: _p::rpc::Table + 'p> test_list_of_any::Builder<'p, T> {
    #[inline]
    pub fn cap_list(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::List<_p::AnyPtr>> {
        unsafe {
            <_p::List<
                _p::AnyPtr,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestListOfAny::CAP_LIST)
        }
    }
    #[inline]
    pub fn list_list(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::List<_p::AnyList>> {
        unsafe {
            <_p::List<
                _p::AnyList,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestListOfAny::LIST_LIST)
        }
    }
    #[inline]
    pub fn into_cap_list(self) -> _p::AccessorOwned<'p, T, _p::List<_p::AnyPtr>> {
        unsafe {
            <_p::List<
                _p::AnyPtr,
            > as _p::field::FieldType>::accessor(self.0, &TestListOfAny::CAP_LIST)
        }
    }
    #[inline]
    pub fn into_list_list(self) -> _p::AccessorOwned<'p, T, _p::List<_p::AnyList>> {
        unsafe {
            <_p::List<
                _p::AnyList,
            > as _p::field::FieldType>::accessor(self.0, &TestListOfAny::LIST_LIST)
        }
    }
}
pub mod test_list_of_any {
    use super::{__file, __imports, _p};
    pub type Reader<'a, T = _p::rpc::Empty> = super::TestListOfAny<
        _p::StructReader<'a, T>,
    >;
    pub type Builder<'a, T = _p::rpc::Empty> = super::TestListOfAny<
        _p::StructBuilder<'a, T>,
    >;
}
#[derive(Clone)]
pub struct TestContainMembrane<T = _p::Family>(T);
impl _p::ty::SchemaType for TestContainMembrane {
    const ID: u64 = 10706263223626234460u64;
}
impl<T> _p::IntoFamily for TestContainMembrane<T> {
    type Family = TestContainMembrane;
}
impl<T: _p::Capable> _p::Capable for TestContainMembrane<T> {
    type Table = T::Table;
    type Imbued = T::Imbued;
    type ImbuedWith<T2: _p::rpc::Table> = TestContainMembrane<T::ImbuedWith<T2>>;
    #[inline]
    fn imbued(&self) -> &Self::Imbued {
        self.0.imbued()
    }
    #[inline]
    fn imbue_release<T2: _p::rpc::Table>(
        self,
        new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
    ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
        let (imbued, old) = self.0.imbue_release(new_table);
        (TestContainMembrane(imbued), old)
    }
    #[inline]
    fn imbue_release_into<U>(&self, other: U) -> (U::ImbuedWith<Self::Table>, U::Imbued)
    where
        U: _p::Capable,
        U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
    {
        self.0.imbue_release_into(other)
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_contain_membrane::Reader<'a, T> {
    type Ptr = _p::StructReader<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
for test_contain_membrane::Reader<'a, T> {
    #[inline]
    fn from(ptr: _p::StructReader<'a, T>) -> Self {
        TestContainMembrane(ptr)
    }
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_contain_membrane::Reader<'a, T>>
for _p::StructReader<'a, T> {
    #[inline]
    fn from(reader: test_contain_membrane::Reader<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
for test_contain_membrane::Reader<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructReader<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructReader
for test_contain_membrane::Reader<'a, T> {}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_contain_membrane::Builder<'a, T> {
    type Ptr = _p::StructBuilder<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_contain_membrane::Builder<'a, T>>
for _p::StructBuilder<'a, T> {
    #[inline]
    fn from(reader: test_contain_membrane::Builder<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
for test_contain_membrane::Builder<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
for test_contain_membrane::Builder<'a, T> {
    #[inline]
    fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
        &mut self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder
for test_contain_membrane::Builder<'a, T> {
    unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
        Self(ptr)
    }
}
impl _p::StructView for TestContainMembrane {
    type Reader<'a, T: _p::rpc::Table> = test_contain_membrane::Reader<'a, T>;
    type Builder<'a, T: _p::rpc::Table> = test_contain_membrane::Builder<'a, T>;
}
impl _p::ty::Struct for TestContainMembrane {
    const SIZE: _p::StructSize = _p::StructSize {
        data: 0u16,
        ptrs: 2u16,
    };
}
impl TestContainMembrane {
    const CAP: _p::Descriptor<_p::AnyPtr> = _p::Descriptor::<_p::AnyPtr> {
        slot: 0u32,
        default: ::core::option::Option::None,
    };
    const LIST: _p::Descriptor<_p::List<_p::AnyPtr>> = _p::Descriptor::<
        _p::List<_p::AnyPtr>,
    > {
        slot: 1u32,
        default: ::core::option::Option::None,
    };
}
impl<'p, T: _p::rpc::Table + 'p> test_contain_membrane::Reader<'p, T> {
    #[inline]
    pub fn cap(&self) -> _p::Accessor<'_, 'p, T, _p::AnyPtr> {
        unsafe {
            <_p::AnyPtr as _p::field::FieldType>::accessor(
                &self.0,
                &TestContainMembrane::CAP,
            )
        }
    }
    #[inline]
    pub fn list(&self) -> _p::Accessor<'_, 'p, T, _p::List<_p::AnyPtr>> {
        unsafe {
            <_p::List<
                _p::AnyPtr,
            > as _p::field::FieldType>::accessor(&self.0, &TestContainMembrane::LIST)
        }
    }
}
impl<'p, T: _p::rpc::Table + 'p> test_contain_membrane::Builder<'p, T> {
    #[inline]
    pub fn cap(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::AnyPtr> {
        unsafe {
            <_p::AnyPtr as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestContainMembrane::CAP,
            )
        }
    }
    #[inline]
    pub fn list(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::List<_p::AnyPtr>> {
        unsafe {
            <_p::List<
                _p::AnyPtr,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestContainMembrane::LIST)
        }
    }
    #[inline]
    pub fn into_cap(self) -> _p::AccessorOwned<'p, T, _p::AnyPtr> {
        unsafe {
            <_p::AnyPtr as _p::field::FieldType>::accessor(
                self.0,
                &TestContainMembrane::CAP,
            )
        }
    }
    #[inline]
    pub fn into_list(self) -> _p::AccessorOwned<'p, T, _p::List<_p::AnyPtr>> {
        unsafe {
            <_p::List<
                _p::AnyPtr,
            > as _p::field::FieldType>::accessor(self.0, &TestContainMembrane::LIST)
        }
    }
}
pub mod test_contain_membrane {
    use super::{__file, __imports, _p};
    pub type Reader<'a, T = _p::rpc::Empty> = super::TestContainMembrane<
        _p::StructReader<'a, T>,
    >;
    pub type Builder<'a, T = _p::rpc::Empty> = super::TestContainMembrane<
        _p::StructBuilder<'a, T>,
    >;
}
#[derive(Clone)]
pub struct TestTransferCap<T = _p::Family>(T);
impl _p::ty::SchemaType for TestTransferCap {
    const ID: u64 = 15936944576269548016u64;
}
impl<T> _p::IntoFamily for TestTransferCap<T> {
    type Family = TestTransferCap;
}
impl<T: _p::Capable> _p::Capable for TestTransferCap<T> {
    type Table = T::Table;
    type Imbued = T::Imbued;
    type ImbuedWith<T2: _p::rpc::Table> = TestTransferCap<T::ImbuedWith<T2>>;
    #[inline]
    fn imbued(&self) -> &Self::Imbued {
        self.0.imbued()
    }
    #[inline]
    fn imbue_release<T2: _p::rpc::Table>(
        self,
        new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
    ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
        let (imbued, old) = self.0.imbue_release(new_table);
        (TestTransferCap(imbued), old)
    }
    #[inline]
    fn imbue_release_into<U>(&self, other: U) -> (U::ImbuedWith<Self::Table>, U::Imbued)
    where
        U: _p::Capable,
        U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
    {
        self.0.imbue_release_into(other)
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_transfer_cap::Reader<'a, T> {
    type Ptr = _p::StructReader<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
for test_transfer_cap::Reader<'a, T> {
    #[inline]
    fn from(ptr: _p::StructReader<'a, T>) -> Self {
        TestTransferCap(ptr)
    }
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_transfer_cap::Reader<'a, T>>
for _p::StructReader<'a, T> {
    #[inline]
    fn from(reader: test_transfer_cap::Reader<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
for test_transfer_cap::Reader<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructReader<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructReader for test_transfer_cap::Reader<'a, T> {}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_transfer_cap::Builder<'a, T> {
    type Ptr = _p::StructBuilder<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_transfer_cap::Builder<'a, T>>
for _p::StructBuilder<'a, T> {
    #[inline]
    fn from(reader: test_transfer_cap::Builder<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
for test_transfer_cap::Builder<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
for test_transfer_cap::Builder<'a, T> {
    #[inline]
    fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
        &mut self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for test_transfer_cap::Builder<'a, T> {
    unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
        Self(ptr)
    }
}
impl _p::StructView for TestTransferCap {
    type Reader<'a, T: _p::rpc::Table> = test_transfer_cap::Reader<'a, T>;
    type Builder<'a, T: _p::rpc::Table> = test_transfer_cap::Builder<'a, T>;
}
impl _p::ty::Struct for TestTransferCap {
    const SIZE: _p::StructSize = _p::StructSize {
        data: 0u16,
        ptrs: 1u16,
    };
}
impl TestTransferCap {
    const LIST: _p::Descriptor<_p::List<_p::Struct<test_transfer_cap::Element>>> = _p::Descriptor::<
        _p::List<_p::Struct<test_transfer_cap::Element>>,
    > {
        slot: 0u32,
        default: ::core::option::Option::None,
    };
}
impl<'p, T: _p::rpc::Table + 'p> test_transfer_cap::Reader<'p, T> {
    #[inline]
    pub fn list(
        &self,
    ) -> _p::Accessor<'_, 'p, T, _p::List<_p::Struct<test_transfer_cap::Element>>> {
        unsafe {
            <_p::List<
                _p::Struct<test_transfer_cap::Element>,
            > as _p::field::FieldType>::accessor(&self.0, &TestTransferCap::LIST)
        }
    }
}
impl<'p, T: _p::rpc::Table + 'p> test_transfer_cap::Builder<'p, T> {
    #[inline]
    pub fn list(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::List<_p::Struct<test_transfer_cap::Element>>> {
        unsafe {
            <_p::List<
                _p::Struct<test_transfer_cap::Element>,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestTransferCap::LIST)
        }
    }
    #[inline]
    pub fn into_list(
        self,
    ) -> _p::AccessorOwned<'p, T, _p::List<_p::Struct<test_transfer_cap::Element>>> {
        unsafe {
            <_p::List<
                _p::Struct<test_transfer_cap::Element>,
            > as _p::field::FieldType>::accessor(self.0, &TestTransferCap::LIST)
        }
    }
}
pub mod test_transfer_cap {
    use super::{__file, __imports, _p};
    pub type Reader<'a, T = _p::rpc::Empty> = super::TestTransferCap<
        _p::StructReader<'a, T>,
    >;
    pub type Builder<'a, T = _p::rpc::Empty> = super::TestTransferCap<
        _p::StructBuilder<'a, T>,
    >;
    #[derive(Clone)]
    pub struct Element<T = _p::Family>(T);
    impl _p::ty::SchemaType for Element {
        const ID: u64 = 14350226048854280892u64;
    }
    impl<T> _p::IntoFamily for Element<T> {
        type Family = Element;
    }
    impl<T: _p::Capable> _p::Capable for Element<T> {
        type Table = T::Table;
        type Imbued = T::Imbued;
        type ImbuedWith<T2: _p::rpc::Table> = Element<T::ImbuedWith<T2>>;
        #[inline]
        fn imbued(&self) -> &Self::Imbued {
            self.0.imbued()
        }
        #[inline]
        fn imbue_release<T2: _p::rpc::Table>(
            self,
            new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
        ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
            let (imbued, old) = self.0.imbue_release(new_table);
            (Element(imbued), old)
        }
        #[inline]
        fn imbue_release_into<U>(
            &self,
            other: U,
        ) -> (U::ImbuedWith<Self::Table>, U::Imbued)
        where
            U: _p::Capable,
            U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
        {
            self.0.imbue_release_into(other)
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for element::Reader<'a, T> {
        type Ptr = _p::StructReader<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
    for element::Reader<'a, T> {
        #[inline]
        fn from(ptr: _p::StructReader<'a, T>) -> Self {
            Element(ptr)
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<element::Reader<'a, T>>
    for _p::StructReader<'a, T> {
        #[inline]
        fn from(reader: element::Reader<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
    for element::Reader<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructReader<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructReader for element::Reader<'a, T> {}
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for element::Builder<'a, T> {
        type Ptr = _p::StructBuilder<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<element::Builder<'a, T>>
    for _p::StructBuilder<'a, T> {
        #[inline]
        fn from(reader: element::Builder<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
    for element::Builder<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
    for element::Builder<'a, T> {
        #[inline]
        fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
            &mut self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for element::Builder<'a, T> {
        unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
            Self(ptr)
        }
    }
    impl _p::StructView for Element {
        type Reader<'a, T: _p::rpc::Table> = element::Reader<'a, T>;
        type Builder<'a, T: _p::rpc::Table> = element::Builder<'a, T>;
    }
    impl _p::ty::Struct for Element {
        const SIZE: _p::StructSize = _p::StructSize {
            data: 0u16,
            ptrs: 2u16,
        };
    }
    impl Element {
        const TEXT: _p::Descriptor<_p::Text> = _p::Descriptor::<_p::Text> {
            slot: 0u32,
            default: ::core::option::Option::None,
        };
        const CAP: _p::Descriptor<_p::AnyPtr> = _p::Descriptor::<_p::AnyPtr> {
            slot: 1u32,
            default: ::core::option::Option::None,
        };
    }
    impl<'p, T: _p::rpc::Table + 'p> element::Reader<'p, T> {
        #[inline]
        pub fn text(&self) -> _p::Accessor<'_, 'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::accessor(&self.0, &Element::TEXT)
            }
        }
        #[inline]
        pub fn cap(&self) -> _p::Accessor<'_, 'p, T, _p::AnyPtr> {
            unsafe {
                <_p::AnyPtr as _p::field::FieldType>::accessor(&self.0, &Element::CAP)
            }
        }
    }
    impl<'p, T: _p::rpc::Table + 'p> element::Builder<'p, T> {
        #[inline]
        pub fn text(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::accessor(&mut self.0, &Element::TEXT)
            }
        }
        #[inline]
        pub fn cap(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::AnyPtr> {
            unsafe {
                <_p::AnyPtr as _p::field::FieldType>::accessor(
                    &mut self.0,
                    &Element::CAP,
                )
            }
        }
        #[inline]
        pub fn into_text(self) -> _p::AccessorOwned<'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::accessor(self.0, &Element::TEXT)
            }
        }
        #[inline]
        pub fn into_cap(self) -> _p::AccessorOwned<'p, T, _p::AnyPtr> {
            unsafe {
                <_p::AnyPtr as _p::field::FieldType>::accessor(self.0, &Element::CAP)
            }
        }
    }
    pub mod element {
        use super::{__file, __imports, _p};
        pub type Reader<'a, T = _p::rpc::Empty> = super::Element<
            _p::StructReader<'a, T>,
        >;
        pub type Builder<'a, T = _p::rpc::Empty> = super::Element<
            _p::StructBuilder<'a, T>,
        >;
    }
}
#[derive(Clone)]
pub struct TestSturdyRef<T = _p::Family>(T);
impl _p::ty::SchemaType for TestSturdyRef {
    const ID: u64 = 14896386035283523266u64;
}
impl<T> _p::IntoFamily for TestSturdyRef<T> {
    type Family = TestSturdyRef;
}
impl<T: _p::Capable> _p::Capable for TestSturdyRef<T> {
    type Table = T::Table;
    type Imbued = T::Imbued;
    type ImbuedWith<T2: _p::rpc::Table> = TestSturdyRef<T::ImbuedWith<T2>>;
    #[inline]
    fn imbued(&self) -> &Self::Imbued {
        self.0.imbued()
    }
    #[inline]
    fn imbue_release<T2: _p::rpc::Table>(
        self,
        new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
    ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
        let (imbued, old) = self.0.imbue_release(new_table);
        (TestSturdyRef(imbued), old)
    }
    #[inline]
    fn imbue_release_into<U>(&self, other: U) -> (U::ImbuedWith<Self::Table>, U::Imbued)
    where
        U: _p::Capable,
        U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
    {
        self.0.imbue_release_into(other)
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_sturdy_ref::Reader<'a, T> {
    type Ptr = _p::StructReader<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
for test_sturdy_ref::Reader<'a, T> {
    #[inline]
    fn from(ptr: _p::StructReader<'a, T>) -> Self {
        TestSturdyRef(ptr)
    }
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_sturdy_ref::Reader<'a, T>>
for _p::StructReader<'a, T> {
    #[inline]
    fn from(reader: test_sturdy_ref::Reader<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
for test_sturdy_ref::Reader<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructReader<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructReader for test_sturdy_ref::Reader<'a, T> {}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_sturdy_ref::Builder<'a, T> {
    type Ptr = _p::StructBuilder<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_sturdy_ref::Builder<'a, T>>
for _p::StructBuilder<'a, T> {
    #[inline]
    fn from(reader: test_sturdy_ref::Builder<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
for test_sturdy_ref::Builder<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
for test_sturdy_ref::Builder<'a, T> {
    #[inline]
    fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
        &mut self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for test_sturdy_ref::Builder<'a, T> {
    unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
        Self(ptr)
    }
}
impl _p::StructView for TestSturdyRef {
    type Reader<'a, T: _p::rpc::Table> = test_sturdy_ref::Reader<'a, T>;
    type Builder<'a, T: _p::rpc::Table> = test_sturdy_ref::Builder<'a, T>;
}
impl _p::ty::Struct for TestSturdyRef {
    const SIZE: _p::StructSize = _p::StructSize {
        data: 0u16,
        ptrs: 2u16,
    };
}
impl TestSturdyRef {
    const HOST_ID: _p::Descriptor<_p::Struct<TestSturdyRefHostId>> = _p::Descriptor::<
        _p::Struct<TestSturdyRefHostId>,
    > {
        slot: 0u32,
        default: ::core::option::Option::None,
    };
    const OBJECT_ID: _p::Descriptor<_p::AnyPtr> = _p::Descriptor::<_p::AnyPtr> {
        slot: 1u32,
        default: ::core::option::Option::None,
    };
}
impl<'p, T: _p::rpc::Table + 'p> test_sturdy_ref::Reader<'p, T> {
    #[inline]
    pub fn host_id(&self) -> _p::Accessor<'_, 'p, T, _p::Struct<TestSturdyRefHostId>> {
        unsafe {
            <_p::Struct<
                TestSturdyRefHostId,
            > as _p::field::FieldType>::accessor(&self.0, &TestSturdyRef::HOST_ID)
        }
    }
    #[inline]
    pub fn object_id(&self) -> _p::Accessor<'_, 'p, T, _p::AnyPtr> {
        unsafe {
            <_p::AnyPtr as _p::field::FieldType>::accessor(
                &self.0,
                &TestSturdyRef::OBJECT_ID,
            )
        }
    }
}
impl<'p, T: _p::rpc::Table + 'p> test_sturdy_ref::Builder<'p, T> {
    #[inline]
    pub fn host_id(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::Struct<TestSturdyRefHostId>> {
        unsafe {
            <_p::Struct<
                TestSturdyRefHostId,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestSturdyRef::HOST_ID)
        }
    }
    #[inline]
    pub fn object_id(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::AnyPtr> {
        unsafe {
            <_p::AnyPtr as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestSturdyRef::OBJECT_ID,
            )
        }
    }
    #[inline]
    pub fn into_host_id(
        self,
    ) -> _p::AccessorOwned<'p, T, _p::Struct<TestSturdyRefHostId>> {
        unsafe {
            <_p::Struct<
                TestSturdyRefHostId,
            > as _p::field::FieldType>::accessor(self.0, &TestSturdyRef::HOST_ID)
        }
    }
    #[inline]
    pub fn into_object_id(self) -> _p::AccessorOwned<'p, T, _p::AnyPtr> {
        unsafe {
            <_p::AnyPtr as _p::field::FieldType>::accessor(
                self.0,
                &TestSturdyRef::OBJECT_ID,
            )
        }
    }
}
pub mod test_sturdy_ref {
    use super::{__file, __imports, _p};
    pub type Reader<'a, T = _p::rpc::Empty> = super::TestSturdyRef<
        _p::StructReader<'a, T>,
    >;
    pub type Builder<'a, T = _p::rpc::Empty> = super::TestSturdyRef<
        _p::StructBuilder<'a, T>,
    >;
}
#[derive(Clone)]
pub struct TestSturdyRefHostId<T = _p::Family>(T);
impl _p::ty::SchemaType for TestSturdyRefHostId {
    const ID: u64 = 16153633125947204418u64;
}
impl<T> _p::IntoFamily for TestSturdyRefHostId<T> {
    type Family = TestSturdyRefHostId;
}
impl<T: _p::Capable> _p::Capable for TestSturdyRefHostId<T> {
    type Table = T::Table;
    type Imbued = T::Imbued;
    type ImbuedWith<T2: _p::rpc::Table> = TestSturdyRefHostId<T::ImbuedWith<T2>>;
    #[inline]
    fn imbued(&self) -> &Self::Imbued {
        self.0.imbued()
    }
    #[inline]
    fn imbue_release<T2: _p::rpc::Table>(
        self,
        new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
    ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
        let (imbued, old) = self.0.imbue_release(new_table);
        (TestSturdyRefHostId(imbued), old)
    }
    #[inline]
    fn imbue_release_into<U>(&self, other: U) -> (U::ImbuedWith<Self::Table>, U::Imbued)
    where
        U: _p::Capable,
        U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
    {
        self.0.imbue_release_into(other)
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_sturdy_ref_host_id::Reader<'a, T> {
    type Ptr = _p::StructReader<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
for test_sturdy_ref_host_id::Reader<'a, T> {
    #[inline]
    fn from(ptr: _p::StructReader<'a, T>) -> Self {
        TestSturdyRefHostId(ptr)
    }
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_sturdy_ref_host_id::Reader<'a, T>>
for _p::StructReader<'a, T> {
    #[inline]
    fn from(reader: test_sturdy_ref_host_id::Reader<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
for test_sturdy_ref_host_id::Reader<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructReader<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructReader
for test_sturdy_ref_host_id::Reader<'a, T> {}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr
for test_sturdy_ref_host_id::Builder<'a, T> {
    type Ptr = _p::StructBuilder<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_sturdy_ref_host_id::Builder<'a, T>>
for _p::StructBuilder<'a, T> {
    #[inline]
    fn from(reader: test_sturdy_ref_host_id::Builder<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
for test_sturdy_ref_host_id::Builder<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
for test_sturdy_ref_host_id::Builder<'a, T> {
    #[inline]
    fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
        &mut self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder
for test_sturdy_ref_host_id::Builder<'a, T> {
    unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
        Self(ptr)
    }
}
impl _p::StructView for TestSturdyRefHostId {
    type Reader<'a, T: _p::rpc::Table> = test_sturdy_ref_host_id::Reader<'a, T>;
    type Builder<'a, T: _p::rpc::Table> = test_sturdy_ref_host_id::Builder<'a, T>;
}
impl _p::ty::Struct for TestSturdyRefHostId {
    const SIZE: _p::StructSize = _p::StructSize {
        data: 0u16,
        ptrs: 1u16,
    };
}
impl TestSturdyRefHostId {
    const HOST: _p::Descriptor<_p::Text> = _p::Descriptor::<_p::Text> {
        slot: 0u32,
        default: ::core::option::Option::None,
    };
}
impl<'p, T: _p::rpc::Table + 'p> test_sturdy_ref_host_id::Reader<'p, T> {
    #[inline]
    pub fn host(&self) -> _p::Accessor<'_, 'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(
                &self.0,
                &TestSturdyRefHostId::HOST,
            )
        }
    }
}
impl<'p, T: _p::rpc::Table + 'p> test_sturdy_ref_host_id::Builder<'p, T> {
    #[inline]
    pub fn host(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestSturdyRefHostId::HOST,
            )
        }
    }
    #[inline]
    pub fn into_host(self) -> _p::AccessorOwned<'p, T, _p::Text> {
        unsafe {
            <_p::Text as _p::field::FieldType>::accessor(
                self.0,
                &TestSturdyRefHostId::HOST,
            )
        }
    }
}
pub mod test_sturdy_ref_host_id {
    use super::{__file, __imports, _p};
    pub type Reader<'a, T = _p::rpc::Empty> = super::TestSturdyRefHostId<
        _p::StructReader<'a, T>,
    >;
    pub type Builder<'a, T = _p::rpc::Empty> = super::TestSturdyRefHostId<
        _p::StructBuilder<'a, T>,
    >;
}
#[derive(Clone)]
pub struct TestSturdyRefObjectId<T = _p::Family>(T);
impl _p::ty::SchemaType for TestSturdyRefObjectId {
    const ID: u64 = 12588314220840310423u64;
}
impl<T> _p::IntoFamily for TestSturdyRefObjectId<T> {
    type Family = TestSturdyRefObjectId;
}
impl<T: _p::Capable> _p::Capable for TestSturdyRefObjectId<T> {
    type Table = T::Table;
    type Imbued = T::Imbued;
    type ImbuedWith<T2: _p::rpc::Table> = TestSturdyRefObjectId<T::ImbuedWith<T2>>;
    #[inline]
    fn imbued(&self) -> &Self::Imbued {
        self.0.imbued()
    }
    #[inline]
    fn imbue_release<T2: _p::rpc::Table>(
        self,
        new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
    ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
        let (imbued, old) = self.0.imbue_release(new_table);
        (TestSturdyRefObjectId(imbued), old)
    }
    #[inline]
    fn imbue_release_into<U>(&self, other: U) -> (U::ImbuedWith<Self::Table>, U::Imbued)
    where
        U: _p::Capable,
        U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
    {
        self.0.imbue_release_into(other)
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr
for test_sturdy_ref_object_id::Reader<'a, T> {
    type Ptr = _p::StructReader<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
for test_sturdy_ref_object_id::Reader<'a, T> {
    #[inline]
    fn from(ptr: _p::StructReader<'a, T>) -> Self {
        TestSturdyRefObjectId(ptr)
    }
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_sturdy_ref_object_id::Reader<'a, T>>
for _p::StructReader<'a, T> {
    #[inline]
    fn from(reader: test_sturdy_ref_object_id::Reader<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
for test_sturdy_ref_object_id::Reader<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructReader<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructReader
for test_sturdy_ref_object_id::Reader<'a, T> {}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr
for test_sturdy_ref_object_id::Builder<'a, T> {
    type Ptr = _p::StructBuilder<'a, T>;
}
impl<
    'a,
    T: _p::rpc::Table,
> core::convert::From<test_sturdy_ref_object_id::Builder<'a, T>>
for _p::StructBuilder<'a, T> {
    #[inline]
    fn from(reader: test_sturdy_ref_object_id::Builder<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
for test_sturdy_ref_object_id::Builder<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
for test_sturdy_ref_object_id::Builder<'a, T> {
    #[inline]
    fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
        &mut self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder
for test_sturdy_ref_object_id::Builder<'a, T> {
    unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
        Self(ptr)
    }
}
impl _p::StructView for TestSturdyRefObjectId {
    type Reader<'a, T: _p::rpc::Table> = test_sturdy_ref_object_id::Reader<'a, T>;
    type Builder<'a, T: _p::rpc::Table> = test_sturdy_ref_object_id::Builder<'a, T>;
}
impl _p::ty::Struct for TestSturdyRefObjectId {
    const SIZE: _p::StructSize = _p::StructSize {
        data: 1u16,
        ptrs: 0u16,
    };
}
impl TestSturdyRefObjectId {
    const TAG: _p::Descriptor<_p::Enum<test_sturdy_ref_object_id::Tag>> = _p::Descriptor::<
        _p::Enum<test_sturdy_ref_object_id::Tag>,
    > {
        slot: 0u32,
        default: test_sturdy_ref_object_id::Tag::TestInterface,
    };
}
impl<'p, T: _p::rpc::Table + 'p> test_sturdy_ref_object_id::Reader<'p, T> {
    #[inline]
    pub fn tag(
        &self,
    ) -> _p::Accessor<'_, 'p, T, _p::Enum<test_sturdy_ref_object_id::Tag>> {
        unsafe {
            <_p::Enum<
                test_sturdy_ref_object_id::Tag,
            > as _p::field::FieldType>::accessor(&self.0, &TestSturdyRefObjectId::TAG)
        }
    }
}
impl<'p, T: _p::rpc::Table + 'p> test_sturdy_ref_object_id::Builder<'p, T> {
    #[inline]
    pub fn tag(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::Enum<test_sturdy_ref_object_id::Tag>> {
        unsafe {
            <_p::Enum<
                test_sturdy_ref_object_id::Tag,
            > as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestSturdyRefObjectId::TAG,
            )
        }
    }
}
pub mod test_sturdy_ref_object_id {
    use super::{__file, __imports, _p};
    pub type Reader<'a, T = _p::rpc::Empty> = super::TestSturdyRefObjectId<
        _p::StructReader<'a, T>,
    >;
    pub type Builder<'a, T = _p::rpc::Empty> = super::TestSturdyRefObjectId<
        _p::StructBuilder<'a, T>,
    >;
    #[repr(u16)]
    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Default)]
    pub enum Tag {
        #[default]
        TestInterface,
        TestExtends,
        TestPipeline,
        TestTailCallee,
        TestTailCaller,
        TestMoreStuff,
    }
    impl _p::ty::SchemaType for Tag {
        const ID: u64 = 17240499757294867513u64;
    }
    impl core::convert::TryFrom<u16> for Tag {
        type Error = _p::NotInSchema;
        #[inline]
        fn try_from(value: u16) -> Result<Self, _p::NotInSchema> {
            match value {
                0u16 => Ok(Self::TestInterface),
                1u16 => Ok(Self::TestExtends),
                2u16 => Ok(Self::TestPipeline),
                3u16 => Ok(Self::TestTailCallee),
                4u16 => Ok(Self::TestTailCaller),
                5u16 => Ok(Self::TestMoreStuff),
                value => Err(_p::NotInSchema(value)),
            }
        }
    }
    impl core::convert::From<Tag> for u16 {
        #[inline]
        fn from(value: Tag) -> Self {
            value as u16
        }
    }
    impl _p::ty::Enum for Tag {}
}
#[derive(Clone)]
pub struct TestProvisionId<T = _p::Family>(T);
impl _p::ty::SchemaType for TestProvisionId {
    const ID: u64 = 11411091520228545634u64;
}
impl<T> _p::IntoFamily for TestProvisionId<T> {
    type Family = TestProvisionId;
}
impl<T: _p::Capable> _p::Capable for TestProvisionId<T> {
    type Table = T::Table;
    type Imbued = T::Imbued;
    type ImbuedWith<T2: _p::rpc::Table> = TestProvisionId<T::ImbuedWith<T2>>;
    #[inline]
    fn imbued(&self) -> &Self::Imbued {
        self.0.imbued()
    }
    #[inline]
    fn imbue_release<T2: _p::rpc::Table>(
        self,
        new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
    ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
        let (imbued, old) = self.0.imbue_release(new_table);
        (TestProvisionId(imbued), old)
    }
    #[inline]
    fn imbue_release_into<U>(&self, other: U) -> (U::ImbuedWith<Self::Table>, U::Imbued)
    where
        U: _p::Capable,
        U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
    {
        self.0.imbue_release_into(other)
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_provision_id::Reader<'a, T> {
    type Ptr = _p::StructReader<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
for test_provision_id::Reader<'a, T> {
    #[inline]
    fn from(ptr: _p::StructReader<'a, T>) -> Self {
        TestProvisionId(ptr)
    }
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_provision_id::Reader<'a, T>>
for _p::StructReader<'a, T> {
    #[inline]
    fn from(reader: test_provision_id::Reader<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
for test_provision_id::Reader<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructReader<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructReader for test_provision_id::Reader<'a, T> {}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_provision_id::Builder<'a, T> {
    type Ptr = _p::StructBuilder<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_provision_id::Builder<'a, T>>
for _p::StructBuilder<'a, T> {
    #[inline]
    fn from(reader: test_provision_id::Builder<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
for test_provision_id::Builder<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
for test_provision_id::Builder<'a, T> {
    #[inline]
    fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
        &mut self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for test_provision_id::Builder<'a, T> {
    unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
        Self(ptr)
    }
}
impl _p::StructView for TestProvisionId {
    type Reader<'a, T: _p::rpc::Table> = test_provision_id::Reader<'a, T>;
    type Builder<'a, T: _p::rpc::Table> = test_provision_id::Builder<'a, T>;
}
impl _p::ty::Struct for TestProvisionId {
    const SIZE: _p::StructSize = _p::StructSize {
        data: 0u16,
        ptrs: 0u16,
    };
}
impl TestProvisionId {}
impl<'p, T: _p::rpc::Table + 'p> test_provision_id::Reader<'p, T> {}
impl<'p, T: _p::rpc::Table + 'p> test_provision_id::Builder<'p, T> {}
pub mod test_provision_id {
    use super::{__file, __imports, _p};
    pub type Reader<'a, T = _p::rpc::Empty> = super::TestProvisionId<
        _p::StructReader<'a, T>,
    >;
    pub type Builder<'a, T = _p::rpc::Empty> = super::TestProvisionId<
        _p::StructBuilder<'a, T>,
    >;
}
#[derive(Clone)]
pub struct TestRecipientId<T = _p::Family>(T);
impl _p::ty::SchemaType for TestRecipientId {
    const ID: u64 = 16874908487150058986u64;
}
impl<T> _p::IntoFamily for TestRecipientId<T> {
    type Family = TestRecipientId;
}
impl<T: _p::Capable> _p::Capable for TestRecipientId<T> {
    type Table = T::Table;
    type Imbued = T::Imbued;
    type ImbuedWith<T2: _p::rpc::Table> = TestRecipientId<T::ImbuedWith<T2>>;
    #[inline]
    fn imbued(&self) -> &Self::Imbued {
        self.0.imbued()
    }
    #[inline]
    fn imbue_release<T2: _p::rpc::Table>(
        self,
        new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
    ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
        let (imbued, old) = self.0.imbue_release(new_table);
        (TestRecipientId(imbued), old)
    }
    #[inline]
    fn imbue_release_into<U>(&self, other: U) -> (U::ImbuedWith<Self::Table>, U::Imbued)
    where
        U: _p::Capable,
        U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
    {
        self.0.imbue_release_into(other)
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_recipient_id::Reader<'a, T> {
    type Ptr = _p::StructReader<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
for test_recipient_id::Reader<'a, T> {
    #[inline]
    fn from(ptr: _p::StructReader<'a, T>) -> Self {
        TestRecipientId(ptr)
    }
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_recipient_id::Reader<'a, T>>
for _p::StructReader<'a, T> {
    #[inline]
    fn from(reader: test_recipient_id::Reader<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
for test_recipient_id::Reader<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructReader<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructReader for test_recipient_id::Reader<'a, T> {}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_recipient_id::Builder<'a, T> {
    type Ptr = _p::StructBuilder<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_recipient_id::Builder<'a, T>>
for _p::StructBuilder<'a, T> {
    #[inline]
    fn from(reader: test_recipient_id::Builder<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
for test_recipient_id::Builder<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
for test_recipient_id::Builder<'a, T> {
    #[inline]
    fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
        &mut self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for test_recipient_id::Builder<'a, T> {
    unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
        Self(ptr)
    }
}
impl _p::StructView for TestRecipientId {
    type Reader<'a, T: _p::rpc::Table> = test_recipient_id::Reader<'a, T>;
    type Builder<'a, T: _p::rpc::Table> = test_recipient_id::Builder<'a, T>;
}
impl _p::ty::Struct for TestRecipientId {
    const SIZE: _p::StructSize = _p::StructSize {
        data: 0u16,
        ptrs: 0u16,
    };
}
impl TestRecipientId {}
impl<'p, T: _p::rpc::Table + 'p> test_recipient_id::Reader<'p, T> {}
impl<'p, T: _p::rpc::Table + 'p> test_recipient_id::Builder<'p, T> {}
pub mod test_recipient_id {
    use super::{__file, __imports, _p};
    pub type Reader<'a, T = _p::rpc::Empty> = super::TestRecipientId<
        _p::StructReader<'a, T>,
    >;
    pub type Builder<'a, T = _p::rpc::Empty> = super::TestRecipientId<
        _p::StructBuilder<'a, T>,
    >;
}
#[derive(Clone)]
pub struct TestThirdPartyCapId<T = _p::Family>(T);
impl _p::ty::SchemaType for TestThirdPartyCapId {
    const ID: u64 = 12107106793842693225u64;
}
impl<T> _p::IntoFamily for TestThirdPartyCapId<T> {
    type Family = TestThirdPartyCapId;
}
impl<T: _p::Capable> _p::Capable for TestThirdPartyCapId<T> {
    type Table = T::Table;
    type Imbued = T::Imbued;
    type ImbuedWith<T2: _p::rpc::Table> = TestThirdPartyCapId<T::ImbuedWith<T2>>;
    #[inline]
    fn imbued(&self) -> &Self::Imbued {
        self.0.imbued()
    }
    #[inline]
    fn imbue_release<T2: _p::rpc::Table>(
        self,
        new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
    ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
        let (imbued, old) = self.0.imbue_release(new_table);
        (TestThirdPartyCapId(imbued), old)
    }
    #[inline]
    fn imbue_release_into<U>(&self, other: U) -> (U::ImbuedWith<Self::Table>, U::Imbued)
    where
        U: _p::Capable,
        U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
    {
        self.0.imbue_release_into(other)
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_third_party_cap_id::Reader<'a, T> {
    type Ptr = _p::StructReader<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
for test_third_party_cap_id::Reader<'a, T> {
    #[inline]
    fn from(ptr: _p::StructReader<'a, T>) -> Self {
        TestThirdPartyCapId(ptr)
    }
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_third_party_cap_id::Reader<'a, T>>
for _p::StructReader<'a, T> {
    #[inline]
    fn from(reader: test_third_party_cap_id::Reader<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
for test_third_party_cap_id::Reader<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructReader<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructReader
for test_third_party_cap_id::Reader<'a, T> {}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr
for test_third_party_cap_id::Builder<'a, T> {
    type Ptr = _p::StructBuilder<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_third_party_cap_id::Builder<'a, T>>
for _p::StructBuilder<'a, T> {
    #[inline]
    fn from(reader: test_third_party_cap_id::Builder<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
for test_third_party_cap_id::Builder<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
for test_third_party_cap_id::Builder<'a, T> {
    #[inline]
    fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
        &mut self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder
for test_third_party_cap_id::Builder<'a, T> {
    unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
        Self(ptr)
    }
}
impl _p::StructView for TestThirdPartyCapId {
    type Reader<'a, T: _p::rpc::Table> = test_third_party_cap_id::Reader<'a, T>;
    type Builder<'a, T: _p::rpc::Table> = test_third_party_cap_id::Builder<'a, T>;
}
impl _p::ty::Struct for TestThirdPartyCapId {
    const SIZE: _p::StructSize = _p::StructSize {
        data: 0u16,
        ptrs: 0u16,
    };
}
impl TestThirdPartyCapId {}
impl<'p, T: _p::rpc::Table + 'p> test_third_party_cap_id::Reader<'p, T> {}
impl<'p, T: _p::rpc::Table + 'p> test_third_party_cap_id::Builder<'p, T> {}
pub mod test_third_party_cap_id {
    use super::{__file, __imports, _p};
    pub type Reader<'a, T = _p::rpc::Empty> = super::TestThirdPartyCapId<
        _p::StructReader<'a, T>,
    >;
    pub type Builder<'a, T = _p::rpc::Empty> = super::TestThirdPartyCapId<
        _p::StructBuilder<'a, T>,
    >;
}
#[derive(Clone)]
pub struct TestJoinResult<T = _p::Family>(T);
impl _p::ty::SchemaType for TestJoinResult {
    const ID: u64 = 17637655861324215808u64;
}
impl<T> _p::IntoFamily for TestJoinResult<T> {
    type Family = TestJoinResult;
}
impl<T: _p::Capable> _p::Capable for TestJoinResult<T> {
    type Table = T::Table;
    type Imbued = T::Imbued;
    type ImbuedWith<T2: _p::rpc::Table> = TestJoinResult<T::ImbuedWith<T2>>;
    #[inline]
    fn imbued(&self) -> &Self::Imbued {
        self.0.imbued()
    }
    #[inline]
    fn imbue_release<T2: _p::rpc::Table>(
        self,
        new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
    ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
        let (imbued, old) = self.0.imbue_release(new_table);
        (TestJoinResult(imbued), old)
    }
    #[inline]
    fn imbue_release_into<U>(&self, other: U) -> (U::ImbuedWith<Self::Table>, U::Imbued)
    where
        U: _p::Capable,
        U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
    {
        self.0.imbue_release_into(other)
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_join_result::Reader<'a, T> {
    type Ptr = _p::StructReader<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
for test_join_result::Reader<'a, T> {
    #[inline]
    fn from(ptr: _p::StructReader<'a, T>) -> Self {
        TestJoinResult(ptr)
    }
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_join_result::Reader<'a, T>>
for _p::StructReader<'a, T> {
    #[inline]
    fn from(reader: test_join_result::Reader<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
for test_join_result::Reader<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructReader<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructReader for test_join_result::Reader<'a, T> {}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_join_result::Builder<'a, T> {
    type Ptr = _p::StructBuilder<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_join_result::Builder<'a, T>>
for _p::StructBuilder<'a, T> {
    #[inline]
    fn from(reader: test_join_result::Builder<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
for test_join_result::Builder<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
for test_join_result::Builder<'a, T> {
    #[inline]
    fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
        &mut self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for test_join_result::Builder<'a, T> {
    unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
        Self(ptr)
    }
}
impl _p::StructView for TestJoinResult {
    type Reader<'a, T: _p::rpc::Table> = test_join_result::Reader<'a, T>;
    type Builder<'a, T: _p::rpc::Table> = test_join_result::Builder<'a, T>;
}
impl _p::ty::Struct for TestJoinResult {
    const SIZE: _p::StructSize = _p::StructSize {
        data: 0u16,
        ptrs: 0u16,
    };
}
impl TestJoinResult {}
impl<'p, T: _p::rpc::Table + 'p> test_join_result::Reader<'p, T> {}
impl<'p, T: _p::rpc::Table + 'p> test_join_result::Builder<'p, T> {}
pub mod test_join_result {
    use super::{__file, __imports, _p};
    pub type Reader<'a, T = _p::rpc::Empty> = super::TestJoinResult<
        _p::StructReader<'a, T>,
    >;
    pub type Builder<'a, T = _p::rpc::Empty> = super::TestJoinResult<
        _p::StructBuilder<'a, T>,
    >;
}
#[derive(Clone)]
pub struct TestNameAnnotation<T = _p::Family>(T);
impl _p::ty::SchemaType for TestNameAnnotation {
    const ID: u64 = 15131407126639566168u64;
}
impl<T> _p::IntoFamily for TestNameAnnotation<T> {
    type Family = TestNameAnnotation;
}
impl<T: _p::Capable> _p::Capable for TestNameAnnotation<T> {
    type Table = T::Table;
    type Imbued = T::Imbued;
    type ImbuedWith<T2: _p::rpc::Table> = TestNameAnnotation<T::ImbuedWith<T2>>;
    #[inline]
    fn imbued(&self) -> &Self::Imbued {
        self.0.imbued()
    }
    #[inline]
    fn imbue_release<T2: _p::rpc::Table>(
        self,
        new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
    ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
        let (imbued, old) = self.0.imbue_release(new_table);
        (TestNameAnnotation(imbued), old)
    }
    #[inline]
    fn imbue_release_into<U>(&self, other: U) -> (U::ImbuedWith<Self::Table>, U::Imbued)
    where
        U: _p::Capable,
        U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
    {
        self.0.imbue_release_into(other)
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_name_annotation::Reader<'a, T> {
    type Ptr = _p::StructReader<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
for test_name_annotation::Reader<'a, T> {
    #[inline]
    fn from(ptr: _p::StructReader<'a, T>) -> Self {
        TestNameAnnotation(ptr)
    }
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_name_annotation::Reader<'a, T>>
for _p::StructReader<'a, T> {
    #[inline]
    fn from(reader: test_name_annotation::Reader<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
for test_name_annotation::Reader<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructReader<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructReader
for test_name_annotation::Reader<'a, T> {}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_name_annotation::Builder<'a, T> {
    type Ptr = _p::StructBuilder<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_name_annotation::Builder<'a, T>>
for _p::StructBuilder<'a, T> {
    #[inline]
    fn from(reader: test_name_annotation::Builder<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
for test_name_annotation::Builder<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
for test_name_annotation::Builder<'a, T> {
    #[inline]
    fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
        &mut self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder
for test_name_annotation::Builder<'a, T> {
    unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
        Self(ptr)
    }
}
impl _p::StructView for TestNameAnnotation {
    type Reader<'a, T: _p::rpc::Table> = test_name_annotation::Reader<'a, T>;
    type Builder<'a, T: _p::rpc::Table> = test_name_annotation::Builder<'a, T>;
}
impl _p::ty::Struct for TestNameAnnotation {
    const SIZE: _p::StructSize = _p::StructSize {
        data: 1u16,
        ptrs: 1u16,
    };
}
impl TestNameAnnotation {
    const ANOTHER_BAD_FIELD_NAME: _p::Descriptor<
        _p::Enum<test_name_annotation::BadlyNamedEnum>,
    > = _p::Descriptor::<_p::Enum<test_name_annotation::BadlyNamedEnum>> {
        slot: 2u32,
        default: test_name_annotation::BadlyNamedEnum::Foo,
    };
    const BADLY_NAMED_UNION: _p::Descriptor<
        _p::Group<test_name_annotation::BadlyNamedUnion>,
    > = ();
    const BAD_FIELD_NAME: _p::VariantDescriptor<bool> = _p::VariantDescriptor::<bool> {
        variant: _p::VariantInfo {
            slot: 1u32,
            case: 0u16,
        },
        field: _p::Descriptor::<bool> {
            slot: 0u32,
            default: false,
        },
    };
    const BAR: _p::VariantDescriptor<i8> = _p::VariantDescriptor::<i8> {
        variant: _p::VariantInfo {
            slot: 1u32,
            case: 1u16,
        },
        field: _p::Descriptor::<i8> {
            slot: 0u32,
            default: 0i8,
        },
    };
}
impl<'p, T: _p::rpc::Table + 'p> test_name_annotation::Reader<'p, T> {
    #[inline]
    pub fn another_bad_field_name(
        &self,
    ) -> _p::Accessor<'_, 'p, T, _p::Enum<test_name_annotation::BadlyNamedEnum>> {
        unsafe {
            <_p::Enum<
                test_name_annotation::BadlyNamedEnum,
            > as _p::field::FieldType>::accessor(
                &self.0,
                &TestNameAnnotation::ANOTHER_BAD_FIELD_NAME,
            )
        }
    }
    #[inline]
    pub fn badly_named_union(
        &self,
    ) -> _p::Accessor<'_, 'p, T, _p::Group<test_name_annotation::BadlyNamedUnion>> {
        unsafe {
            <_p::Group<
                test_name_annotation::BadlyNamedUnion,
            > as _p::field::FieldType>::accessor(
                &self.0,
                &TestNameAnnotation::BADLY_NAMED_UNION,
            )
        }
    }
    #[inline]
    pub fn bad_field_name(&self) -> _p::Variant<'_, 'p, T, bool> {
        unsafe {
            <bool as _p::field::FieldType>::variant(
                &self.0,
                &TestNameAnnotation::BAD_FIELD_NAME,
            )
        }
    }
    #[inline]
    pub fn bar(&self) -> _p::Variant<'_, 'p, T, i8> {
        unsafe {
            <i8 as _p::field::FieldType>::variant(&self.0, &TestNameAnnotation::BAR)
        }
    }
    #[inline]
    pub fn which(&self) -> Result<test_name_annotation::Which<&Self>, _p::NotInSchema> {
        unsafe { <test_name_annotation::Which<_> as _p::UnionViewer<_>>::get(self) }
    }
}
impl<'p, T: _p::rpc::Table + 'p> test_name_annotation::Builder<'p, T> {
    #[inline]
    pub fn another_bad_field_name(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::Enum<test_name_annotation::BadlyNamedEnum>> {
        unsafe {
            <_p::Enum<
                test_name_annotation::BadlyNamedEnum,
            > as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestNameAnnotation::ANOTHER_BAD_FIELD_NAME,
            )
        }
    }
    #[inline]
    pub fn badly_named_union(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::Group<test_name_annotation::BadlyNamedUnion>> {
        unsafe {
            <_p::Group<
                test_name_annotation::BadlyNamedUnion,
            > as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestNameAnnotation::BADLY_NAMED_UNION,
            )
        }
    }
    #[inline]
    pub fn bad_field_name(&mut self) -> _p::VariantMut<'_, 'p, T, bool> {
        unsafe {
            <bool as _p::field::FieldType>::variant(
                &mut self.0,
                &TestNameAnnotation::BAD_FIELD_NAME,
            )
        }
    }
    #[inline]
    pub fn bar(&mut self) -> _p::VariantMut<'_, 'p, T, i8> {
        unsafe {
            <i8 as _p::field::FieldType>::variant(&mut self.0, &TestNameAnnotation::BAR)
        }
    }
    #[inline]
    pub fn into_badly_named_union(
        self,
    ) -> _p::AccessorOwned<'p, T, _p::Group<test_name_annotation::BadlyNamedUnion>> {
        unsafe {
            <_p::Group<
                test_name_annotation::BadlyNamedUnion,
            > as _p::field::FieldType>::accessor(
                self.0,
                &TestNameAnnotation::BADLY_NAMED_UNION,
            )
        }
    }
    #[inline]
    pub fn which(
        &mut self,
    ) -> Result<test_name_annotation::Which<&mut Self>, _p::NotInSchema> {
        unsafe { <test_name_annotation::Which<_> as _p::UnionViewer<_>>::get(self) }
    }
}
pub mod test_name_annotation {
    use super::{__file, __imports, _p};
    pub type Reader<'a, T = _p::rpc::Empty> = super::TestNameAnnotation<
        _p::StructReader<'a, T>,
    >;
    pub type Builder<'a, T = _p::rpc::Empty> = super::TestNameAnnotation<
        _p::StructBuilder<'a, T>,
    >;
    pub enum Which<T: _p::Viewable = _p::Family> {
        BadFieldName(_p::ViewOf<T, bool>),
        Bar(_p::ViewOf<T, i8>),
    }
    impl<'b, 'p: 'b, T: _p::Table + 'p> _p::UnionViewer<&'b Reader<'p, T>> for Which {
        type View = Which<&'b Reader<'p, T>>;
        unsafe fn get(repr: &'b Reader<'p, T>) -> Result<Self::View, _p::NotInSchema> {
            let tag = repr.0.data_field::<u16>(1usize);
            match tag {
                0u16 => {
                    Ok(
                        Which::BadFieldName(
                            <bool as _p::field::FieldType>::accessor(
                                &repr.0,
                                &super::TestNameAnnotation::BAD_FIELD_NAME.field,
                            ),
                        ),
                    )
                }
                1u16 => {
                    Ok(
                        Which::Bar(
                            <i8 as _p::field::FieldType>::accessor(
                                &repr.0,
                                &super::TestNameAnnotation::BAR.field,
                            ),
                        ),
                    )
                }
                unknown => Err(_p::NotInSchema(unknown)),
            }
        }
    }
    impl<'b, 'p: 'b, T: _p::Table + 'p> _p::UnionViewer<&'b mut Builder<'p, T>>
    for Which {
        type View = Which<&'b mut Builder<'p, T>>;
        unsafe fn get(
            repr: &'b mut Builder<'p, T>,
        ) -> Result<Self::View, _p::NotInSchema> {
            let tag = repr.0.data_field::<u16>(1usize);
            match tag {
                0u16 => {
                    Ok(
                        Which::BadFieldName(
                            <bool as _p::field::FieldType>::accessor(
                                &mut repr.0,
                                &super::TestNameAnnotation::BAD_FIELD_NAME.field,
                            ),
                        ),
                    )
                }
                1u16 => {
                    Ok(
                        Which::Bar(
                            <i8 as _p::field::FieldType>::accessor(
                                &mut repr.0,
                                &super::TestNameAnnotation::BAR.field,
                            ),
                        ),
                    )
                }
                unknown => Err(_p::NotInSchema(unknown)),
            }
        }
    }
    #[repr(u16)]
    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Default)]
    pub enum BadlyNamedEnum {
        #[default]
        Foo,
        Bar,
        Baz,
    }
    impl _p::ty::SchemaType for BadlyNamedEnum {
        const ID: u64 = 17730902487403718730u64;
    }
    impl core::convert::TryFrom<u16> for BadlyNamedEnum {
        type Error = _p::NotInSchema;
        #[inline]
        fn try_from(value: u16) -> Result<Self, _p::NotInSchema> {
            match value {
                0u16 => Ok(Self::Foo),
                1u16 => Ok(Self::Bar),
                2u16 => Ok(Self::Baz),
                value => Err(_p::NotInSchema(value)),
            }
        }
    }
    impl core::convert::From<BadlyNamedEnum> for u16 {
        #[inline]
        fn from(value: BadlyNamedEnum) -> Self {
            value as u16
        }
    }
    impl _p::ty::Enum for BadlyNamedEnum {}
    #[derive(Clone)]
    pub struct NestedStruct<T = _p::Family>(T);
    impl _p::ty::SchemaType for NestedStruct {
        const ID: u64 = 13709075339766211204u64;
    }
    impl<T> _p::IntoFamily for NestedStruct<T> {
        type Family = NestedStruct;
    }
    impl<T: _p::Capable> _p::Capable for NestedStruct<T> {
        type Table = T::Table;
        type Imbued = T::Imbued;
        type ImbuedWith<T2: _p::rpc::Table> = NestedStruct<T::ImbuedWith<T2>>;
        #[inline]
        fn imbued(&self) -> &Self::Imbued {
            self.0.imbued()
        }
        #[inline]
        fn imbue_release<T2: _p::rpc::Table>(
            self,
            new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
        ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
            let (imbued, old) = self.0.imbue_release(new_table);
            (NestedStruct(imbued), old)
        }
        #[inline]
        fn imbue_release_into<U>(
            &self,
            other: U,
        ) -> (U::ImbuedWith<Self::Table>, U::Imbued)
        where
            U: _p::Capable,
            U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
        {
            self.0.imbue_release_into(other)
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for nested_struct::Reader<'a, T> {
        type Ptr = _p::StructReader<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
    for nested_struct::Reader<'a, T> {
        #[inline]
        fn from(ptr: _p::StructReader<'a, T>) -> Self {
            NestedStruct(ptr)
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<nested_struct::Reader<'a, T>>
    for _p::StructReader<'a, T> {
        #[inline]
        fn from(reader: nested_struct::Reader<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
    for nested_struct::Reader<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructReader<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructReader for nested_struct::Reader<'a, T> {}
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for nested_struct::Builder<'a, T> {
        type Ptr = _p::StructBuilder<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<nested_struct::Builder<'a, T>>
    for _p::StructBuilder<'a, T> {
        #[inline]
        fn from(reader: nested_struct::Builder<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
    for nested_struct::Builder<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
    for nested_struct::Builder<'a, T> {
        #[inline]
        fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
            &mut self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for nested_struct::Builder<'a, T> {
        unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
            Self(ptr)
        }
    }
    impl _p::StructView for NestedStruct {
        type Reader<'a, T: _p::rpc::Table> = nested_struct::Reader<'a, T>;
        type Builder<'a, T: _p::rpc::Table> = nested_struct::Builder<'a, T>;
    }
    impl _p::ty::Struct for NestedStruct {
        const SIZE: _p::StructSize = _p::StructSize {
            data: 1u16,
            ptrs: 1u16,
        };
    }
    impl NestedStruct {
        const BAD_NESTED_FIELD_NAME: _p::Descriptor<bool> = _p::Descriptor::<bool> {
            slot: 0u32,
            default: false,
        };
        const ANOTHER_BAD_NESTED_FIELD_NAME: _p::Descriptor<_p::Struct<NestedStruct>> = _p::Descriptor::<
            _p::Struct<NestedStruct>,
        > {
            slot: 0u32,
            default: ::core::option::Option::None,
        };
    }
    impl<'p, T: _p::rpc::Table + 'p> nested_struct::Reader<'p, T> {
        #[inline]
        pub fn bad_nested_field_name(&self) -> _p::Accessor<'_, 'p, T, bool> {
            unsafe {
                <bool as _p::field::FieldType>::accessor(
                    &self.0,
                    &NestedStruct::BAD_NESTED_FIELD_NAME,
                )
            }
        }
        #[inline]
        pub fn another_bad_nested_field_name(
            &self,
        ) -> _p::Accessor<'_, 'p, T, _p::Struct<NestedStruct>> {
            unsafe {
                <_p::Struct<
                    NestedStruct,
                > as _p::field::FieldType>::accessor(
                    &self.0,
                    &NestedStruct::ANOTHER_BAD_NESTED_FIELD_NAME,
                )
            }
        }
    }
    impl<'p, T: _p::rpc::Table + 'p> nested_struct::Builder<'p, T> {
        #[inline]
        pub fn bad_nested_field_name(&mut self) -> _p::AccessorMut<'_, 'p, T, bool> {
            unsafe {
                <bool as _p::field::FieldType>::accessor(
                    &mut self.0,
                    &NestedStruct::BAD_NESTED_FIELD_NAME,
                )
            }
        }
        #[inline]
        pub fn another_bad_nested_field_name(
            &mut self,
        ) -> _p::AccessorMut<'_, 'p, T, _p::Struct<NestedStruct>> {
            unsafe {
                <_p::Struct<
                    NestedStruct,
                > as _p::field::FieldType>::accessor(
                    &mut self.0,
                    &NestedStruct::ANOTHER_BAD_NESTED_FIELD_NAME,
                )
            }
        }
        #[inline]
        pub fn into_another_bad_nested_field_name(
            self,
        ) -> _p::AccessorOwned<'p, T, _p::Struct<NestedStruct>> {
            unsafe {
                <_p::Struct<
                    NestedStruct,
                > as _p::field::FieldType>::accessor(
                    self.0,
                    &NestedStruct::ANOTHER_BAD_NESTED_FIELD_NAME,
                )
            }
        }
    }
    pub mod nested_struct {
        use super::{__file, __imports, _p};
        pub type Reader<'a, T = _p::rpc::Empty> = super::NestedStruct<
            _p::StructReader<'a, T>,
        >;
        pub type Builder<'a, T = _p::rpc::Empty> = super::NestedStruct<
            _p::StructBuilder<'a, T>,
        >;
        #[repr(u16)]
        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Default)]
        pub enum DeeplyNestedEnum {
            #[default]
            Quux,
            Corge,
            Grault,
        }
        impl _p::ty::SchemaType for DeeplyNestedEnum {
            const ID: u64 = 17783377494901203680u64;
        }
        impl core::convert::TryFrom<u16> for DeeplyNestedEnum {
            type Error = _p::NotInSchema;
            #[inline]
            fn try_from(value: u16) -> Result<Self, _p::NotInSchema> {
                match value {
                    0u16 => Ok(Self::Quux),
                    1u16 => Ok(Self::Corge),
                    2u16 => Ok(Self::Grault),
                    value => Err(_p::NotInSchema(value)),
                }
            }
        }
        impl core::convert::From<DeeplyNestedEnum> for u16 {
            #[inline]
            fn from(value: DeeplyNestedEnum) -> Self {
                value as u16
            }
        }
        impl _p::ty::Enum for DeeplyNestedEnum {}
    }
    #[derive(Clone)]
    pub struct BadlyNamedUnion<T = _p::Family>(T);
    impl _p::ty::SchemaType for BadlyNamedUnion {
        const ID: u64 = 9933200673777910140u64;
    }
    impl<T> _p::IntoFamily for BadlyNamedUnion<T> {
        type Family = BadlyNamedUnion;
    }
    impl<T: _p::Capable> _p::Capable for BadlyNamedUnion<T> {
        type Table = T::Table;
        type Imbued = T::Imbued;
        type ImbuedWith<T2: _p::rpc::Table> = BadlyNamedUnion<T::ImbuedWith<T2>>;
        #[inline]
        fn imbued(&self) -> &Self::Imbued {
            self.0.imbued()
        }
        #[inline]
        fn imbue_release<T2: _p::rpc::Table>(
            self,
            new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
        ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
            let (imbued, old) = self.0.imbue_release(new_table);
            (BadlyNamedUnion(imbued), old)
        }
        #[inline]
        fn imbue_release_into<U>(
            &self,
            other: U,
        ) -> (U::ImbuedWith<Self::Table>, U::Imbued)
        where
            U: _p::Capable,
            U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
        {
            self.0.imbue_release_into(other)
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for badly_named_union::Reader<'a, T> {
        type Ptr = _p::StructReader<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
    for badly_named_union::Reader<'a, T> {
        #[inline]
        fn from(ptr: _p::StructReader<'a, T>) -> Self {
            BadlyNamedUnion(ptr)
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<badly_named_union::Reader<'a, T>>
    for _p::StructReader<'a, T> {
        #[inline]
        fn from(reader: badly_named_union::Reader<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
    for badly_named_union::Reader<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructReader<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructReader
    for badly_named_union::Reader<'a, T> {}
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for badly_named_union::Builder<'a, T> {
        type Ptr = _p::StructBuilder<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<badly_named_union::Builder<'a, T>>
    for _p::StructBuilder<'a, T> {
        #[inline]
        fn from(reader: badly_named_union::Builder<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
    for badly_named_union::Builder<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
    for badly_named_union::Builder<'a, T> {
        #[inline]
        fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
            &mut self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder
    for badly_named_union::Builder<'a, T> {
        unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
            Self(ptr)
        }
    }
    impl _p::StructView for BadlyNamedUnion {
        type Reader<'a, T: _p::rpc::Table> = badly_named_union::Reader<'a, T>;
        type Builder<'a, T: _p::rpc::Table> = badly_named_union::Builder<'a, T>;
    }
    impl _p::FieldGroup for BadlyNamedUnion {
        unsafe fn clear<'a, 'b, T: _p::rpc::Table>(s: &'a mut _p::StructBuilder<'b, T>) {
            s.set_field_unchecked(3usize, 0);
            <_p::Group<
                badly_named_union::BadlyNamedGroup,
            > as _p::field::FieldType>::clear(
                s,
                &BadlyNamedUnion::BADLY_NAMED_GROUP.field,
            );
        }
    }
    impl BadlyNamedUnion {
        const BADLY_NAMED_GROUP: _p::VariantDescriptor<
            _p::Group<badly_named_union::BadlyNamedGroup>,
        > = _p::VariantDescriptor::<_p::Group<badly_named_union::BadlyNamedGroup>> {
            variant: _p::VariantInfo {
                slot: 3u32,
                case: 0u16,
            },
            field: (),
        };
        const BAZ: _p::VariantDescriptor<_p::Struct<NestedStruct>> = _p::VariantDescriptor::<
            _p::Struct<NestedStruct>,
        > {
            variant: _p::VariantInfo {
                slot: 3u32,
                case: 1u16,
            },
            field: _p::Descriptor::<_p::Struct<NestedStruct>> {
                slot: 0u32,
                default: ::core::option::Option::None,
            },
        };
    }
    impl<'p, T: _p::rpc::Table + 'p> badly_named_union::Reader<'p, T> {
        #[inline]
        pub fn badly_named_group(
            &self,
        ) -> _p::Variant<'_, 'p, T, _p::Group<badly_named_union::BadlyNamedGroup>> {
            unsafe {
                <_p::Group<
                    badly_named_union::BadlyNamedGroup,
                > as _p::field::FieldType>::variant(
                    &self.0,
                    &BadlyNamedUnion::BADLY_NAMED_GROUP,
                )
            }
        }
        #[inline]
        pub fn baz(&self) -> _p::Variant<'_, 'p, T, _p::Struct<NestedStruct>> {
            unsafe {
                <_p::Struct<
                    NestedStruct,
                > as _p::field::FieldType>::variant(&self.0, &BadlyNamedUnion::BAZ)
            }
        }
        #[inline]
        pub fn which(&self) -> Result<badly_named_union::Which<&Self>, _p::NotInSchema> {
            unsafe { <badly_named_union::Which<_> as _p::UnionViewer<_>>::get(self) }
        }
    }
    impl<'p, T: _p::rpc::Table + 'p> badly_named_union::Builder<'p, T> {
        #[inline]
        pub fn badly_named_group(
            &mut self,
        ) -> _p::VariantMut<'_, 'p, T, _p::Group<badly_named_union::BadlyNamedGroup>> {
            unsafe {
                <_p::Group<
                    badly_named_union::BadlyNamedGroup,
                > as _p::field::FieldType>::variant(
                    &mut self.0,
                    &BadlyNamedUnion::BADLY_NAMED_GROUP,
                )
            }
        }
        #[inline]
        pub fn baz(&mut self) -> _p::VariantMut<'_, 'p, T, _p::Struct<NestedStruct>> {
            unsafe {
                <_p::Struct<
                    NestedStruct,
                > as _p::field::FieldType>::variant(&mut self.0, &BadlyNamedUnion::BAZ)
            }
        }
        #[inline]
        pub fn into_badly_named_group(
            self,
        ) -> _p::VariantOwned<'p, T, _p::Group<badly_named_union::BadlyNamedGroup>> {
            unsafe {
                <_p::Group<
                    badly_named_union::BadlyNamedGroup,
                > as _p::field::FieldType>::variant(
                    self.0,
                    &BadlyNamedUnion::BADLY_NAMED_GROUP,
                )
            }
        }
        #[inline]
        pub fn into_baz(self) -> _p::VariantOwned<'p, T, _p::Struct<NestedStruct>> {
            unsafe {
                <_p::Struct<
                    NestedStruct,
                > as _p::field::FieldType>::variant(self.0, &BadlyNamedUnion::BAZ)
            }
        }
        #[inline]
        pub fn which(
            &mut self,
        ) -> Result<badly_named_union::Which<&mut Self>, _p::NotInSchema> {
            unsafe { <badly_named_union::Which<_> as _p::UnionViewer<_>>::get(self) }
        }
    }
    pub mod badly_named_union {
        use super::{__file, __imports, _p};
        pub type Reader<'a, T = _p::rpc::Empty> = super::BadlyNamedUnion<
            _p::StructReader<'a, T>,
        >;
        pub type Builder<'a, T = _p::rpc::Empty> = super::BadlyNamedUnion<
            _p::StructBuilder<'a, T>,
        >;
        pub enum Which<T: _p::Viewable = _p::Family> {
            BadlyNamedGroup(_p::ViewOf<T, _p::Group<BadlyNamedGroup>>),
            Baz(_p::ViewOf<T, _p::Struct<super::NestedStruct>>),
        }
        impl<'b, 'p: 'b, T: _p::Table + 'p> _p::UnionViewer<&'b Reader<'p, T>>
        for Which {
            type View = Which<&'b Reader<'p, T>>;
            unsafe fn get(
                repr: &'b Reader<'p, T>,
            ) -> Result<Self::View, _p::NotInSchema> {
                let tag = repr.0.data_field::<u16>(3usize);
                match tag {
                    0u16 => {
                        Ok(
                            Which::BadlyNamedGroup(
                                <_p::Group<
                                    BadlyNamedGroup,
                                > as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::BadlyNamedUnion::BADLY_NAMED_GROUP.field,
                                ),
                            ),
                        )
                    }
                    1u16 => {
                        Ok(
                            Which::Baz(
                                <_p::Struct<
                                    super::NestedStruct,
                                > as _p::field::FieldType>::accessor(
                                    &repr.0,
                                    &super::BadlyNamedUnion::BAZ.field,
                                ),
                            ),
                        )
                    }
                    unknown => Err(_p::NotInSchema(unknown)),
                }
            }
        }
        impl<'b, 'p: 'b, T: _p::Table + 'p> _p::UnionViewer<&'b mut Builder<'p, T>>
        for Which {
            type View = Which<&'b mut Builder<'p, T>>;
            unsafe fn get(
                repr: &'b mut Builder<'p, T>,
            ) -> Result<Self::View, _p::NotInSchema> {
                let tag = repr.0.data_field::<u16>(3usize);
                match tag {
                    0u16 => {
                        Ok(
                            Which::BadlyNamedGroup(
                                <_p::Group<
                                    BadlyNamedGroup,
                                > as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::BadlyNamedUnion::BADLY_NAMED_GROUP.field,
                                ),
                            ),
                        )
                    }
                    1u16 => {
                        Ok(
                            Which::Baz(
                                <_p::Struct<
                                    super::NestedStruct,
                                > as _p::field::FieldType>::accessor(
                                    &mut repr.0,
                                    &super::BadlyNamedUnion::BAZ.field,
                                ),
                            ),
                        )
                    }
                    unknown => Err(_p::NotInSchema(unknown)),
                }
            }
        }
        #[derive(Clone)]
        pub struct BadlyNamedGroup<T = _p::Family>(T);
        impl _p::ty::SchemaType for BadlyNamedGroup {
            const ID: u64 = 14076365459987674914u64;
        }
        impl<T> _p::IntoFamily for BadlyNamedGroup<T> {
            type Family = BadlyNamedGroup;
        }
        impl<T: _p::Capable> _p::Capable for BadlyNamedGroup<T> {
            type Table = T::Table;
            type Imbued = T::Imbued;
            type ImbuedWith<T2: _p::rpc::Table> = BadlyNamedGroup<T::ImbuedWith<T2>>;
            #[inline]
            fn imbued(&self) -> &Self::Imbued {
                self.0.imbued()
            }
            #[inline]
            fn imbue_release<T2: _p::rpc::Table>(
                self,
                new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
            ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
                let (imbued, old) = self.0.imbue_release(new_table);
                (BadlyNamedGroup(imbued), old)
            }
            #[inline]
            fn imbue_release_into<U>(
                &self,
                other: U,
            ) -> (U::ImbuedWith<Self::Table>, U::Imbued)
            where
                U: _p::Capable,
                U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
            {
                self.0.imbue_release_into(other)
            }
        }
        impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr
        for badly_named_group::Reader<'a, T> {
            type Ptr = _p::StructReader<'a, T>;
        }
        impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
        for badly_named_group::Reader<'a, T> {
            #[inline]
            fn from(ptr: _p::StructReader<'a, T>) -> Self {
                BadlyNamedGroup(ptr)
            }
        }
        impl<'a, T: _p::rpc::Table> core::convert::From<badly_named_group::Reader<'a, T>>
        for _p::StructReader<'a, T> {
            #[inline]
            fn from(reader: badly_named_group::Reader<'a, T>) -> Self {
                reader.0
            }
        }
        impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
        for badly_named_group::Reader<'a, T> {
            #[inline]
            fn as_ref(&self) -> &_p::StructReader<'a, T> {
                &self.0
            }
        }
        impl<'a, T: _p::rpc::Table> _p::ty::StructReader
        for badly_named_group::Reader<'a, T> {}
        impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr
        for badly_named_group::Builder<'a, T> {
            type Ptr = _p::StructBuilder<'a, T>;
        }
        impl<
            'a,
            T: _p::rpc::Table,
        > core::convert::From<badly_named_group::Builder<'a, T>>
        for _p::StructBuilder<'a, T> {
            #[inline]
            fn from(reader: badly_named_group::Builder<'a, T>) -> Self {
                reader.0
            }
        }
        impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
        for badly_named_group::Builder<'a, T> {
            #[inline]
            fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
                &self.0
            }
        }
        impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
        for badly_named_group::Builder<'a, T> {
            #[inline]
            fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
                &mut self.0
            }
        }
        impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder
        for badly_named_group::Builder<'a, T> {
            unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
                Self(ptr)
            }
        }
        impl _p::StructView for BadlyNamedGroup {
            type Reader<'a, T: _p::rpc::Table> = badly_named_group::Reader<'a, T>;
            type Builder<'a, T: _p::rpc::Table> = badly_named_group::Builder<'a, T>;
        }
        impl _p::FieldGroup for BadlyNamedGroup {
            unsafe fn clear<'a, 'b, T: _p::rpc::Table>(
                s: &'a mut _p::StructBuilder<'b, T>,
            ) {
                <() as _p::field::FieldType>::clear(s, &BadlyNamedGroup::FOO);
                <() as _p::field::FieldType>::clear(s, &BadlyNamedGroup::BAR);
            }
        }
        impl BadlyNamedGroup {
            const FOO: _p::Descriptor<()> = ();
            const BAR: _p::Descriptor<()> = ();
        }
        impl<'p, T: _p::rpc::Table + 'p> badly_named_group::Reader<'p, T> {
            #[inline]
            pub fn foo(&self) -> _p::Accessor<'_, 'p, T, ()> {
                unsafe {
                    <() as _p::field::FieldType>::accessor(
                        &self.0,
                        &BadlyNamedGroup::FOO,
                    )
                }
            }
            #[inline]
            pub fn bar(&self) -> _p::Accessor<'_, 'p, T, ()> {
                unsafe {
                    <() as _p::field::FieldType>::accessor(
                        &self.0,
                        &BadlyNamedGroup::BAR,
                    )
                }
            }
        }
        impl<'p, T: _p::rpc::Table + 'p> badly_named_group::Builder<'p, T> {
            #[inline]
            pub fn foo(&mut self) -> _p::AccessorMut<'_, 'p, T, ()> {
                unsafe {
                    <() as _p::field::FieldType>::accessor(
                        &mut self.0,
                        &BadlyNamedGroup::FOO,
                    )
                }
            }
            #[inline]
            pub fn bar(&mut self) -> _p::AccessorMut<'_, 'p, T, ()> {
                unsafe {
                    <() as _p::field::FieldType>::accessor(
                        &mut self.0,
                        &BadlyNamedGroup::BAR,
                    )
                }
            }
        }
        pub mod badly_named_group {
            use super::{__file, __imports, _p};
            pub type Reader<'a, T = _p::rpc::Empty> = super::BadlyNamedGroup<
                _p::StructReader<'a, T>,
            >;
            pub type Builder<'a, T = _p::rpc::Empty> = super::BadlyNamedGroup<
                _p::StructBuilder<'a, T>,
            >;
        }
    }
}
#[derive(Clone)]
pub struct TestImpliedFirstField<T = _p::Family>(T);
impl _p::ty::SchemaType for TestImpliedFirstField {
    const ID: u64 = 17073458209730106194u64;
}
impl<T> _p::IntoFamily for TestImpliedFirstField<T> {
    type Family = TestImpliedFirstField;
}
impl<T: _p::Capable> _p::Capable for TestImpliedFirstField<T> {
    type Table = T::Table;
    type Imbued = T::Imbued;
    type ImbuedWith<T2: _p::rpc::Table> = TestImpliedFirstField<T::ImbuedWith<T2>>;
    #[inline]
    fn imbued(&self) -> &Self::Imbued {
        self.0.imbued()
    }
    #[inline]
    fn imbue_release<T2: _p::rpc::Table>(
        self,
        new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
    ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
        let (imbued, old) = self.0.imbue_release(new_table);
        (TestImpliedFirstField(imbued), old)
    }
    #[inline]
    fn imbue_release_into<U>(&self, other: U) -> (U::ImbuedWith<Self::Table>, U::Imbued)
    where
        U: _p::Capable,
        U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
    {
        self.0.imbue_release_into(other)
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr
for test_implied_first_field::Reader<'a, T> {
    type Ptr = _p::StructReader<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
for test_implied_first_field::Reader<'a, T> {
    #[inline]
    fn from(ptr: _p::StructReader<'a, T>) -> Self {
        TestImpliedFirstField(ptr)
    }
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_implied_first_field::Reader<'a, T>>
for _p::StructReader<'a, T> {
    #[inline]
    fn from(reader: test_implied_first_field::Reader<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
for test_implied_first_field::Reader<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructReader<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructReader
for test_implied_first_field::Reader<'a, T> {}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr
for test_implied_first_field::Builder<'a, T> {
    type Ptr = _p::StructBuilder<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_implied_first_field::Builder<'a, T>>
for _p::StructBuilder<'a, T> {
    #[inline]
    fn from(reader: test_implied_first_field::Builder<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
for test_implied_first_field::Builder<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
for test_implied_first_field::Builder<'a, T> {
    #[inline]
    fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
        &mut self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder
for test_implied_first_field::Builder<'a, T> {
    unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
        Self(ptr)
    }
}
impl _p::StructView for TestImpliedFirstField {
    type Reader<'a, T: _p::rpc::Table> = test_implied_first_field::Reader<'a, T>;
    type Builder<'a, T: _p::rpc::Table> = test_implied_first_field::Builder<'a, T>;
}
impl _p::ty::Struct for TestImpliedFirstField {
    const SIZE: _p::StructSize = _p::StructSize {
        data: 1u16,
        ptrs: 3u16,
    };
}
impl TestImpliedFirstField {
    const TEXT_STRUCT: _p::Descriptor<
        _p::Struct<test_implied_first_field::TextStruct>,
    > = _p::Descriptor::<_p::Struct<test_implied_first_field::TextStruct>> {
        slot: 0u32,
        default: ::core::option::Option::Some(unsafe {
            _p::StructReader::slice_unchecked(
                &[
                    _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                    _p::Word([1u8, 0u8, 0u8, 0u8, 34u8, 0u8, 0u8, 0u8]),
                    _p::Word([102u8, 111u8, 111u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
                ],
                _p::StructSize {
                    data: 1u16,
                    ptrs: 1u16,
                },
            )
        }),
    };
    const TEXT_STRUCT_LIST: _p::Descriptor<
        _p::List<_p::Struct<test_implied_first_field::TextStruct>>,
    > = _p::Descriptor::<_p::List<_p::Struct<test_implied_first_field::TextStruct>>> {
        slot: 1u32,
        default: ::core::option::Option::None,
    };
    const INT_GROUP: _p::Descriptor<_p::Group<test_implied_first_field::IntGroup>> = ();
}
impl<'p, T: _p::rpc::Table + 'p> test_implied_first_field::Reader<'p, T> {
    #[inline]
    pub fn text_struct(
        &self,
    ) -> _p::Accessor<'_, 'p, T, _p::Struct<test_implied_first_field::TextStruct>> {
        unsafe {
            <_p::Struct<
                test_implied_first_field::TextStruct,
            > as _p::field::FieldType>::accessor(
                &self.0,
                &TestImpliedFirstField::TEXT_STRUCT,
            )
        }
    }
    #[inline]
    pub fn text_struct_list(
        &self,
    ) -> _p::Accessor<
        '_,
        'p,
        T,
        _p::List<_p::Struct<test_implied_first_field::TextStruct>>,
    > {
        unsafe {
            <_p::List<
                _p::Struct<test_implied_first_field::TextStruct>,
            > as _p::field::FieldType>::accessor(
                &self.0,
                &TestImpliedFirstField::TEXT_STRUCT_LIST,
            )
        }
    }
    #[inline]
    pub fn int_group(
        &self,
    ) -> _p::Accessor<'_, 'p, T, _p::Group<test_implied_first_field::IntGroup>> {
        unsafe {
            <_p::Group<
                test_implied_first_field::IntGroup,
            > as _p::field::FieldType>::accessor(
                &self.0,
                &TestImpliedFirstField::INT_GROUP,
            )
        }
    }
}
impl<'p, T: _p::rpc::Table + 'p> test_implied_first_field::Builder<'p, T> {
    #[inline]
    pub fn text_struct(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::Struct<test_implied_first_field::TextStruct>> {
        unsafe {
            <_p::Struct<
                test_implied_first_field::TextStruct,
            > as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestImpliedFirstField::TEXT_STRUCT,
            )
        }
    }
    #[inline]
    pub fn text_struct_list(
        &mut self,
    ) -> _p::AccessorMut<
        '_,
        'p,
        T,
        _p::List<_p::Struct<test_implied_first_field::TextStruct>>,
    > {
        unsafe {
            <_p::List<
                _p::Struct<test_implied_first_field::TextStruct>,
            > as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestImpliedFirstField::TEXT_STRUCT_LIST,
            )
        }
    }
    #[inline]
    pub fn int_group(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::Group<test_implied_first_field::IntGroup>> {
        unsafe {
            <_p::Group<
                test_implied_first_field::IntGroup,
            > as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestImpliedFirstField::INT_GROUP,
            )
        }
    }
    #[inline]
    pub fn into_text_struct(
        self,
    ) -> _p::AccessorOwned<'p, T, _p::Struct<test_implied_first_field::TextStruct>> {
        unsafe {
            <_p::Struct<
                test_implied_first_field::TextStruct,
            > as _p::field::FieldType>::accessor(
                self.0,
                &TestImpliedFirstField::TEXT_STRUCT,
            )
        }
    }
    #[inline]
    pub fn into_text_struct_list(
        self,
    ) -> _p::AccessorOwned<
        'p,
        T,
        _p::List<_p::Struct<test_implied_first_field::TextStruct>>,
    > {
        unsafe {
            <_p::List<
                _p::Struct<test_implied_first_field::TextStruct>,
            > as _p::field::FieldType>::accessor(
                self.0,
                &TestImpliedFirstField::TEXT_STRUCT_LIST,
            )
        }
    }
    #[inline]
    pub fn into_int_group(
        self,
    ) -> _p::AccessorOwned<'p, T, _p::Group<test_implied_first_field::IntGroup>> {
        unsafe {
            <_p::Group<
                test_implied_first_field::IntGroup,
            > as _p::field::FieldType>::accessor(
                self.0,
                &TestImpliedFirstField::INT_GROUP,
            )
        }
    }
}
pub mod test_implied_first_field {
    use super::{__file, __imports, _p};
    pub type Reader<'a, T = _p::rpc::Empty> = super::TestImpliedFirstField<
        _p::StructReader<'a, T>,
    >;
    pub type Builder<'a, T = _p::rpc::Empty> = super::TestImpliedFirstField<
        _p::StructBuilder<'a, T>,
    >;
    #[derive(Clone)]
    pub struct TextStruct<T = _p::Family>(T);
    impl _p::ty::SchemaType for TextStruct {
        const ID: u64 = 10399958892050652522u64;
    }
    impl<T> _p::IntoFamily for TextStruct<T> {
        type Family = TextStruct;
    }
    impl<T: _p::Capable> _p::Capable for TextStruct<T> {
        type Table = T::Table;
        type Imbued = T::Imbued;
        type ImbuedWith<T2: _p::rpc::Table> = TextStruct<T::ImbuedWith<T2>>;
        #[inline]
        fn imbued(&self) -> &Self::Imbued {
            self.0.imbued()
        }
        #[inline]
        fn imbue_release<T2: _p::rpc::Table>(
            self,
            new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
        ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
            let (imbued, old) = self.0.imbue_release(new_table);
            (TextStruct(imbued), old)
        }
        #[inline]
        fn imbue_release_into<U>(
            &self,
            other: U,
        ) -> (U::ImbuedWith<Self::Table>, U::Imbued)
        where
            U: _p::Capable,
            U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
        {
            self.0.imbue_release_into(other)
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for text_struct::Reader<'a, T> {
        type Ptr = _p::StructReader<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
    for text_struct::Reader<'a, T> {
        #[inline]
        fn from(ptr: _p::StructReader<'a, T>) -> Self {
            TextStruct(ptr)
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<text_struct::Reader<'a, T>>
    for _p::StructReader<'a, T> {
        #[inline]
        fn from(reader: text_struct::Reader<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
    for text_struct::Reader<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructReader<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructReader for text_struct::Reader<'a, T> {}
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for text_struct::Builder<'a, T> {
        type Ptr = _p::StructBuilder<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<text_struct::Builder<'a, T>>
    for _p::StructBuilder<'a, T> {
        #[inline]
        fn from(reader: text_struct::Builder<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
    for text_struct::Builder<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
    for text_struct::Builder<'a, T> {
        #[inline]
        fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
            &mut self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for text_struct::Builder<'a, T> {
        unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
            Self(ptr)
        }
    }
    impl _p::StructView for TextStruct {
        type Reader<'a, T: _p::rpc::Table> = text_struct::Reader<'a, T>;
        type Builder<'a, T: _p::rpc::Table> = text_struct::Builder<'a, T>;
    }
    impl _p::ty::Struct for TextStruct {
        const SIZE: _p::StructSize = _p::StructSize {
            data: 1u16,
            ptrs: 1u16,
        };
    }
    impl TextStruct {
        const TEXT: _p::Descriptor<_p::Text> = _p::Descriptor::<_p::Text> {
            slot: 0u32,
            default: ::core::option::Option::None,
        };
        const I: _p::Descriptor<u32> = _p::Descriptor::<u32> {
            slot: 0u32,
            default: 321u32,
        };
    }
    impl<'p, T: _p::rpc::Table + 'p> text_struct::Reader<'p, T> {
        #[inline]
        pub fn text(&self) -> _p::Accessor<'_, 'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::accessor(&self.0, &TextStruct::TEXT)
            }
        }
        #[inline]
        pub fn i(&self) -> _p::Accessor<'_, 'p, T, u32> {
            unsafe { <u32 as _p::field::FieldType>::accessor(&self.0, &TextStruct::I) }
        }
    }
    impl<'p, T: _p::rpc::Table + 'p> text_struct::Builder<'p, T> {
        #[inline]
        pub fn text(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::accessor(
                    &mut self.0,
                    &TextStruct::TEXT,
                )
            }
        }
        #[inline]
        pub fn i(&mut self) -> _p::AccessorMut<'_, 'p, T, u32> {
            unsafe {
                <u32 as _p::field::FieldType>::accessor(&mut self.0, &TextStruct::I)
            }
        }
        #[inline]
        pub fn into_text(self) -> _p::AccessorOwned<'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::accessor(self.0, &TextStruct::TEXT)
            }
        }
    }
    pub mod text_struct {
        use super::{__file, __imports, _p};
        pub type Reader<'a, T = _p::rpc::Empty> = super::TextStruct<
            _p::StructReader<'a, T>,
        >;
        pub type Builder<'a, T = _p::rpc::Empty> = super::TextStruct<
            _p::StructBuilder<'a, T>,
        >;
    }
    #[derive(Clone)]
    pub struct IntGroup<T = _p::Family>(T);
    impl _p::ty::SchemaType for IntGroup {
        const ID: u64 = 17683013451488578037u64;
    }
    impl<T> _p::IntoFamily for IntGroup<T> {
        type Family = IntGroup;
    }
    impl<T: _p::Capable> _p::Capable for IntGroup<T> {
        type Table = T::Table;
        type Imbued = T::Imbued;
        type ImbuedWith<T2: _p::rpc::Table> = IntGroup<T::ImbuedWith<T2>>;
        #[inline]
        fn imbued(&self) -> &Self::Imbued {
            self.0.imbued()
        }
        #[inline]
        fn imbue_release<T2: _p::rpc::Table>(
            self,
            new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
        ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
            let (imbued, old) = self.0.imbue_release(new_table);
            (IntGroup(imbued), old)
        }
        #[inline]
        fn imbue_release_into<U>(
            &self,
            other: U,
        ) -> (U::ImbuedWith<Self::Table>, U::Imbued)
        where
            U: _p::Capable,
            U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
        {
            self.0.imbue_release_into(other)
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for int_group::Reader<'a, T> {
        type Ptr = _p::StructReader<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
    for int_group::Reader<'a, T> {
        #[inline]
        fn from(ptr: _p::StructReader<'a, T>) -> Self {
            IntGroup(ptr)
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<int_group::Reader<'a, T>>
    for _p::StructReader<'a, T> {
        #[inline]
        fn from(reader: int_group::Reader<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
    for int_group::Reader<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructReader<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructReader for int_group::Reader<'a, T> {}
    impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for int_group::Builder<'a, T> {
        type Ptr = _p::StructBuilder<'a, T>;
    }
    impl<'a, T: _p::rpc::Table> core::convert::From<int_group::Builder<'a, T>>
    for _p::StructBuilder<'a, T> {
        #[inline]
        fn from(reader: int_group::Builder<'a, T>) -> Self {
            reader.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
    for int_group::Builder<'a, T> {
        #[inline]
        fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
            &self.0
        }
    }
    impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
    for int_group::Builder<'a, T> {
        #[inline]
        fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
            &mut self.0
        }
    }
    impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder for int_group::Builder<'a, T> {
        unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
            Self(ptr)
        }
    }
    impl _p::StructView for IntGroup {
        type Reader<'a, T: _p::rpc::Table> = int_group::Reader<'a, T>;
        type Builder<'a, T: _p::rpc::Table> = int_group::Builder<'a, T>;
    }
    impl _p::FieldGroup for IntGroup {
        unsafe fn clear<'a, 'b, T: _p::rpc::Table>(s: &'a mut _p::StructBuilder<'b, T>) {
            <u32 as _p::field::FieldType>::clear(s, &IntGroup::I);
            <_p::Text as _p::field::FieldType>::clear(s, &IntGroup::STR);
        }
    }
    impl IntGroup {
        const I: _p::Descriptor<u32> = _p::Descriptor::<u32> {
            slot: 0u32,
            default: 0u32,
        };
        const STR: _p::Descriptor<_p::Text> = _p::Descriptor::<_p::Text> {
            slot: 2u32,
            default: ::core::option::Option::Some(
                _p::text::Reader::from_slice(b"corge\0"),
            ),
        };
    }
    impl<'p, T: _p::rpc::Table + 'p> int_group::Reader<'p, T> {
        #[inline]
        pub fn i(&self) -> _p::Accessor<'_, 'p, T, u32> {
            unsafe { <u32 as _p::field::FieldType>::accessor(&self.0, &IntGroup::I) }
        }
        #[inline]
        pub fn str(&self) -> _p::Accessor<'_, 'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::accessor(&self.0, &IntGroup::STR)
            }
        }
    }
    impl<'p, T: _p::rpc::Table + 'p> int_group::Builder<'p, T> {
        #[inline]
        pub fn i(&mut self) -> _p::AccessorMut<'_, 'p, T, u32> {
            unsafe { <u32 as _p::field::FieldType>::accessor(&mut self.0, &IntGroup::I) }
        }
        #[inline]
        pub fn str(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::accessor(&mut self.0, &IntGroup::STR)
            }
        }
        #[inline]
        pub fn into_str(self) -> _p::AccessorOwned<'p, T, _p::Text> {
            unsafe {
                <_p::Text as _p::field::FieldType>::accessor(self.0, &IntGroup::STR)
            }
        }
    }
    pub mod int_group {
        use super::{__file, __imports, _p};
        pub type Reader<'a, T = _p::rpc::Empty> = super::IntGroup<
            _p::StructReader<'a, T>,
        >;
        pub type Builder<'a, T = _p::rpc::Empty> = super::IntGroup<
            _p::StructBuilder<'a, T>,
        >;
    }
}
pub const TEST_IMPLIED_FIRST_FIELD: _p::ty::ConstPtr<
    _p::Struct<TestImpliedFirstField>,
> = unsafe {
    _p::ty::ConstPtr::new(
        &[
            _p::Word([0u8, 0u8, 0u8, 0u8, 1u8, 0u8, 3u8, 0u8]),
            _p::Word([123u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([8u8, 0u8, 0u8, 0u8, 1u8, 0u8, 1u8, 0u8]),
            _p::Word([17u8, 0u8, 0u8, 0u8, 39u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([1u8, 0u8, 0u8, 0u8, 34u8, 0u8, 0u8, 0u8]),
            _p::Word([98u8, 97u8, 114u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([8u8, 0u8, 0u8, 0u8, 1u8, 0u8, 1u8, 0u8]),
            _p::Word([0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([9u8, 0u8, 0u8, 0u8, 34u8, 0u8, 0u8, 0u8]),
            _p::Word([58u8, 1u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([5u8, 0u8, 0u8, 0u8, 34u8, 0u8, 0u8, 0u8]),
            _p::Word([98u8, 97u8, 122u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
            _p::Word([113u8, 117u8, 120u8, 0u8, 0u8, 0u8, 0u8, 0u8]),
        ],
    )
};
#[derive(Clone)]
pub struct TestCycleANoCaps<T = _p::Family>(T);
impl _p::ty::SchemaType for TestCycleANoCaps {
    const ID: u64 = 13375596688656551808u64;
}
impl<T> _p::IntoFamily for TestCycleANoCaps<T> {
    type Family = TestCycleANoCaps;
}
impl<T: _p::Capable> _p::Capable for TestCycleANoCaps<T> {
    type Table = T::Table;
    type Imbued = T::Imbued;
    type ImbuedWith<T2: _p::rpc::Table> = TestCycleANoCaps<T::ImbuedWith<T2>>;
    #[inline]
    fn imbued(&self) -> &Self::Imbued {
        self.0.imbued()
    }
    #[inline]
    fn imbue_release<T2: _p::rpc::Table>(
        self,
        new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
    ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
        let (imbued, old) = self.0.imbue_release(new_table);
        (TestCycleANoCaps(imbued), old)
    }
    #[inline]
    fn imbue_release_into<U>(&self, other: U) -> (U::ImbuedWith<Self::Table>, U::Imbued)
    where
        U: _p::Capable,
        U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
    {
        self.0.imbue_release_into(other)
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_cycle_a_no_caps::Reader<'a, T> {
    type Ptr = _p::StructReader<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
for test_cycle_a_no_caps::Reader<'a, T> {
    #[inline]
    fn from(ptr: _p::StructReader<'a, T>) -> Self {
        TestCycleANoCaps(ptr)
    }
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_cycle_a_no_caps::Reader<'a, T>>
for _p::StructReader<'a, T> {
    #[inline]
    fn from(reader: test_cycle_a_no_caps::Reader<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
for test_cycle_a_no_caps::Reader<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructReader<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructReader
for test_cycle_a_no_caps::Reader<'a, T> {}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_cycle_a_no_caps::Builder<'a, T> {
    type Ptr = _p::StructBuilder<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_cycle_a_no_caps::Builder<'a, T>>
for _p::StructBuilder<'a, T> {
    #[inline]
    fn from(reader: test_cycle_a_no_caps::Builder<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
for test_cycle_a_no_caps::Builder<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
for test_cycle_a_no_caps::Builder<'a, T> {
    #[inline]
    fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
        &mut self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder
for test_cycle_a_no_caps::Builder<'a, T> {
    unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
        Self(ptr)
    }
}
impl _p::StructView for TestCycleANoCaps {
    type Reader<'a, T: _p::rpc::Table> = test_cycle_a_no_caps::Reader<'a, T>;
    type Builder<'a, T: _p::rpc::Table> = test_cycle_a_no_caps::Builder<'a, T>;
}
impl _p::ty::Struct for TestCycleANoCaps {
    const SIZE: _p::StructSize = _p::StructSize {
        data: 0u16,
        ptrs: 1u16,
    };
}
impl TestCycleANoCaps {
    const FOO: _p::Descriptor<_p::Struct<TestCycleBNoCaps>> = _p::Descriptor::<
        _p::Struct<TestCycleBNoCaps>,
    > {
        slot: 0u32,
        default: ::core::option::Option::None,
    };
}
impl<'p, T: _p::rpc::Table + 'p> test_cycle_a_no_caps::Reader<'p, T> {
    #[inline]
    pub fn foo(&self) -> _p::Accessor<'_, 'p, T, _p::Struct<TestCycleBNoCaps>> {
        unsafe {
            <_p::Struct<
                TestCycleBNoCaps,
            > as _p::field::FieldType>::accessor(&self.0, &TestCycleANoCaps::FOO)
        }
    }
}
impl<'p, T: _p::rpc::Table + 'p> test_cycle_a_no_caps::Builder<'p, T> {
    #[inline]
    pub fn foo(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Struct<TestCycleBNoCaps>> {
        unsafe {
            <_p::Struct<
                TestCycleBNoCaps,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestCycleANoCaps::FOO)
        }
    }
    #[inline]
    pub fn into_foo(self) -> _p::AccessorOwned<'p, T, _p::Struct<TestCycleBNoCaps>> {
        unsafe {
            <_p::Struct<
                TestCycleBNoCaps,
            > as _p::field::FieldType>::accessor(self.0, &TestCycleANoCaps::FOO)
        }
    }
}
pub mod test_cycle_a_no_caps {
    use super::{__file, __imports, _p};
    pub type Reader<'a, T = _p::rpc::Empty> = super::TestCycleANoCaps<
        _p::StructReader<'a, T>,
    >;
    pub type Builder<'a, T = _p::rpc::Empty> = super::TestCycleANoCaps<
        _p::StructBuilder<'a, T>,
    >;
}
#[derive(Clone)]
pub struct TestCycleBNoCaps<T = _p::Family>(T);
impl _p::ty::SchemaType for TestCycleBNoCaps {
    const ID: u64 = 9886200362498451516u64;
}
impl<T> _p::IntoFamily for TestCycleBNoCaps<T> {
    type Family = TestCycleBNoCaps;
}
impl<T: _p::Capable> _p::Capable for TestCycleBNoCaps<T> {
    type Table = T::Table;
    type Imbued = T::Imbued;
    type ImbuedWith<T2: _p::rpc::Table> = TestCycleBNoCaps<T::ImbuedWith<T2>>;
    #[inline]
    fn imbued(&self) -> &Self::Imbued {
        self.0.imbued()
    }
    #[inline]
    fn imbue_release<T2: _p::rpc::Table>(
        self,
        new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
    ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
        let (imbued, old) = self.0.imbue_release(new_table);
        (TestCycleBNoCaps(imbued), old)
    }
    #[inline]
    fn imbue_release_into<U>(&self, other: U) -> (U::ImbuedWith<Self::Table>, U::Imbued)
    where
        U: _p::Capable,
        U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
    {
        self.0.imbue_release_into(other)
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_cycle_b_no_caps::Reader<'a, T> {
    type Ptr = _p::StructReader<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
for test_cycle_b_no_caps::Reader<'a, T> {
    #[inline]
    fn from(ptr: _p::StructReader<'a, T>) -> Self {
        TestCycleBNoCaps(ptr)
    }
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_cycle_b_no_caps::Reader<'a, T>>
for _p::StructReader<'a, T> {
    #[inline]
    fn from(reader: test_cycle_b_no_caps::Reader<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
for test_cycle_b_no_caps::Reader<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructReader<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructReader
for test_cycle_b_no_caps::Reader<'a, T> {}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_cycle_b_no_caps::Builder<'a, T> {
    type Ptr = _p::StructBuilder<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_cycle_b_no_caps::Builder<'a, T>>
for _p::StructBuilder<'a, T> {
    #[inline]
    fn from(reader: test_cycle_b_no_caps::Builder<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
for test_cycle_b_no_caps::Builder<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
for test_cycle_b_no_caps::Builder<'a, T> {
    #[inline]
    fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
        &mut self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder
for test_cycle_b_no_caps::Builder<'a, T> {
    unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
        Self(ptr)
    }
}
impl _p::StructView for TestCycleBNoCaps {
    type Reader<'a, T: _p::rpc::Table> = test_cycle_b_no_caps::Reader<'a, T>;
    type Builder<'a, T: _p::rpc::Table> = test_cycle_b_no_caps::Builder<'a, T>;
}
impl _p::ty::Struct for TestCycleBNoCaps {
    const SIZE: _p::StructSize = _p::StructSize {
        data: 0u16,
        ptrs: 2u16,
    };
}
impl TestCycleBNoCaps {
    const FOO: _p::Descriptor<_p::List<_p::Struct<TestCycleANoCaps>>> = _p::Descriptor::<
        _p::List<_p::Struct<TestCycleANoCaps>>,
    > {
        slot: 0u32,
        default: ::core::option::Option::None,
    };
    const BAR: _p::Descriptor<_p::Struct<TestAllTypes>> = _p::Descriptor::<
        _p::Struct<TestAllTypes>,
    > {
        slot: 1u32,
        default: ::core::option::Option::None,
    };
}
impl<'p, T: _p::rpc::Table + 'p> test_cycle_b_no_caps::Reader<'p, T> {
    #[inline]
    pub fn foo(
        &self,
    ) -> _p::Accessor<'_, 'p, T, _p::List<_p::Struct<TestCycleANoCaps>>> {
        unsafe {
            <_p::List<
                _p::Struct<TestCycleANoCaps>,
            > as _p::field::FieldType>::accessor(&self.0, &TestCycleBNoCaps::FOO)
        }
    }
    #[inline]
    pub fn bar(&self) -> _p::Accessor<'_, 'p, T, _p::Struct<TestAllTypes>> {
        unsafe {
            <_p::Struct<
                TestAllTypes,
            > as _p::field::FieldType>::accessor(&self.0, &TestCycleBNoCaps::BAR)
        }
    }
}
impl<'p, T: _p::rpc::Table + 'p> test_cycle_b_no_caps::Builder<'p, T> {
    #[inline]
    pub fn foo(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::List<_p::Struct<TestCycleANoCaps>>> {
        unsafe {
            <_p::List<
                _p::Struct<TestCycleANoCaps>,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestCycleBNoCaps::FOO)
        }
    }
    #[inline]
    pub fn bar(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Struct<TestAllTypes>> {
        unsafe {
            <_p::Struct<
                TestAllTypes,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestCycleBNoCaps::BAR)
        }
    }
    #[inline]
    pub fn into_foo(
        self,
    ) -> _p::AccessorOwned<'p, T, _p::List<_p::Struct<TestCycleANoCaps>>> {
        unsafe {
            <_p::List<
                _p::Struct<TestCycleANoCaps>,
            > as _p::field::FieldType>::accessor(self.0, &TestCycleBNoCaps::FOO)
        }
    }
    #[inline]
    pub fn into_bar(self) -> _p::AccessorOwned<'p, T, _p::Struct<TestAllTypes>> {
        unsafe {
            <_p::Struct<
                TestAllTypes,
            > as _p::field::FieldType>::accessor(self.0, &TestCycleBNoCaps::BAR)
        }
    }
}
pub mod test_cycle_b_no_caps {
    use super::{__file, __imports, _p};
    pub type Reader<'a, T = _p::rpc::Empty> = super::TestCycleBNoCaps<
        _p::StructReader<'a, T>,
    >;
    pub type Builder<'a, T = _p::rpc::Empty> = super::TestCycleBNoCaps<
        _p::StructBuilder<'a, T>,
    >;
}
#[derive(Clone)]
pub struct TestCycleAWithCaps<T = _p::Family>(T);
impl _p::ty::SchemaType for TestCycleAWithCaps {
    const ID: u64 = 10517235811239054007u64;
}
impl<T> _p::IntoFamily for TestCycleAWithCaps<T> {
    type Family = TestCycleAWithCaps;
}
impl<T: _p::Capable> _p::Capable for TestCycleAWithCaps<T> {
    type Table = T::Table;
    type Imbued = T::Imbued;
    type ImbuedWith<T2: _p::rpc::Table> = TestCycleAWithCaps<T::ImbuedWith<T2>>;
    #[inline]
    fn imbued(&self) -> &Self::Imbued {
        self.0.imbued()
    }
    #[inline]
    fn imbue_release<T2: _p::rpc::Table>(
        self,
        new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
    ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
        let (imbued, old) = self.0.imbue_release(new_table);
        (TestCycleAWithCaps(imbued), old)
    }
    #[inline]
    fn imbue_release_into<U>(&self, other: U) -> (U::ImbuedWith<Self::Table>, U::Imbued)
    where
        U: _p::Capable,
        U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
    {
        self.0.imbue_release_into(other)
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_cycle_a_with_caps::Reader<'a, T> {
    type Ptr = _p::StructReader<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
for test_cycle_a_with_caps::Reader<'a, T> {
    #[inline]
    fn from(ptr: _p::StructReader<'a, T>) -> Self {
        TestCycleAWithCaps(ptr)
    }
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_cycle_a_with_caps::Reader<'a, T>>
for _p::StructReader<'a, T> {
    #[inline]
    fn from(reader: test_cycle_a_with_caps::Reader<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
for test_cycle_a_with_caps::Reader<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructReader<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructReader
for test_cycle_a_with_caps::Reader<'a, T> {}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_cycle_a_with_caps::Builder<'a, T> {
    type Ptr = _p::StructBuilder<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_cycle_a_with_caps::Builder<'a, T>>
for _p::StructBuilder<'a, T> {
    #[inline]
    fn from(reader: test_cycle_a_with_caps::Builder<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
for test_cycle_a_with_caps::Builder<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
for test_cycle_a_with_caps::Builder<'a, T> {
    #[inline]
    fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
        &mut self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder
for test_cycle_a_with_caps::Builder<'a, T> {
    unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
        Self(ptr)
    }
}
impl _p::StructView for TestCycleAWithCaps {
    type Reader<'a, T: _p::rpc::Table> = test_cycle_a_with_caps::Reader<'a, T>;
    type Builder<'a, T: _p::rpc::Table> = test_cycle_a_with_caps::Builder<'a, T>;
}
impl _p::ty::Struct for TestCycleAWithCaps {
    const SIZE: _p::StructSize = _p::StructSize {
        data: 0u16,
        ptrs: 1u16,
    };
}
impl TestCycleAWithCaps {
    const FOO: _p::Descriptor<_p::Struct<TestCycleBWithCaps>> = _p::Descriptor::<
        _p::Struct<TestCycleBWithCaps>,
    > {
        slot: 0u32,
        default: ::core::option::Option::None,
    };
}
impl<'p, T: _p::rpc::Table + 'p> test_cycle_a_with_caps::Reader<'p, T> {
    #[inline]
    pub fn foo(&self) -> _p::Accessor<'_, 'p, T, _p::Struct<TestCycleBWithCaps>> {
        unsafe {
            <_p::Struct<
                TestCycleBWithCaps,
            > as _p::field::FieldType>::accessor(&self.0, &TestCycleAWithCaps::FOO)
        }
    }
}
impl<'p, T: _p::rpc::Table + 'p> test_cycle_a_with_caps::Builder<'p, T> {
    #[inline]
    pub fn foo(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::Struct<TestCycleBWithCaps>> {
        unsafe {
            <_p::Struct<
                TestCycleBWithCaps,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestCycleAWithCaps::FOO)
        }
    }
    #[inline]
    pub fn into_foo(self) -> _p::AccessorOwned<'p, T, _p::Struct<TestCycleBWithCaps>> {
        unsafe {
            <_p::Struct<
                TestCycleBWithCaps,
            > as _p::field::FieldType>::accessor(self.0, &TestCycleAWithCaps::FOO)
        }
    }
}
pub mod test_cycle_a_with_caps {
    use super::{__file, __imports, _p};
    pub type Reader<'a, T = _p::rpc::Empty> = super::TestCycleAWithCaps<
        _p::StructReader<'a, T>,
    >;
    pub type Builder<'a, T = _p::rpc::Empty> = super::TestCycleAWithCaps<
        _p::StructBuilder<'a, T>,
    >;
}
#[derive(Clone)]
pub struct TestCycleBWithCaps<T = _p::Family>(T);
impl _p::ty::SchemaType for TestCycleBWithCaps {
    const ID: u64 = 17813587854411418758u64;
}
impl<T> _p::IntoFamily for TestCycleBWithCaps<T> {
    type Family = TestCycleBWithCaps;
}
impl<T: _p::Capable> _p::Capable for TestCycleBWithCaps<T> {
    type Table = T::Table;
    type Imbued = T::Imbued;
    type ImbuedWith<T2: _p::rpc::Table> = TestCycleBWithCaps<T::ImbuedWith<T2>>;
    #[inline]
    fn imbued(&self) -> &Self::Imbued {
        self.0.imbued()
    }
    #[inline]
    fn imbue_release<T2: _p::rpc::Table>(
        self,
        new_table: <Self::ImbuedWith<T2> as _p::Capable>::Imbued,
    ) -> (Self::ImbuedWith<T2>, Self::Imbued) {
        let (imbued, old) = self.0.imbue_release(new_table);
        (TestCycleBWithCaps(imbued), old)
    }
    #[inline]
    fn imbue_release_into<U>(&self, other: U) -> (U::ImbuedWith<Self::Table>, U::Imbued)
    where
        U: _p::Capable,
        U::ImbuedWith<Self::Table>: _p::Capable<Imbued = Self::Imbued>,
    {
        self.0.imbue_release_into(other)
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_cycle_b_with_caps::Reader<'a, T> {
    type Ptr = _p::StructReader<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<_p::StructReader<'a, T>>
for test_cycle_b_with_caps::Reader<'a, T> {
    #[inline]
    fn from(ptr: _p::StructReader<'a, T>) -> Self {
        TestCycleBWithCaps(ptr)
    }
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_cycle_b_with_caps::Reader<'a, T>>
for _p::StructReader<'a, T> {
    #[inline]
    fn from(reader: test_cycle_b_with_caps::Reader<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructReader<'a, T>>
for test_cycle_b_with_caps::Reader<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructReader<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructReader
for test_cycle_b_with_caps::Reader<'a, T> {}
impl<'a, T: _p::rpc::Table> _p::ty::TypedPtr for test_cycle_b_with_caps::Builder<'a, T> {
    type Ptr = _p::StructBuilder<'a, T>;
}
impl<'a, T: _p::rpc::Table> core::convert::From<test_cycle_b_with_caps::Builder<'a, T>>
for _p::StructBuilder<'a, T> {
    #[inline]
    fn from(reader: test_cycle_b_with_caps::Builder<'a, T>) -> Self {
        reader.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsRef<_p::StructBuilder<'a, T>>
for test_cycle_b_with_caps::Builder<'a, T> {
    #[inline]
    fn as_ref(&self) -> &_p::StructBuilder<'a, T> {
        &self.0
    }
}
impl<'a, T: _p::rpc::Table> core::convert::AsMut<_p::StructBuilder<'a, T>>
for test_cycle_b_with_caps::Builder<'a, T> {
    #[inline]
    fn as_mut(&mut self) -> &mut _p::StructBuilder<'a, T> {
        &mut self.0
    }
}
impl<'a, T: _p::rpc::Table> _p::ty::StructBuilder
for test_cycle_b_with_caps::Builder<'a, T> {
    unsafe fn from_ptr(ptr: Self::Ptr) -> Self {
        Self(ptr)
    }
}
impl _p::StructView for TestCycleBWithCaps {
    type Reader<'a, T: _p::rpc::Table> = test_cycle_b_with_caps::Reader<'a, T>;
    type Builder<'a, T: _p::rpc::Table> = test_cycle_b_with_caps::Builder<'a, T>;
}
impl _p::ty::Struct for TestCycleBWithCaps {
    const SIZE: _p::StructSize = _p::StructSize {
        data: 0u16,
        ptrs: 2u16,
    };
}
impl TestCycleBWithCaps {
    const FOO: _p::Descriptor<_p::List<_p::Struct<TestCycleAWithCaps>>> = _p::Descriptor::<
        _p::List<_p::Struct<TestCycleAWithCaps>>,
    > {
        slot: 0u32,
        default: ::core::option::Option::None,
    };
    const BAR: _p::Descriptor<_p::AnyPtr> = _p::Descriptor::<_p::AnyPtr> {
        slot: 1u32,
        default: ::core::option::Option::None,
    };
}
impl<'p, T: _p::rpc::Table + 'p> test_cycle_b_with_caps::Reader<'p, T> {
    #[inline]
    pub fn foo(
        &self,
    ) -> _p::Accessor<'_, 'p, T, _p::List<_p::Struct<TestCycleAWithCaps>>> {
        unsafe {
            <_p::List<
                _p::Struct<TestCycleAWithCaps>,
            > as _p::field::FieldType>::accessor(&self.0, &TestCycleBWithCaps::FOO)
        }
    }
    #[inline]
    pub fn bar(&self) -> _p::Accessor<'_, 'p, T, _p::AnyPtr> {
        unsafe {
            <_p::AnyPtr as _p::field::FieldType>::accessor(
                &self.0,
                &TestCycleBWithCaps::BAR,
            )
        }
    }
}
impl<'p, T: _p::rpc::Table + 'p> test_cycle_b_with_caps::Builder<'p, T> {
    #[inline]
    pub fn foo(
        &mut self,
    ) -> _p::AccessorMut<'_, 'p, T, _p::List<_p::Struct<TestCycleAWithCaps>>> {
        unsafe {
            <_p::List<
                _p::Struct<TestCycleAWithCaps>,
            > as _p::field::FieldType>::accessor(&mut self.0, &TestCycleBWithCaps::FOO)
        }
    }
    #[inline]
    pub fn bar(&mut self) -> _p::AccessorMut<'_, 'p, T, _p::AnyPtr> {
        unsafe {
            <_p::AnyPtr as _p::field::FieldType>::accessor(
                &mut self.0,
                &TestCycleBWithCaps::BAR,
            )
        }
    }
    #[inline]
    pub fn into_foo(
        self,
    ) -> _p::AccessorOwned<'p, T, _p::List<_p::Struct<TestCycleAWithCaps>>> {
        unsafe {
            <_p::List<
                _p::Struct<TestCycleAWithCaps>,
            > as _p::field::FieldType>::accessor(self.0, &TestCycleBWithCaps::FOO)
        }
    }
    #[inline]
    pub fn into_bar(self) -> _p::AccessorOwned<'p, T, _p::AnyPtr> {
        unsafe {
            <_p::AnyPtr as _p::field::FieldType>::accessor(
                self.0,
                &TestCycleBWithCaps::BAR,
            )
        }
    }
}
pub mod test_cycle_b_with_caps {
    use super::{__file, __imports, _p};
    pub type Reader<'a, T = _p::rpc::Empty> = super::TestCycleBWithCaps<
        _p::StructReader<'a, T>,
    >;
    pub type Builder<'a, T = _p::rpc::Empty> = super::TestCycleBWithCaps<
        _p::StructBuilder<'a, T>,
    >;
}
